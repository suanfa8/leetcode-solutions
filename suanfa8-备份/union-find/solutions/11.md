# 「力扣」第 952 题：按公因数计算最大组件大小（困难）

- 题目链接：[952. 按公因数计算最大组件大小](https://leetcode-cn.com/problems/largest-component-size-by-common-factor/)；
- 题解链接：[并查集（Java、Python）](https://leetcode-cn.com/problems/largest-component-size-by-common-factor/solution/bing-cha-ji-java-python-by-liweiwei1419/)。

## 题目描述

给定一个由不同正整数的组成的非空数组 `A`，考虑下面的图：

- 有 `A.length` 个节点，按从 `A[0]` 到 `A[A.length - 1]` 标记；
- 只有当 `A[i]` 和 `A[j]` 共用一个大于 1 的公因数时，`A[i]` 和 `A[j]` 之间才有一条边。

返回图中最大连通组件的大小。

**示例 1：**

```
输入：[4,6,15,35]
输出：4
```

![](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/202305031700340.png)

**示例 2：**

```
输入：[20,50,9,63]
输出：2
```

![](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/202305031700820.png)

**示例 3：**

```
输入：[2,3,6,7,4,12,21,39]
输出：8
```

![](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/202305031700447.png)

**提示：**

1. `1 <= A.length <= 20000`
2. `1 <= A[i] <= 100000`

## 思路分析

这道题题目都直接画成了连通图，显然可以考虑使用并查集。

1、这些数的所有质因子，是连接不同候选数的桥梁，即两个数因为有了相同的质因子，它们才能在一个连通分量里；

2、最大连通组件那里，要绕一个弯子，对于候选数组中的每一个数，查询一下这个数在并查集中的代表元（即根结点是谁），然后做一个计数统计，记录那个出现最多的代表元的个数即可。

![](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/202305031700714.png)

![](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/202305031701754.png)


**参考代码**：

Java 代码：
```java
public class Solution {

    public int largestComponentSize(int[] A) {
        int maxVal = 0;
        for (int num : A) {
            maxVal = Math.max(maxVal, num);
        }

        // 0 位置不使用，因此需要 + 1
        UnionFind unionFind = new UnionFind(maxVal + 1);

        for (int num : A) {
            double upBound = Math.sqrt(num);
            for (int i = 2; i <= upBound; i++) {
                if (num % i == 0) {
                    unionFind.union(num, i);
                    unionFind.union(num, num / i);
                }
            }
        }

        // 将候选数组映射成代表元，统计代表元出现的次数，找出最大者
        int[] cnt = new int[maxVal + 1];
        int res = 0;
        for (int num : A) {
            int root = unionFind.find(num);
            cnt[root]++;
            res = Math.max(res, cnt[root]);
        }
        return res;
    }

    private class UnionFind {

        private int[] parent;

        public UnionFind(int n) {
            parent = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }

        // 使用了路径压缩
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }

        // 没有实现按秩合并
        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rootX != rootY) {
                parent[rootX] = rootY;
            }
        }
    }

}

````
Python 代码：
```python
from math import sqrt
from typing import List


class Solution:

    def largestComponentSize(self, A: List[int]) -> int:

        class UnionFind:
            def __init__(self, n):
                self.parent = [i for i in range(n)]

            def union(self, x, y):
                root_x = self.find(x)
                root_y = self.find(y)
                if root_x != root_y:
                    self.parent[root_x] = root_y

            def find(self, x):
                while x != self.parent[x]:
                    self.parent[x] = self.parent[self.parent[x]]
                    x = self.parent[x]
                return x

        max_val = max(A)
        union_find = UnionFind(max_val + 1)

        for num in A:
            up_bound = int(sqrt(num))
            for i in range(2, up_bound + 1):
                if num % i == 0:
                    union_find.union(num, i)
                    union_find.union(num, num // i)

        cnt = [0 for _ in range(max_val + 1)]
        res = 0
        for num in A:
            root = union_find.find(num)
            cnt[root] += 1
            res = max(res, cnt[root])
        return res
````




---

作者：liweiwei1419
链接：https://suanfa8.com/union-find/solutions/0952-largest-component-size-by-common-factor
来源：算法吧
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。