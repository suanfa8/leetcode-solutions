# 「力扣」第 35 题：搜索插入位置（简单）

![](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/suanfa8/202305261925464.png)

- 题目链接：[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)；
- 题解链接：[写对二分查找不是套模板并往里面填空，需要仔细分析题意](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)。

## 题目描述

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1：**

```
输入: [1, 3, 5, 6], 5
输出: 2
```

**示例 2：**

```
输入: [1, 3, 5, 6], 2
输出: 1
```

**示例 3：**

```
输入: [1, 3, 5, 6], 7
输出: 4
```

**示例 4：**

```
输入: [1, 3, 5, 6], 0
输出: 0
```

**示例 5:**

```
输入: nums = [1], target = 0
输出: 0
```


**提示:**

- $1 <= nums.length <= 10^4$
- $-10^4 <= nums[i] <= 10^4$
- `nums` 为 **无重复元素** 的 **升序** 排列数组
- $-10^4 <= target <= 10^4$




## 一、题意分析

- 根据「示例 1」和「示例 2」，可知：题目要我们找出第 1 个 **大于等于** 目标元素的下标。**这一点是解对这个问题的前提，如果题意分析错误，代码肯定写不对**；
- 根据「示例 3」，可知：如果目标元素 **严格大于** 输入数组的最后一个元素，题目要我们返回数组的最后一个元素的下标 `+1`（也就是数组的长度）。「示例 3」说明了特殊情况时应该返回什么，因为很有可能输入数组中并不存在大于等于目标元素的数字；
- **注意**：题目最后的「提示」中说，`nums` 不为空，`nums` 没有重复元素。

## 二、思路分析

在 **有序数组** 中查找符合条件的某个数（或者它的下标），可以使用二分查找。即根据搜索区间中间位置 `mid` 的值，判断下一轮搜索区间在哪里。

根据「题意分析」中对示例的描述：

- **情况 1**：如果当前 `mid` 看到的数值严格小于 `target`，那么 `mid` 以及 `mid` 左边的所有元素就一定不是「插入元素的位置」，因此下一轮搜索区间是 `[mid + 1..right]`，下一轮把 `left` 移动到 `mid + 1` 位置，因此设置 `left = mid + 1`；


- **情况 2**：否则。如果 `mid` 看到的数值大于等于 `target`，那么 `mid` **可能是「插入元素的位置」**，`mid` 的右边一定不存在「插入元素的位置」。如果 `mid` 的左边不存在「插入元素的位置」，我们才可以说 `mid` 是「插入元素的位置」。因此下一轮搜索区间是 `[left..mid]`，下一轮把 `right` 移动到 `mid` 位置，因此设置 `right = mid`。

**说明**：上面的两点中，「情况 2」其实不用分析得那么细致， 因为只要「情况 1」的区间分析是正确的，「情况 2」一定是「情况 1」得到的区间的反面区间。

## 三、本题的特点 

看到一个数大于等于目标元素，此时不能说它是第一个大于等于目标元素的元素。

- 如果它的左边没有大于等于目标元素的元素，它才是第一个大于等于目标元素的元素；
- 如果它的左边有大于等于目标元素的元素，它不是第一个大于等于目标元素的元素。

就是这样的特点决定了：**这个问题的答案是需要再退出循环以后才能得到的**。


## 四、参考代码

如果你非常清楚「二分查找」，或者看过我讲的「二分查找」的视频或者题解，下面的代码应该不难理解。我在「五、其它代码讲解」会说明：其它代码和我这里给出的代码其实是一样的。

**参考代码 1**：

```java
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        // 特殊判断
        if (nums[len - 1] < target) {
            return len;
        }

        // 程序走到这里一定有 nums[len - 1] >= target，插入位置在区间 [0..len - 1]
        int left = 0;
        int right = len - 1;
        // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target){
                // 下一轮搜索的区间是 [mid + 1..right]
                left = mid + 1;
            } else {
                // 下一轮搜索的区间是 [left..mid]
                right = mid;
            }
        }
        return left;
    }
}
```

**说明**：`while (left < right)` 表示当 `left` 与 `right` 重合的时候，搜索终止。**根据题意和示例**，区间 `nums[left..right]` 里一定存在「插入元素的位置」，且 `while` 循环里只把区间分成两个部分，退出循环的时候一定有 `left == right` 成立，因此返回 `left` 或者 `right` 都可以。

**复杂度分析**：

- 时间复杂度：$O(\log N)$，这里 $N$ 是输入数组的长度；
- 空间复杂度：$O(1)$。

既然 `len` 也有可能是答案，可以在初始化的时候，把 `right` 设置成 `len`，在一开始的时候就不需要特殊判断了。

**参考代码 2**：

```java
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        int left = 0;
        int right = len;
        // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target){
                // 下一轮搜索的区间是 [mid + 1..right]
                left = mid + 1;
            } else {
                // 下一轮搜索的区间是 [left..mid]
                right = mid;
            }
        }
        return left;
    }
}
```

**复杂度分析**：（同参考代码 1）。


因为题目的最后说：`nums` 中没有重复元素，所以可以在循环体里面加一个判断：

```java
if (nums[mid] == target) {
    return mid;
}
```


## 五、其它代码讲解

**代码 1**：

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int n = nums.length;
        int left = 0, right = n - 1, ans = n;
        while (left <= right) {
            int mid = ((right - left) >> 1) + left;
            if (target <= nums[mid]) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
}
```


作者：LeetCode-Solution
链接：https://leetcode.cn/problems/search-insert-position/solution/sou-suo-cha-ru-wei-zhi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


**解释**：

- 这里的 `ans` 的含义是，把有可能是题目答案的结果用 `ans` 保存起来，所以 `ans` 初始化的时候应该设置为 `n`（根据 「示例」3）；
- 在 `if` 语句里 `nums[mid] >= target` 的时候，`mid` 位置有可能是问题的答案，所以需要用 `ans` 把 `mid` 保存起来（根据「二、思路分析」「情况 2」）；
- 最后要返回 `ans`。

由于有了 `ans` 变量，并且在 `if` 和 `else` 语句中 `left` 一定是 `mid + 1`，`right` 一定是 `mid - 1`，这种情况不会出现死循环，所以 `while` 里面可以写 `left <= right`。

其实这里的「代码 1」和上面给出的「参考代码 1」「参考代码 2」是一样的。其中：

- `ans` 的含义是：搜索区间的右边界；
- `right` 的含义是： 搜索区间的右边界 `-1`。


**代码 2**：

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while(left <= right) {
            int mid = (left + right) / 2;
            if(nums[mid] == target) {
                return mid;
            } else if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}

```

作者：guanpengchn
链接：https://leetcode.cn/problems/search-insert-position/solution/hua-jie-suan-fa-35-sou-suo-cha-ru-wei-zhi-by-guanp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


**解释**：

- 这一版代码里，所有关于右边界的设置，都要比真正的右边界少 $1$。也就是说，如果作者分析出搜索区间是 `[10, 20]`，他在代码里设置 `left = 10`, `right = 19`。除此之外，和「四、参考代码」里的「参考代码 2」是一样的；
- 因为数组的长度有可能是问题的答案，作者固定死了设置右边界的时候 `-1`，所以初始化的时候 `right = nums.length - 1;`；
- 循环体里面 `if (nums[mid] == target)` 我前面分析过，直接返回 `mid` 就好了，这里没有设置右边界；
- `else if (nums[mid] < target)` 我前面也分析过，此时设置左边界；
- `else` 是 `nums[mid] > target` 的时候，此时本该设置 `right = mid`，但是作者固定死了设置右边界的时候 `-1`，所以这里写 `right = mid - 1;`
- 因为固定死了设置右边界的时候 `-1`，所以退出循环的时候，`left` 和 `right` 不重合，`right` 比 `left` 少 `1`，所以返回 `left` 正确，返回 `right` 不正确，应该返回 `right + 1`，大家可以自己验证。

为什么 `while (left <= right)` 正确，还是因为固定死了设置右边界的时候 `-1`。当 `left` 与 `right` 重合的时候，虽然区间 `[left..right]` 里只有一个数，但是真正的右边界是 `right + 1`，所以此时还应该继续搜索下去。


## 六、总结

「二分查找」的写法很多、细节也很多。希望大家一定要有耐心，遇到问题的时候自己调试，把变量的值打印出来看一眼。

我相信，真正掌握「二分查找」的朋友，不是因为他（她）背下了「二分查找」的模板，而是他（她）对题目的意思有准确的理解。

就本题而言，一定要分析出：

- 数组的长度有可能是问题的答案，也就是 `nums.length` 有可能是问题的答案，如果不讨论，答案肯定错；
- 当 `nums[mid] >= target` 的时候，`mid` 有可能是问题的答案，如果直接去掉，也肯定错，这一点在「三、本题的特点 」里专门强调过。

任何模板都不会覆盖上面的信息，上面也和大家解释了其它版本的代码正确也离不开对上面两点的分析，本质上本题解里出现的代码都是一样的，所以审题很重要。

希望我的讲解对大家有帮助！



---

作者：liweiwei1419
链接：https://suanfa8.com/binary-search/solutions-1/0035-search-insert-position
来源：算法吧
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。