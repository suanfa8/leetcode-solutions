# 「力扣」第 581 题：最短无序连续子数组（中等）

- 题目链接：[581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)；
- 题解链接：[「力扣」第 581 题：最短无序连续子数组（栈、单调栈）](https://blog.csdn.net/lw_power/article/details/106386048)。

## 题目描述

给你一个整数数组 `nums` ，你需要找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的 **最短** 子数组，并输出它的长度。

**示例 1：**

```
输入：nums = [2, 6, 4, 8, 10, 9, 15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
```

**示例 2：**

```
输入：nums = [1, 2, 3, 4]
输出：0
```

**示例 3：**

```
输入：nums = [1]
输出：0
```

**提示：**

- $1 \le nums.length \le 10^4$
- $-10^5 \le nums[i] \le 10^5$

**进阶：** 你可以设计一个时间复杂度为 $O(n)$ 的解决方案吗？

## 理解题意（重要）

这道问题关键在于审题，题目只要求我们返回「最短的连续子区间」的长度，重点是：**只要求返回长度，不要求返回具体是哪些值**。

## 想法的由来（重要）

观察示例 1：

![从左向右找逆序、从右向左也找逆序](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/202301250100684.png)

可知：

- 如果一个数的左边有比自己还大的数（构成逆序关系），那么当前这个数的位置就需要参与排序；
- 同理：如果一个数的右边有比自己还小的数（也构成逆序关系），那么当前这个数的位置就需要参与排序；

因此，我们可以从左向右遍历，一边遍历、一边找出「当前遍历到的最大值」，只要当前位置的数值比「当前遍历到的最大值」小，就 **更新「当前位置」**。遍历完成以后，找到需要参与排序的右边界 `rightBound`。

同理：我们再从右向左遍历，一边遍历、一边找出「当前遍历到的最小值」，只要当前位置的数值比「当前遍历到的最小值」大，就更新「当前位置」。遍历完成以后，找到需要参与排序的左边界 `leftBound`。（到这里为止，已经描述清楚思路和算法，请见「参考代码 1」）。

### 方法一：两次遍历

- 第一次遍历找出右边界 `rightBound`：关注自己的左边，如果存在数值比自己大，就记录自己的下标，所以遍历找最大值；
- 第二次遍历找出左边界 `leftBound`：关注自己的右边，如果存在数值比自己小，就记录自己的下标，所以遍历找最小值；

> 说明：[官方题解](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/solution/zui-duan-wu-xu-lian-xu-zi-shu-zu-by-leet-yhlf/) 的「方法二：一次遍历」和我这里的代码本质上是一样的，时间复杂度也完全相同。我这里给出的代码是两次遍历，每次遍历只做一件事情。官方题解中的代码是一次遍历，在一次遍历的时候，通过下标的转换（`nums[i]` 与 `nums[n - i - 1]`）把两次遍历需要做的事情给做了。

**参考代码 1**：

```java
public class Solution {

    public int findUnsortedSubarray(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return 0;
        }

        int maxVal = nums[0];
        int rightBound = 0;
        for (int i = 1; i < len; i++) {
            maxVal = Math.max(maxVal, nums[i]);
            if (nums[i] < maxVal) {
                rightBound = i;
            }
        }

        int leftBound = len - 1;
        int minValue = nums[len - 1];
        for (int i = len - 2; i >= 0; i--) {
            minValue = Math.min(minValue, nums[i]);
            if (nums[i] > minValue) {
                leftBound = i;
            }
        }

        // 区间 [leftBound..rightBound] 需要参与排序
        if (rightBound > leftBound) {
            return rightBound - leftBound + 1;
        }
        return 0;
    }
}
```

**说明**：`if (rightBound > leftBound)` 这里需要判断是因为如果整个数组有序，`rightBound` 和 `leftBound` 就没有意义，因此不可以返回 `rightBound - leftBound + 1;`，可以结合「力扣」给出的错误提示理解。

![](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/202301250101033.png)

**时间复杂度**：$O(N)$，这里 $N$ 是输入输入的长度。

### 方法二：使用「栈」

> 友情提示：文字部分稍显晦涩，请大家结合具体例子（可以对照上面的图）和代码进行理解。

还可以借助有关「栈」的结论：通过 **出栈元素的下标** 找到需要修改的「左边界最小值」和「右边界最大值」。

例如：`[2, 6, 7, 8]` 后面来一个 `3` ，可以把前面的 `8`、`7`、`6` 依次拿掉，找到 `3` 的左边「第一个比自己小的元素」`2` 的位置，但其实 `2` 的右边的 `6` 的下标才是我们需要找的需要重新参与排序的下标，所以需要记录出栈元素下标的最小值（可以结合代码进行理解）。

**关键**：**出栈的时候记录下标**。

**参考代码 2**：

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Solution {

    public int findUnsortedSubarray(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return 0;
        }

        int leftBound = len - 1;
        int rightBound = 0;

        // 重点：栈用于找最近比 nums[i] 严格大的元素的下标
        Deque<Integer> stack = new ArrayDeque<>(len);
        for (int i = 0; i < len; i++) {
            // 这里有点绕：找右边「第一个」比它严格大的元素，这里的 while 不要忘记，保留的是最左边的下标
            while (!stack.isEmpty() && nums[i] < nums[stack.peekLast()]) {
                leftBound = Math.min(leftBound, stack.removeLast());
            }
            stack.addLast(i);
        }

        stack.clear();
        for (int i = len - 1; i >= 0; i--) {
            while (!stack.isEmpty() && nums[i] > nums[stack.peekLast()]) {
                rightBound = Math.max(rightBound, stack.removeLast());
            }
            stack.addLast(i);
        }

        if (rightBound > leftBound) {
            return rightBound - leftBound + 1;
        }
        return 0;
    }
}
```

**时间复杂度**：$O(N)$，这里 $N$ 是输入输入的长度。所有的元素最多进栈一次、出栈一次。




---

作者：liweiwei1419
链接：https://suanfa8.com/stack/solutions-2/0581-shortest-unsorted-continuous-subarray
来源：算法吧
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。