# 第 13.7 节 区间 DP 与划分型 DP 问题选讲

区间 DP ，顾名思义是以「区间」为状态，进行状态转移的动态规划问题。即：区间 DP 问题中，一个较大的区间的状态由包含于它的若干个子区间的状态转移而来。因此划分区间就是区间 DP 要考虑的问题。

区间 DP 的三要素通常如下：

+ 阶段：区间 DP 按照区间长度从小到大进行递推；
+ 状态：区间通常使用有序数对 `(left, right)` 表示区间 `[left..right]` 的左右端点；
+ 决策：每一种划分区间的方法。

弄清楚这三要素以后，通常编码来说就不难了。下面我们通过两个经典的动态规划问题，向大家介绍区间 DP 问题求解的思路，它们是：

+ 「力扣」第 5 题：最长回文子串；
+ 「力扣」第 312 题：戳气球。

希望大家能够通过这两道问题，以及本节后面给出的练习，体会动态规划穷举所有可能情况的思想，并且基于「无后效性」的原则设计状态以及递推求解的阶段。

---


## 例 1：「力扣」第 5 题：最长回文子串

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 `1000`。

示例 1：

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

示例 2：

```
输入: "cbbd"
输出: "bb"
```

**题意分析**：这道题给我们一个字符串 `s`，让我们找出这个字符串 `s` 的最长回文子串，并且告诉我们 `s` 的最大长度为 $1000$。回文串是从左向右读和从右向左读都一样的字符串。特别地，单独的一个字符肯定是回文串，两个相同的字符组成的字符串也是回文串。在「力扣」上有很多关于「回文串」的问题。

子串是原始字符串的一个子集，子串的特点是：组成子串的字符在原始字符串中是 **连续** 的。这一点区别于子序列这个概念：子序列（subsequence）只需要保证字符的相对顺序不变，但不要求连续。

由于 `s` 的最大长度为 $1000$，可以简单计算一下：$1000$ 的平方是 $10^6$，根据经验，可以设计一个 $O(N^2)$ 的算法。

我们先给出暴力解法：

### 方法一：暴力解法

根据子串 **连续** 的特点，可以枚举子串 **所有** 可能的左边界和右边界，然后再逐个判断每个子串的回文性质，同时记录子串的长度。在遍历的过程中，我们就可以找到最长的回文子串。

**参考代码 1**：

```Java []
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // s.charAt(i) 每次都会检查数组下标越界，因此先转换成字符数组
        char[] charArray = s.toCharArray();
        // 枚举所有长度大于 1 的子串 charArray[i..j]
        for (int i = 0; i < len - 1; i++) {
            for (int j = i + 1; j < len; j++) {
                if (j - i + 1 > maxLen && validPalindromic(charArray, i, j)) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }

    /**
     * 验证子串 s[left..right] 是否为回文串
     */
    private boolean validPalindromic(char[] charArray, int left, int right) {
        while (left < right) {
            if (charArray[left] != charArray[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

**说明**：

+ 由于截取字符串有一定的性能消耗，一个等价的方式是：只需要记录最长回文子串的起点位置和它的长度，在最后输出的时候，再做截取；
+ 由于只关心最长回文子串，因此左边界只需要枚举到倒数第 $2$ 个位置，右边界从左边界 $+ 1$ 的位置开始枚举；
+ 借助逻辑与运算的短路性质，我们只需要看长度大于当前得到的最长回文子串长度的那些子串，进而验证它们是否是回文；


**复杂度分析**：

+ 时间复杂度：$O(N^3)$，这里 $N$ 是输入字符串的长度，两层嵌套 `for` 循环枚举左右边界，一层 `while` 循环判断是否回文；
+ 空间复杂度：$O(1)$，由于只使用到常数个临时变量，与字符串的长度无关，因此空间复杂度是 $O(1)$。


### 方法二：中心扩散

除了枚举子串的两个端点，我们也针对可能的回文中心位置，向两边进行扩散，扩散到边界或者不能再扩散位置，就可以计算出当前得到的回文子串的长度。

枚举 **所有** 可能的回文的中心位置，向两侧扩散得到的最长回文子串的长度，就是题目所求。

由于回文子串的长度可能为奇数，也能为偶数，需要分类讨论。

![image.png](https://pic.leetcode-cn.com/1605667914-TgnPOP-image.png)

**参考代码 2**：
```Java []
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        // 在遍历的过程中，记录最长回文子串的长度 maxLen 和对应的起始下标 begin
        int maxLen = 1;
        int begin = 0;
        char[] charArray = s.toCharArray();
        // 到 len - 2 为止，因为 len - 1 的右边不能再扩散
        for (int i = 0; i < len - 1; i++) {
            int oddLen = expandAroundCenter(charArray, i, i);
            int evenLen = expandAroundCenter(charArray, i, i + 1);

            int curMaxLen = Math.max(oddLen, evenLen);
            if (curMaxLen > maxLen) {
                maxLen = curMaxLen;
                // 这一步要在纸上画图发现规律，分奇数长度回文子串和偶数长度回文子串分类讨论，统一表达式
                begin = i - (maxLen - 1) / 2;
            }
        }
        // 在最后一步截取字符串
        return s.substring(begin, begin + maxLen);
    }

    /**
     * 当 left = right 的时候，回文中心是一个字符，回文串的长度是奇数
     * 当 right = left + 1 的时候，此时回文中心两个字符，回文串的长度是偶数
     *
     * @param charArray 原始字符串的字符数组
     * @param left      起始左边界（可以取到）
     * @param right     起始右边界（可以取到）
     * @return 回文串的长度
     */
    private int expandAroundCenter(char[] charArray, int left, int right) {
        int len = charArray.length;
        int i = left;
        int j = right;
        while (i >= 0 && j < len) {
            if (charArray[i] == charArray[j]) {
                i--;
                j++;
            } else {
                break;
            }
        }
        // 跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，返回的回文串的长度是 j - i + 1 - 2 = j - i - 1
        return j - i - 1;
    }
}
```

**说明**：中心扩散的返回值可以设计成返回当前得到的回文子串的长度、和起始下标。事实上，可以通过回文中心的下标和回文长度推导出当前得到的回文子串的起始下标，我们举两个具体的例子就不难发现规律。

![image.png](https://pic.leetcode-cn.com/1605667976-UyTWLR-image.png)

**复杂度分析**：

+ 时间复杂度：$O(N^2)$，这里 $N$ 是输入字符串的长度，枚举中心位置的个数是 $2N - 1$，每一次向两边扩散检测是否是回文；
+ 空间复杂度：$O(N)$，由于只使用到常数个临时变量，与字符串的长度无关，因此空间复杂度是 $O(1)$。

### 方法三：动态规划

回文串天然具有状态转移性质，即：一个回文去掉两头以后，剩下的部分依然是回文（单字符、两个一样的字符的情况除外）。反之，如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串。所以，只有当一个字符串的头尾两个字符相等的情况下才有必要继续判断下去。

+ 如果里面的子串是回文，整体就是回文串；
+ 如果里面的子串不是回文串，整体就不是回文串。

即：在头和尾两个字符相等的前提下，整个子串的回文性质就由去掉头尾两个字符以后的子串的回文性质决定，这个性质就是状态转移。


#### 第 1 步：定义状态

`dp[i][j]` 表示：子串 `s[i..j]` 是否为回文子串，这里 `i` 和 `j` 分别表示字符串 `s` 的左右边界，规定 `s[i]` 和 `s[j]` 可以取到。

#### 第 2 步：推导状态转移方程

根据上面的分析：整个子串的回文性质就由去掉头尾两个字符以后的子串的回文性质决定，即：

```
dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
```
从 `dp[i + 1][j - 1]` 表达式 **下标不越界** 看出边界情况：以下标 `i + 1` 为左边界和以下标 `j - 1` 为右边界的子串长度不够 $2$ 个，此时区间长度为 $0$ 个 或者 $1$ 个的时候，肯定是回文串。计算此时区间的长度的表达式：$j - 1 - (i + 1) + 1 < 2$，整理得 $j - i < 3$。结论也很显然：当子串 `s[i, j]` 的长度等于 $2$ 或者等于 $3$ 的时候，只需要判断头尾两个字符是否相等就可以直接下结论。

所以，在 `s[i] == s[j]` 成立和 `j - i < 3` 的前提下，直接可以下结论 `dp[i][j] = true`，否则才需要参考之前计算的状态。



#### 第 3 步：考虑初始化

单个字符一定是回文串，因此可以把对角线初始化为 $1$：`dp[i][i] = 1`。事实上，初始化的部分可以省略，因为 `dp[i][i]` 的值根本不会被其它状态值所参考。填表模拟动态规划的过程的时候，就会体会到这一点。

#### 第 4 步：考虑输出

在填表的过程中，只要一得到一个为 `true` 的状态，就记录此时回文子串的长度和起始位置，最后输出最长回文子串。

下面我们看一下动态规划代码是如何作用在求解字符串 `babab` 的最长回文子串中。

+ 二维表格就记录了我们在求解 `s` 的所有子串问题的所有状态；
+ 每一行表示了 `s` 的子串左边界，每一列表示了 `s` 的子串的右边界；
+ 左边界和右边界的组合就唯一地确定了一个子串，我们将子串的回文性质填写在这张表格中。由于作为子串的下标左边界 `i` 一定小于等于右边界 `j`。我们只需要填写在这张表格中主对角线上边的部分；
+ **注意**：由于 `dp[i][j]` 的值需要参考 `dp[i + 1][j - 1]`，`i + 1` 在 `i` 的下边一行，`j - 1` 是 `j` 的左边一列。因此我们在填表的时候，**一定要保证左下方的单元格先被计算出来，这样才能保证递推过程「无后效性」**。

我们按照先写左边的列，从上到下依次填写的顺序进行填表。填表的顺序不唯一，保证「无后效性」即可。

<![0005.001.jpeg](https://pic.leetcode-cn.com/1605670761-ygmVKS-0005.001.jpeg),![0005.002.jpeg](https://pic.leetcode-cn.com/1605670761-PXkgEw-0005.002.jpeg),![0005.003.jpeg](https://pic.leetcode-cn.com/1605670761-UkQYJs-0005.003.jpeg),![0005.004.jpeg](https://pic.leetcode-cn.com/1605670761-gRAUPX-0005.004.jpeg),![0005.005.jpeg](https://pic.leetcode-cn.com/1605670761-qhZhAY-0005.005.jpeg),![0005.006.jpeg](https://pic.leetcode-cn.com/1605670761-VssyYI-0005.006.jpeg),![0005.007.jpeg](https://pic.leetcode-cn.com/1605670761-KnEXzg-0005.007.jpeg),![0005.008.jpeg](https://pic.leetcode-cn.com/1605670761-RAsYhq-0005.008.jpeg),![0005.009.jpeg](https://pic.leetcode-cn.com/1605670761-rYoyaW-0005.009.jpeg),![0005.010.jpeg](https://pic.leetcode-cn.com/1605670761-SXumCK-0005.010.jpeg),![0005.011.jpeg](https://pic.leetcode-cn.com/1605670761-WEMFPJ-0005.011.jpeg)>

**参考代码 3**：

```Java []
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;

        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        char[] charArray = s.toCharArray();
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }
        for (int j = 1; j < len; j++) {
            for (int i = 0; i < j; i++) {
                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```
**复杂度分析**：

+ 时间复杂度：$O(N^2)$，这里 $N$ 是输入字符串的长度，遍历了字符串的左右边界，与暴力解法不同的是：在判断子串的过程中参考了以前判断的子串的结果，降低了一个级别的时间复杂度；
+ 空间复杂度：$O(N^2)$，空间复杂度就是二维表格的大小，也是 $O(N^2)$。

> 「中心扩散法」和「动态规划」时间复杂度都为 $O(N^2)$，但是实际运行结果，「中心扩散法」会快很多。这是因为「中心扩散法」枚举的中心的个数为 $2N - 1$，即 $O(N)$，而动态规划枚举的子区间的数量级为 $O(N^2)$。再次说明了时间复杂度是一个估算，表示的是渐进的含义。

### 换一个角度填表

一个更有规律可循的填表方式是按照我们在这一节之前所提到的「区间 DP 三要素」，进行从外到内的循环：

+ 阶段：长度为 $1$ 的子串、长度为 $2$ 的子串、依次枚举到长度为 $N$ 的子串；
+ 状态：在长度确定的情况下，枚举左边界，右边界随之确定；
+ **决策**：这一步没有选择的过程，发生状态转移。

按照这样的顺序，也能保证长度更长的子区间可以参考长度较短的子区间的回文性质，以 $O(1)$ 的时间复杂度发生状态转移。下面的动画展示了这种跳表的过程。

<![0005-2.001.jpeg](https://pic.leetcode-cn.com/1606268526-ngsupS-0005-2.001.jpeg),![0005-2.002.jpeg](https://pic.leetcode-cn.com/1606268526-gbpRug-0005-2.002.jpeg),![0005-2.003.jpeg](https://pic.leetcode-cn.com/1606268526-zrDQzy-0005-2.003.jpeg),![0005-2.004.jpeg](https://pic.leetcode-cn.com/1606268526-IlBAbG-0005-2.004.jpeg),![0005-2.005.jpeg](https://pic.leetcode-cn.com/1606268526-KfOftZ-0005-2.005.jpeg),![0005-2.006.jpeg](https://pic.leetcode-cn.com/1606268526-uyMpSo-0005-2.006.jpeg),![0005-2.007.jpeg](https://pic.leetcode-cn.com/1606268526-gZToAj-0005-2.007.jpeg),![0005-2.008.jpeg](https://pic.leetcode-cn.com/1606268526-hbhtJp-0005-2.008.jpeg),![0005-2.009.jpeg](https://pic.leetcode-cn.com/1606268526-eBkYKA-0005-2.009.jpeg),![0005-2.010.jpeg](https://pic.leetcode-cn.com/1606268526-XBFhxx-0005-2.010.jpeg),![0005-2.011.jpeg](https://pic.leetcode-cn.com/1606268526-JuyKjP-0005-2.011.jpeg)>

**参考代码 4**：

```Java []
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```


**说明**：这里有一个编码的小技巧。左边界 `i` 的上界不容易计算出来。事实上，固定了区间长度 `L` 和左边界 `i`，可以推出右边界 `j` 的值，如果 `j` 越界，当前枚举就可以停止。具体请见如下代码。

**复杂度分析**：（同参考代码 3）

### 方法四：Manacher 算法

这道题其实还有一个终极的解法，是专门用于求解动态规划问题的解法。由著名的计算机科学家 Manacher 提出，Manacher 巧妙地利用了回文串的性质，通过添加间隔字符，让奇、偶数长度回文统一了起来，具体来说是让偶数长度的回文串的中心扩散的结果和奇数长度的回文串一样可以通过动态规划记录下来。这个看起来很神奇的算法其实是「动态规划」和「中心扩散」解法的结合。能推出一个很酷但并不太难理解的状态转移方程，只遍历了数组一次就得到了最长的回文子串，这个解法已经超出了我们讲解内容的范围，感兴趣的朋友可以在「力扣」第 5 题的官方题解收看对于这个思路的讲解和代码。

面试中遇到这个问题，「动态规划」和「中心扩散」选其一作答即可。

---

## 例 2：「力扣」第 312 题：戳气球

有 `n` 个气球，编号为`0` 到 `n - 1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。

现在要求你戳破所有的气球。如果你戳破气球 `i` ，就可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 `i` 相邻的两个气球的序号。注意当你戳破了气球 `i` 后，气球 `left` 和气球 `right` 就变成了相邻的气球。

求所能获得硬币的最大数量。

**说明**：

- 你可以假设 `nums[-1] = nums[n] = 1`，但注意它们不是真实存在的所以并不能被戳破。
- `0 ≤ n ≤ 500`, `0 ≤ nums[i] ≤ 100`

**示例**：

```
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

**题意分析**：题目中的关键信息是：戳破一个气球，分别与这个被戳破的气球相邻的气球，它们彼此相邻。

![image.png](https://pic.leetcode-cn.com/1605283524-KJEsSY-image.png)

如果依次按照题目中的方式枚举所有可能的情况，可能的情况会呈指数级增长。依据题意，可以假设输入数组的左右各有一个值为 $1$ 的气球，这样戳破边界的气球的计算方式，就可以与戳破中间的气球的计算方式统一起来。

![image.png](https://pic.leetcode-cn.com/1605283845-lQDtFi-image.png)

**思路分析**：

+ 题目只问最优值，没有问具体解，可以考虑使用动态规划求解；
+ 根据上面的分析，不能够直接枚举所有可能戳破气球的情况，但可以观察出如下信息：戳破气球前与戳破气球后，**剩下的气球之间的相对顺序不变**，可以 **根据小区间里戳破气球的最大得分组合成大区间里戳破气球的最大得分** ，即：

> 当前大区间里所有气球按照规则戳破的得分 = 当前戳破气球的左边小区间的最大得分 + 戳破当前气球 + 当前戳破气球的右边小区间的最大得分

**注意**：左边小区间和右边小区间可能为空区间。

**下面这句话解释了这种状态转移的合理性（非常重要，需认真体会）**：

> 下标 `k` 是最后一个戳破的气球，它把原来的区间 `[i..j]` 划分成左区间（如果有的话）和右区间（如果有的话）。正是由于 `k` 最后戳破，**左区间和右区间里的气球永远不会相邻**。因此 **左子区间和右子区间的求解是独立的**，可以分别求解子问题在左区间和在右区间，它们的解就组成了更大区间的解。



因此可以设计状态如下：`dp[i][j]` 表示输入数组两端各扩充了一个虚拟气球以后，下标区间 `[i..j]` 按照题目中的规则戳破以后能够获得的最大分数。我们以区间内有 $4$ 个气球为例，分析状态转移方程如何推导。


以下 $4$ 种情况表示，在区间 `[i..j]` 有 $4$ 个气球的情况下，区间划分可能的 $4$ 种情况。

![image.png](https://pic.leetcode-cn.com/1605283123-MlNauE-image.png)

下面这张图需要这样看：

+ 浅灰色背景是当前要求的区间里按照规则戳破气球的最大得分，$4$ 张图都是一样的；
+ 依次戳破的 $4$ 个气球把浅灰色区间进行了划分，戳破第一个气球没有左区间（红色虚框表示），戳破最后一个气球没有右区间（红色虚框表示）；
+ 应该认为：红色虚框的部分的气球先被戳破（按照什么顺序戳破暂时不用管），**有一根针的气球是此时最后被戳破的**，由于它是最后戳破的气球，此时它的 **左边和右边的气球在 $4$ 种情况下是固定的**，均为 `nums[i - 1]` 和 `nums[j + 1]`。

把当前被戳破的气球的下标记为 `k`，

![image.png](https://pic.leetcode-cn.com/1605259541-VXcfQM-image.png)


可以推导出状态转移方程：对于所有 $k \in [i, j]$，有

```java
dp[i][j] = dp[i][k - 1] + nums[i - 1] * nums[k] * nums[j + 1] + dp[k + 1][j]
```



值得说明的是：

+ 当 `k = i` 的时候，它的 **左边** 没有区间，上面的方程 `dp[i][k - 1]` 所表示的区间 `[i..i - 1]` 为空区间；
+ 当 `k = j` 的时候，它的 **右边** 没有区间，上面的方程 `dp[k + 1][j]` 所表示的区间 `[k + 1..k]` 为空区间。

两个空区间应该赋值为 $0$ ，由于 Java 整型 int 数组在初始化的时候默认值为 $0$。因此上面两种特殊情况可以不单独讨论。


我们总结一下这样可以求解问题的 **关键**：把气球编号 `k` 当做最后一个被戳破的气球，枚举这个步骤的得分是 **确定** 的（因为左右气球是确定的额），整个推导的过程 **符合无后效性**。


因此在编码的时候需要按照如下顺序：

+ **阶段**：依次计算长度为 $1$ 的区间、长度为 $2$ 的区间、长度为 $N$ 的区间；
+ **状态**：枚举长度为 `L` 的区间的时候，枚举起始端点 `i` ，此时对应的右端点为 `j` ，由于 `j - i + 1 = L` ，故 `j = L + i - 1`；
+ **选择**：区间 `[i..j]` 里每一个气球都需要枚举当它最后被戳破的时候，整个 `[i..j]` 区间能够获得的最大得分。

下面的表格展示了「动态规划」求解戳气球问题的状态表格以及细节，如果对于各个阶段状态转移还不是很清楚的朋友，可以按照「枚举长度为 $1$ 的区间」、「枚举长度为 $2$ 的区间」 …… 这样的顺序在草稿纸上填写下面的表格，遇到卡壳的地方再做比对。

![image.png](https://pic.leetcode-cn.com/1605678424-XfvDKO-image.png)


**参考代码**：

```Java []
import java.util.Arrays;

public class Solution {

    public int maxCoins(int[] nums) {
        int len = nums.length;
        // 预处理
        int[] newNums = new int[len + 2];
        newNums[0] = 1;
        newNums[len + 1] = 1;
        System.arraycopy(nums, 0, newNums, 1, len);
        nums = newNums;

        // 第一维是左边界下标，第二维是右边界下标
        int[][] dp = new int[len + 2][len + 2];
        // 递推开始
        // 先枚举长度
        for (int L = 1; L <= len; L++) {
            // i 是左边界
            for (int i = 1; i <= len - L + 1; i++) {
                // j 是 i 和 L 确定的情况下，右边界
                int j = i + L - 1;
                // 枚举每一个位置
                for (int k = i; k <= j; k++) {
                    dp[i][j] = Math.max(dp[i][j], dp[i][k - 1] + nums[i - 1] * nums[k] * nums[j + 1] + dp[k + 1][j]);
                }
            }
        }
        return dp[1][len];
    }
}
```


**复杂度分析**：

+ 时间复杂度：$O(N^3)$，这里 $N$ 是输入数组的长度，三重循环有依赖关系；
+ 空间复杂度：$O(N^2)$，状态数组的大小为 $N^2$。

---

## 总结

「阶段」、「状态」和「选择」是 **递推**、**自底向上** 求解动态规划问题的三大要求，并且它们需要按照从外到内的顺序依次循环可以保证求解过程「无后效性」。对这三个概念我们再说一些解释。

**阶段**：动态规划可用于求解多阶段决策问题，一步一步求解，每一个新问题都参考了 **已经求解过的** 子问题，每一步就是一个阶段；
**状态**：状态是描述求解问题到了哪一个阶段的概念，这一点我们在回溯算法中提及过，这个阶段通常用若干个变量表示。这道题（「力扣」第 312 题）的状态由一个区间，即区间的左右下标 `i`、`j` 表示；
**选择**：通过之前我们求解过的问题，可以发现，动态规划的方法其实绝大多数情况下，不是针对这个问题设计出来的具体的解决方案，而是去考虑了 **所有可能的求解方案**，并记录每一个步骤，每一种可能的结果，从中当前阶段选出最好的结果。每一个阶段的每一种可能就是一种选择。

---

## 练习


1. 完成「力扣」第 1039 题：多边形三角剖分的最低得分（中等）；
2. 完成「力扣」第 132 题：分割回文串 II（困难）；
3. 完成「力扣」第 516 题：最长回文子序列（中等）；
4. 完成「力扣」第 664 题：奇怪的打印机（困难）；
5. 完成「力扣」第 877 题：石子游戏（中等）；
6. 完成「力扣」第 486 题：预测赢家（中等）；
7. （选做）完成「力扣」第 1563 题：石子游戏 V（困难）；
8. （选做）完成「力扣」第 1312 题：让字符串成为回文串的最少插入次数（困难）；
9. 完成「力扣」第 1547 题：切棍子的最小成本（困难）。

---

10. 完成「力扣」第 410 题：分割数组的最大值（困难）；
11. （选做）完成「力扣」第 813 题：最大平均值和的分组（中等）
