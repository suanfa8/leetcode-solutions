# 第 12.6 节 数独问题

这一节我们来看一个游戏问题，其实这个问题没有技巧性。但是需要大家注意的一点是，在深度优先遍历的过程中，记录下有用的信息，也是剪枝的途径。

## 例 1：「力扣」第 37 题：解数独

编写一个程序，通过填充空格来解决数独问题。

一个数独的解法需遵循如下规则：

1. 数字 `1-9` 在每一行只能出现一次。

2. 数字 `1-9` 在每一列只能出现一次。

3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

空白格用 `'.'` 表示。

![img](http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

一个数独。

![img](http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png)

答案被标成红色。

**提示**：

+ 给定的数独序列只包含数字 `1-9` 和字符 `'.'` 。
+ 你可以假设给定的数独只有唯一解。
+ 给定数独永远是 `9 x 9` 形式的。

**题意分析**：最后的提示有一条：「你可以假设给定的数独只有唯一解」。

**思路分析**：

+ 很多游戏问题的解决方案并没有那么智能，回溯算法也可以使用暴力搜索，也就是回溯算法的方式完成；
+ 解决数独问题的方案很像 N 皇后问题，都是在棋盘（二维表格）上搜索按照一定规则摆放的棋子（数字）的可行解；
+ 注意需要在深度优先遍历的过程中记录下已经摆放的数字，根据题目中的规则，我们需要设置三个布尔数组：
  + `row[i][j]`：表示下标为 `i` 的那一 **行**，已经填上了数字 `j`（实际上 `j` 表示下标，需要处理下标偏移，具体请见代码，下同）；  
  + `col[i][j]`：表示下标为 `i` 的那一 **列**，已经填上了数字 `j`；
  + `box[i][j][k]`：表示 **粗实线宫格** 的坐标为 `(i, j)` 的那个单元格，已经填上了数字 `k`。
![image.png](https://pic.leetcode-cn.com/1604283119-HbGQDi-image.png)

+ 由于初始的时候，棋盘上已经有一些数组，应该先遍历一次棋盘，记录下棋盘上已经有的数字，然后再使用回溯算法 **从左向右、从上到下** 搜索可行解：
  + 在遍历的过程中，如果遇到 `'.'` 就尝试填写数字 `1 ~ 9`，每一次尝试都需要看 `row` 、`col`、`box` 对应位置是否已经填写，如果已经填写尝试下一个数字，如果还未填写，就尝试填写这个数字，然后进入下一个坐标（**注意**：代码中有处理下标的细节，请留意）。


**参考代码**：

```Java []
public class Solution {

    private boolean[][] row;
    private boolean[][] col;
    private boolean[][][] box;

    public void solveSudoku(char[][] board) {
        row = new boolean[9][9];
        col = new boolean[9][9];
        box = new boolean[3][3][9];

        // 步骤 1：同 N 皇后问题，先遍历棋盘一次，然后每一行，每一列在 row col cell 里占住位置
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    // 计算在布尔数值中的下标，减去 1 使得下标从 0 开始
                    int index = board[i][j] - '1';
                    // 在下标为 i 这一行，记录为 true
                    row[i][index] = true;
                    // 在下标为 j 这一列，记录为 true
                    col[j][index] = true;
                    // 在横坐标为 i / 3、纵坐标 j / 3 的地方， 看到的那个数字记录为 true
                    box[i / 3][j / 3][index] = true;
                }
            }
        }
        // 步骤 2：进行一次深度优先遍历，尝试所有的可能性
        dfs(board, 0, 0);
    }

    /**
     * @param board 棋盘
     * @param i     棋盘横坐标
     * @param j     棋盘纵坐标
     * @return 由于存在唯一解，搜索到一个解就可以退出了，递归函数的返回值为是否搜索到一个解
     */
    private boolean dfs(char[][] board, int i, int j) {
        // 递归终止条件 1：全部填完
        if (i == 9) {
            return true;
        }

        // 对 '.' 尝试从 1 填到 9
        if (board[i][j] == '.') {
            for (char c = '1'; c <= '9'; c++) {
                // 如果行、列、box 已经填了 c - '1' 则尝试下一个数字
                int index = c - '1';
                if (row[i][index] || col[j][index] || box[i / 3][j / 3][index]) {
                    continue;
                }

                // 填写当前字符，并且对应 row、col、box 占位
                board[i][j] = c;
                row[i][index] = true;
                col[j][index] = true;
                box[i / 3][j / 3][index] = true;

                // 题目保证只有唯一解，继续填写下一格
                // ①：i + (j + 1) / 9 表示如果 j 已经在一列的末尾（此时 j = 8），跳转到下一行
                // (j + 1) % 9 ，当 j = 8 时，j + 1 重置到 0
                if (dfs(board, i + (j + 1) / 9, (j + 1) % 9)) {
                    return true;
                }

                // 重置变量
                board[i][j] = '.';
                row[i][index] = false;
                col[j][index] = false;
                box[i / 3][j / 3][index] = false;
            }
        } else {
            // 填写下一格和 ① 一样
            return dfs(board, i + (j + 1) / 9, (j + 1) % 9);
        }
        // 递归终止条件 2：全部尝试过以后，返回 false
        return false;
    }
}
```

**复杂度分析**：（本题的时间复杂度与空间复杂度均为指数级别，很难分析，一般面试不要求掌握。）

---


## 练习

1. 完成「力扣」第 37 题：解数独（困难）；

> 友情提示：由于 `row`、`col`、`box` 的最后一维只有 $9$ 位有效，并且它们都是布尔数组，可以把布尔数组改成整形数组，使用位运算的方式实现。

2. 完成「力扣」第 473 题：火柴拼正方形（中等）；
3. 完成「力扣」第 401 题：二进制手表（简单）；
4. 完成「力扣」第 131 题：分割回文串（中等）。
5. （选做）如果感兴趣，可以在互联网上搜索关键字「Dancing Links（跳舞链表）」，这个数据结构是解决数独问题的高效数据结构。

> 友情提示：Dancing Links 属于竞赛级别的高级数据结构，准备面试的朋友可以不用了解。

---

## 总结

回溯算法这一章节我们就为大家介绍到这里了，希望大家能够通过不断练习，理解回溯算法来自于深度优先遍历这种算法思想，事实上没有什么技巧，也称为暴力搜索。

下一章节我们进入动态规划的学习，动态规划也是一种常见的算法设计的思想，并且在面试问题中出现的概率很高，请大家留意。

