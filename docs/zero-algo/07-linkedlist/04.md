# 第 7.4 节 虚拟头结点

这一节我们来看「力扣」第 19 题（删除链表的倒数第 `N` 个节点）。

## 例题：「力扣」第 19 题：删除链表的倒数第 `N` 个节点

这道题给我们一个链表，给定一个链表，要我们删除链表的倒数第 `n` 个节点，并且返回链表的头结点。并且保证 `n` 是有效的。

**思路分析**：

+ 要删除一个结点，我们知道，需要来到待删除结点的上一个结点。
+ 要删除倒数第 $N$ 个结点，因此我们就得站在倒数第 $N + 1$ 个结点，然后修改它的 `next` 指针指向。

![image.png](https://pic.leetcode-cn.com/1598235955-GxlFVa-image.png)

为此，我需要遍历一遍链表，得到链表的长度 `len` 。为了找到倒数第 `N + 1` 个结点，就又得从链表的起始结点开始遍历，那么这里要走多少步呢？这一步不能靠猜，画出具体的图，就很清晰了。

+ 一共 $6$ 个结点，$N = 3$，删除倒数第 $3$ 个结点，就是正数第 $4$ 个结点，从起始结点开始，需要走 $3$ 步；
+ 一共 $6$ 个结点，$N = 1$，删除倒数第 $1$ 个结点，就是正数第 $6$ 个结点，从起始结点开始，需要走 $5$ 步。


因此，从起始结点开始，需要走 `len - N - 1` 步来到要删除的结点的上一个结点。

那么问题又来了。一共 $6$ 个结点，如果 $N = 6$ ，此时 $6 - 6 - 1 = -1$，需要走 $-1$ 步，是没有意义的。而我们要删掉的就是起始结点本身。当然我们可以对这种情况单独做判断，但事实上，处理链表起始结点的边界问题，有一个经典的技巧，那就是设置 **虚拟头结点**。

### 虚拟头结点

+ 虚拟头结点的存在非必要，但是可以简化对链表问题的讨论，这个技巧其实我们在插入排序的时候用过，也叫 **哨兵**，只不过在链表中的哨兵是我们人为引入的，它不参与链表的业务，只起到占位和回避边界条件讨论的作用；
+ 在链表的实现中，我们一般也都会设置「虚拟头结点」。这是非常常见的技巧。仍然是在上面在删除倒数第 $N$ 个结点的任务中，如果链表删到都没有结点了，怎么还能引用到链表呢，空链表又怎么在链表的末尾添加结点呢。

有了虚拟头结点以后，这道题的新的解决方案是：

+ 先遍历输出链表的长度；
+ 创建虚拟头结点，接在原来链表的头部（这一步很多教科书上称为「头插法」）；
+ 然后从虚拟头结点开始遍历，走 `len - N` 步，这时候，就不要减 $1$ 了，需要多走一步（因为虚拟头结点占了一个位置），同样，对走几步想不清楚的朋友，还是建议在纸上写写画画，便不难得出正确答案；
+ 注意：这里我们从虚拟头结点开始走，就是为了避免那个最极端的情况。再想一想 $6$ 个结点，删除倒数第 $6$ 个，从虚拟头结点开始，走 $0$ 步，也就是原地不动，修改结点的 `next` 指针指向即可。

**参考代码**：

```Java []
public class Solution {

    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 先获得链表的长度
        int len = getLenOfNode(head);

        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;
        ListNode curNode = dummyNode;
        // 从虚拟头结点开始走 len - n 步
        for (int i = 0; i < len - n; i++) {
            curNode = curNode.next;
        }

        // 删除结点，先声明待删除结点
        ListNode deleteNode = curNode.next;
        // 再修改指针指向
        curNode.next = deleteNode.next;
        // 删除结点的 next 指针释放引用
        deleteNode.next = null;
        return dummyNode.next;
    }


    private int getLenOfNode(ListNode head) {
        int len = 0;
        while (head != null) {
            len++;
            head = head.next;
        }
        return len;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是链表的结点数；
+ 空间复杂度：$O(N)$。

**注意**：

+ 虚拟头结点是几乎所有链表实现里的实现技巧，如果要求我们实现一个链表，一般我们都会实现带有虚拟头结点的链表，在单链表、双链表、循环链表、循环双链表中，均是如此；
+ 做「力扣」里的问题，因为「力扣」是以结点为视角看待链表的，因此虚拟头结点有的时候非必要。经验是：当我们觉得需要分类讨论的时候，如果分类讨论的地方在链表开始的位置，不妨考虑一下，设置虚拟头结点能避免分类讨论。

---

## 练习

1. 完成「力扣」第 2 题：两数相加；
2. 完成「力扣」第 445 题：两数相加 II；
3. 完成「力扣」第 21 题：合并两个有序链表；
4. 完成「力扣」第 23 题：合并K个排序链表；
5. 完成「力扣」第 82 题：删除排序链表中的重复元素 II；
6. 完成「力扣」第 83 题：删除排序链表中的重复元素；
7. 完成「力扣」第 86 题：分隔链表。