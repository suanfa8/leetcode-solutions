## 第 7.6 节 经典例题 1：环形链表

这一节我们来看「力扣」上关于单链表的两个经典问题：「环形链表」。首先是「力扣」第 141 题：环形链表。

---

## 例 1：「力扣」第 141 题：环形链表

**题意分析**：这道题要求我们检测一个链表是否有环。这里有环的链表需要和之前我们介绍的「循环链表」区分开来。

### 方法一：暴力解法

**思路分析**：我们可以使用一个指针变量往下遍历链表：

+ 如果一直遍历下去，没有走到空结点，就说明链表中存在环；
+ 如果一直遍历下去，走到了空结点，就说明链表中不存在环。

这个方法的缺点是，如果链表中存在环，这个指针就很可能走了很多遍。到底多长时间程序还没有返回我们就认为链表中有环，这与测试用例中链表的结点数相关。严格来说，这不是一个正确的方法，但是可以通过系统测评。

**参考代码 1**：

```Java []
public class Solution {

    public boolean hasCycle(ListNode head) {
        // 特判
        if (head == null || head.next == null) {
            return false;
        }

        ListNode curNode = head;
        int count = 0;
        while (curNode != null) {
            curNode = curNode.next;
            // 在遍历了 10000 个结点以后，都没有遍历完，认为链表中有环
            // 这是一种「取巧」的做法
            if (count == 10000){
                return true;
            }
            count++;
        }
        return false;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是链表的结点数。
+ 空间复杂度：$O(N)$。

### 方法二：将遍历过的结点存入哈希表

根据题意，如果遍历的过程中，发现遍历到重复的结点，就说明链表中有环。基于这个想法，可以在遍历的过程中将遍历到的结点存放在哈希表中。一旦检测到哈希表中存放了 **即将要** 放进哈希表的结点，就说明这个链表中有环。

如果一直遍历下去，走到了空结点，就说明链表中不存在环。

**参考代码 2**：

```Java []
import java.util.HashSet;
import java.util.Set;

public class Solution {

    public boolean hasCycle(ListNode head) {
        // 特判
        if (head == null || head.next == null) {
            return false;
        }

        ListNode curNode = head;
        Set<ListNode> hashSet = new HashSet<>();
        while (curNode != null) {
            if (hashSet.contains(curNode)) {
                return true;
            }
            hashSet.add(curNode);
            curNode = curNode.next;
        }
        return false;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是链表的长度；不论是否有环，程序都需要遍历一遍链表的所有结点；
+ 空间复杂度：$O(N)$，每遍历一个结点，都要将这个结点存进哈希表里。

### 方法三：快慢指针

下面介绍一个更经典的思路，依然是快慢指针，事实上，我们在上一节也接触过。

使用两个指针变量：`fastNode` 和 `slowNode`，刚开始都位于起始位置。 `slowNode` 每次走 $1$ 步、`fastNode` 每次走 $2$ 步。由于快指针更快，一旦检测到 `fastNode` 来到了空结点，就说明链表没有环。在链表中存在环的时候，只要 `slowNode`  和 `fastNode`  都在环里，因为 `slowNode` 每次走 $1$ 步、`fastNode` 每次走 $2$ 步，快慢指针一定会在某一个时刻相遇。

可以这样理解这个问题：首先，只要进入环，我们可以认为是「快指针」在追赶「慢指针」，可以想象快、慢指针在环形跑道上跑。它们相遇，肯定是由于快指针 **从慢指针的后面** 赶超了慢指针。

其次，恰恰好是因为 `slowNode` 每次走 $1$ 步、`fastNode` 每次走 $2$ 步，它们的 **速度差恒定是 $1$ ** ，因此在有环的前提下一定会相遇。这一点你可以想象 A 同学现在在「力扣」上刷了 $100$ 题了，A 同学每天坚持刷 $1$ 题，而 B 同学现在只刷了 $50$ 题，但是 B  同学每天坚持刷 $2$ 题，每天比 A 同学多做 $1$ 题，一定有一天，B 同学刷题的数量和学霸会相等。

**参考代码 3**：

```Java []
public class Solution {

    public boolean hasCycle(ListNode head) {
        // 特判
        if (head == null || head.next == null) {
            return false;
        }

        ListNode slow = head;
        ListNode fast = head;

        // 慢指针一次走一步、快指针一次走两步
        // 注意：快指针可以走的条件 fast != null && fast.next != null

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
}
```

接下来，我们来看这道问题的进阶问题。

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是链表的长度；
+ 空间复杂度：$O(1)$，只使用了常数个变量。

---

## 例 2：「力扣」第 141 题：环形链表 II

这道题给我们一个链表，返回链表开始入环的第一个节点。题目还给了说明：不允许修改给定的链表。并且进阶要求是：不用额外空间解决此题。

**思路分析**：通过第 141 题使用哈希表的思路，我们知道：使用哈希表检测到重复的那个结点，就一定是环的入口结点。

对于进阶要求「不使用额外的空间」，思路依然是「快慢指针」，这里需要一些逻辑推导，不过大家放心，并不难，只要细心一点，相信不难发现其中的规律。

由第 141 题，我们知道链表中存在的时候，快慢指针一定在环中相遇。为此可以设置 $3$ 个变量，假设：

![image-20191206010442600](https://tva1.sinaimg.cn/large/006tNbRwly1g9qkgn5lbgj31k90u076t.jpg)

在这个有环的链表上，有 $3$ 个很重要的结点：

+ 链表的起始结点；
+ 环的入口结点；
+ 快慢指针相遇的结点。

这 $3$ 个结点，把这个有环的链表分成了 $3$ 个部分，我们用 **左闭右开** 区间分别表示它们：

+ 绿色部分：`[链表的起始结点, 环的入口结点)`，设这部分结点的个数为 $a$ ；
+ 黄色部分：`[环的入口结点, 快慢指针相遇的结点)`，设这部分结点的个数为 $b$；
+ 红色部分）`[快慢指针相遇的结点, 环的入口结点)`，设这部分结点的个数为 $c$；

我们还注意到一点：从一个颜色结点的起始位置，走到另一个颜色结点的起始位置，走的步数恰好等于这个颜色结点的个数。对这个结论有怀疑的，可以在草稿纸上用具体的例子验证，例如上面我们画的：从绿色结点的开始位置到黄色结点的开始位置，一共走了 $6$ 步，恰恰好就是绿色结点的个数。

根据「快慢指针」相遇，可以知道「慢指针走过的步数 $\times 2 =$  快指针走过的步数」。根据上面的记号：

慢指针走过的步数 = $a + b$，快指针走过的步数 = $a + N \times ( b + c ) + b$，根据「慢指针走过的步数 $\times 2 =$ 快指针走过的步数」，于是：

$$
2 \cdot (a + b) = a + N \cdot (b + c) + b
$$

这里 $N$ 表示快指针在环中走过了多少圈，$N \ge 1$，$N$ 是自然数。化简这个等式，等式的两边都有 $a$  和 $b$ 这两项，我们可以在等式两边同时减去 $a$ 和 $b$，得到：

$$
a + b = N \times (b + c)
$$


我们看到，左边和右边都有  $b$ ，我们把右边 $N$ 个 $b + c$ 中拿一个拆开，写成。

$$
a + b = b + c + (N - 1) \times (b + c)
$$


两边再约去 $b$，得：

$$
a =  c + (N - 1) \times (b + c)
$$
这里 $b + c$ 其实就是环中的结点个数，$a$ 就是从链表起点到环的入口结点要走过的步数，$c$ 是从相遇结点到环入口结点走过的步数。

因此我们就可以设计一个算法，在相遇以后，把其中一个指针放在链表的起始位置，然后两个指针变量同步移动，它们再一次相遇一定就在链表的起始结点。

再一次相遇的时候，在环中的这个结点可能已经绕着环走了几圈了，**走几圈都是有可能的**。大家可以画几个具体的例子验证一下。这个方法虽然节约了空间，但是相应的时间也多消耗了一些。

**参考代码 1**：

```Java []
public class Solution {

    public ListNode detectCycle(ListNode head) {
        // 特判
        if (head == null || head.next == null) {
            // 注意：不要习惯性把 head 返回回去
            return null;
        }

        // 起点要一样，这里利用第 141 题的结论
        ListNode slow = head;
        ListNode fast = head;

        // 注意这种写法，因为快指针一次走两步，
        // 所以要看它下一个结点以及下下一个结点是否为空
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (slow == fast) {
                break;
            }
        }

        // 特判，如果只是因为链表不存在环，那就返回空，因为既然不存在环，肯定没有重复结点
        if (fast == null || fast.next == null) {
            return null;
        }

        slow = head;

        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是链表的长度；
+ 空间复杂度：$O(1)$，只使用了常数个变量。

---

## 练习

1. 使用快慢指针的技巧完成「力扣」第 287 题：寻找重复数。

> 友情提示：这个问题使用「快慢指针」这个技巧解决的思路是比较难想到的，在面试的时候如果遇到同样的问题，应先回答常规思路，然后再回答有技巧、比较开脑洞的思路。如果面试官问是否做过同样的问题或者类似的问题，我们建议如实回答。

---

## 总结

这一节的两个问题是链表的技巧「快慢指针」的应用，如果之前没有学习过，可能比较难想到。相对于写对这两个问题，更重要的是理解设计算法的合理性。

这就是这一节的内容，下一节我们来看另一个比较经典的问题：相交链表。




