# 第 7.5 节 快慢指针

在上一节介绍的方法中，有一点不太好的地方是：为了得到链表的长度，需要先遍历一次链表，数出链表的长度，然后再从头开始遍历。**如果这个链表比较长** ，待删除的结点恰好在末尾，此时就得遍历两次链表。影响时间性能的原因是：必须等待第一次链表遍历完成以后，才能开始第二次遍历。

这一节我们介绍一个在链表问题中同样 **常见** 的技巧：「快慢指针」。「快慢指针」是指在链表遍历的过程中，使用两个指针变量 **同向移动** 的一种解决问题的技巧。

---

## 快慢指针

依然以「力扣」第 19 题（删除链表的倒数第 $N$ 个节点） 为例。我们先让一个指针先走 $N + 1$ 步（称为快指针只是因为 **先走**，有些时候并不代表走得快），注意 **仍然从虚拟头结点开始** 走（有可能涉及到链表第 $1$ 个结点增删操作都需要设置虚拟头结点）。然后再让一个指针（慢指针）从虚拟头结点开始，与快指针 **同步移动**，直到快指针走到了链表的末尾，慢指针就刚刚好来到了倒数第 $N + 1$ 个结点。

至于为什么需要让快指针从虚拟头结点开始走 $N + 1$ 步，没有想明白的朋友依然是建议自己画一个图，举几个简单的例子帮助分析，找出规律。

设置 **快慢指针** 的好处是，两个指针可以一起走，相比于「先遍历一次链表」的做法，我们实现了一个并行的操作，节约了时间。

下面我们来看一下代码。注意理解 **快指针可以继续移动的条件** 。

**参考代码**：

```Java []
public class Solution {

    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;

        // 来到倒数第 N + 1 个结点的位置
        // 快指针先走 N + 1 步
        ListNode fastNode = dummyNode;
        for (int i = 0; i < n; i++) {
            fastNode = fastNode.next;
        }

        ListNode slowNode = dummyNode;
        while (fastNode.next != null) {
            fastNode = fastNode.next;
            slowNode = slowNode.next;
        }

        // 此时 slowNode 来到了待删除的结点的上一个结点
        ListNode deleteNode = slowNode.next;
        slowNode.next = deleteNode.next;
        deleteNode.next = null;
        return dummyNode.next;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是链表的长度；
+ 空间复杂度：$O(1)$，只使用了常数个临时变量。

---

## 快慢指针找链表中点以及注意事项

快慢指针的另一个经典应用是找链表的中点。此时使用快慢指针，有一点点技巧：

+ 快慢指针一开始是同起跑线的；
+ 然后快指针一次走 $2$ 步，慢指针一次走 $1$ 步，一旦快指针走到了末尾，慢指针就正好来到了链表的中间。

此时我们要注意一个非常小的细节，那就是快指针可以前进的条件。

+ 如果快指针以及快指针的下一个结点非空，来到的是中间结点的前一个结点；
+ 如果快指针的下一个结点以及快指针的下一个结点的下一个结点非空，来到的是中间结点的后一个结点。

依然是建议大家自己在纸上举出几个结点个数是偶数的链表，实际的模拟一下这个过程就非常清楚了。因为事实上，这一点点小小的区别，在一些问题中，很可能就会导致错误的结果。依然是 **画图分析** 和  **打印输出**，是很重要的调试手段。

---

## 练习

1. 完成「力扣」第 876 题：链表的中间结点；
2. 完成「力扣」第 234 题：回文链表。
---

## 总结

到此为止，我已经把链表当中常见的技巧全部介绍完了，其实并不多。希望大家通过不断练习，加深对这几点的体会。在后面几节，我们会详细讲解几个链表的经典问题，这几个问题比较经典，但是解决方案相对单一，如果对这几个问题不感兴趣的朋友其实可以跳过，直接进入下一章节内容的学习。


