# 第 7.2 节 解决链表中的指针指向问题

这一小节我们讲解「力扣」第 206 题（反转链表）。「力扣」上的链表问题绝大多数都以 **结点类** 为讨论对象，而不是给我们一个链表， 即：输入数据是链表的第一个结点。

---

## 例题：「力扣」第 206 题：反转链表

这道题要求我们反转一个单链表。


**思路分析**：（一种可行但不符合题意的做法）可以遍历链表一次，把结点的值记录到一个数组里，然后再遍历一次， **倒着** 把读到的结点值赋值回去，是可以完成题目中的要求。

但是单链表的问题，一般而言是要求我们通过修改 `next` 变量的值，即修改指针变量 `next` 的指向完成任务。这样的工作好像是在做针线活，因此可以形象地把在链表中修改 `next` 指针指向的工作称之为穿针引线。

**注意**：修改了结点的 `next` 数据域，才叫做修改了结点的指向。


### 方法一：循环实现

算法设计步骤：

+ 首先我们画出修改前后，链表的形态，注意它们的一一对应关系；

![image-20200816161329210](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjiucj7xj31cc0gcgm8.jpg)

把链接用不同颜色标注出来。

![image-20200816161446452](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjiv5d36j31ao0g074w.jpg)

+ 假设当前结点为 `curNode` ，第一个结点的 `next` 指针需要指到它的前面，它的前面是一个空结点，因此我们需要声明一个 `preNode` 变量，初始化的时候为 `null`；
+ 在修改了第一个结点的 `next` 指针指向以后，程序要对原来第一个结点的下一个结点做类似的操作，但是这里当前  `curNode`  结点的下一个结点指向了 `preNode` （`null`） ，导致我们不能访问到原始链表第一个结点的下一个结点。因此我们在修改第一个结点的 `next` 指针操作之前，就需要先把第一个结点的下一个结点的引用保存下来，命名为 `nextNode` ；
+ 在修改了指针的指向的操作以后，重置 `preNode` 变量和 `curNode` 变量；
+ 对每一个结点执行同样的操作，最后返回 `preNode` 结点。

> 友情提示：如果对这里 **修改指针指向** 的操作还比较模糊的朋友，我们建议在草稿纸上根据自己的思路模拟出程序的设计流程，想清楚为何要声明 `preNode` 变量和 `nextNode` 变量，以及 **程序的编写顺序** ，为何最后返回的是 `preNode` 变量。

说到这里，可能有一点绕，我们再整理一下这个过程。

+ 我们以 `curNode` 为核心，`curNode` 每前进一格，就改变一个结点的 `next` 指针的指向；
+ 直到 `curNode` 为空，`curNode` 之前的所有结点的 `next` 指针就都完成了指向反转；
+ 循环开始的时候，先初始化 `nextNode` 以便下一轮 `curNode` 能指向正确的位置；
+ 然后是真正的修改 `curNode` 的 `next` 变量的指向；
+ 修改完成以后 `preNode` 和  `curNode` 要依次向前移动一位，注意顺序：先移动 `preNode` 再移动 `curNode`。最后代码写出来，正好是首尾相接的。
+ 最后把 `preNode` 返回。

**参考代码 1**：

请大家注意：「力扣」提交代码的模板里把 `ListNode` 类的代码给注释掉了，我们在提交代码的时候不需要把 `ListNode` 的代码提交上去。

```Java []
public class Solution {
    
    public ListNode reverseList(ListNode head) {
        // 特判
        if (head == null || head.next == null) {
            return head;
        }

        ListNode preNode = null;
        ListNode curNode = head;
        while (curNode != null) {
            ListNode nextNode = curNode.next;
            curNode.next = preNode;
            preNode = curNode;
            curNode = nextNode;
        }
        return preNode;
    }
}
```
**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是链表的结点个数；
+ 空间复杂度：$O(1)$，在修改指针指向的过程中，只使用到常数个临时变量。

反转链表这件事情，还可以这样实现：先改变最后一个结点的 `next` 指向，接着修改倒数第二哥链表的 `next` 指向，最后修改第一个结点的 `next` 指向，这样的过程 **后遍历到的结点先修改指针变量的指向** ，可以通过递归方法实现。

### 方法二：递归实现

由于链表本身也是递归定义的（递归终止条件是：最后一个结点的 `next` 指向为 `null`）。我们可以把问题做拆分：先反转除了第一个结点以外，剩下的那部分单链表。此时需要把第一个结点的下一个结点保存起来，传入下一个递归方法。

在递归方法完成以后，新链表的第一个结点，我们记为 `newHead` ，需要指向还未拆分前的第一个结点。这部分的代码是：

```Java []
ListNode nextNode = head.next;
ListNode newHead = reverseList(nextNode);
nextNode.next = head;
// 这里不要忘记切断引用，否则会出现错误：Error - Found cycle in the ListNode
head.next = null;
return newHead;
```

代码如果只这个样子写是会出问题的。编写递归代码，很重要的一点是 **先写递归终止条件** 。这道题的递归终止条件是：

```Java []
if (head == null || head.next == null) {
  return head;
}
```

它应该写在我们之前逻辑的前面。事实上，递归机制在编程语言中，是通过 **栈** 来实现的，我们会在下一章介绍栈以及栈的应用。使用递归完成「反转链表」的操作，其实是 **符合「后进先出」规律** 的。

借助栈的作用，我们把一些变量给固定住了，例如这里的 `newHead` ，核心的步骤修改了 `next` 指针变量的操作也只有一行，只不过我们不需要去保存和修改那些循环当中的变量的指向，请大家比较两种编码实现的不同之处。

**参考代码 2**：

```Java []
public class Solution {

    public ListNode reverseList(ListNode head) {
        // 特判
        if (head == null || head.next == null) {
            return head;
        }

        ListNode nextNode = head.next;
        ListNode newNode = reverseList(nextNode);
        nextNode.next = head;
        // 这里不要忘记切断引用，否则会出现错误：Error - Found cycle in the ListNode
        head.next = null;
        return newNode;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是链表的结点个数；
+ 空间复杂度：$O(N)$，$N$ 是递归过程中递归栈的最大深度。

---

## 练习

我们给出的问题均可以分别使用 **循环** 和 **递归** 完成，只需要实现其中一种即可。依然是提示大家，解决这些问题不要光动脑想，而 **更需要动笔** ，在纸上把思路以及操作的先后顺序模拟清楚。

1. 完成「力扣」第 92 题：反转链表 II；
2. 完成「力扣」第 203 题：移除链表元素。
3. 完成「力扣」第 24 题：两两交换链表中的节点；
4. 完成「力扣」第 25 题：K 个一组翻转链表；
5. 完成「力扣」第 143 题：重排链表；
6. 完成「力扣」第 328 题：奇偶链表。
7. 完成「力扣」第 61 题：旋转链表（这个问题不用递归去做）；
8. 完成「力扣」第 234 题：回文链表（这个问题做法很多，需留意）；
9. 完成「力扣」第 147 题：对链表进行插入排序（这个问题较复杂，需要有点耐心，不用递归去做）。

---

## 总结

这一节我们通过一个问题，介绍了如何通过修改链表的指针指向，进而修改链表结构的具体操作，只要大家细心，就会发现链表中的问题其实不难。重点考查的思路和细心程度。

这就是这一节的内容，感谢大家。

