# 第 14.7 节 完全背包问题选讲 - 2

这一节我们介绍「力扣」上的两个问题，分别是第 518 题（零钱兑换 II）和第 1449 题（数位成本和为目标值的最大数字）。

## 例 1：「力扣」第 518 题：零钱兑换 II（中等）

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

**示例 1:**

```
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5 = 5
5 = 2 + 2 + 1
5 = 2 + 1 + 1 + 1
5 = 1 + 1 + 1 + 1 + 1
```

**示例 2:**

```
输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
```

**示例 3:**

```
输入: amount = 10, coins = [10] 
输出: 1
```

**注意**:

你可以假设：

- `0 <= amount (总金额) <= 5000`
- `1 <= coin (硬币面额) <= 5000`
- 硬币种类不超过 500 种
- 结果符合 32 位符号整数

**思路分析**：题目的条件和示例告诉我们：同一个硬币可以使用多次，可以看出了当前问题是一个「完全背包问题」。

**转换成为「完全背包」问题**：

+ 使用若干个不同面值的硬币凑出总面值为刚好为 `amount` ，等价于使用若干个物品填满 **恰好** 重量为 `amount` 的背包，这里 `amount` 是约束；
+ 题目中说「假设每一种面额的硬币有无限个」，对应「背包中的物品有无数多个」；
+ 目的是找所有的总数，对应「完全背包问题」中找最优解；
+ 硬币的选取是 **组合（不计较顺序）**，对应于「完全背包问题」中，物品的组合也不计较顺序。

我们依然是先写出不优化空间的代码，然后写出优化空间的代码。

**参考代码 1**：

```Java []
public class Solution {

    public int change(int amount, int[] coins) {
        int len = coins.length;
        if (len == 0) {
            if (amount == 0) {
                return 1;
            }
            return 0;
        }

        // 定义：使用区间 [0..i] 里的硬币，恰好可以凑出面值为 j 的方案总数
        int[][] dp = new int[len][amount + 1];
        dp[0][0] = 1;

        // 初始化
        for (int i = coins[0]; i <= amount; i += coins[0]) {
            dp[0][i] = 1;
        }

        // 递推开始
        for (int i = 1; i < len; i++) {
            for (int j = 0; j <= amount; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j - coins[i] >= 0) {
                    dp[i][j] += dp[i][j - coins[i]];
                }
            }
        }
        return dp[len - 1][amount];
    }
}

```

**复杂度分析**：

+ 时间复杂度：$O(N \cdot amount)$，这里 $N$ 是输入数组 `coins` 的长度，`amount` 是总金额，状态转移的时间复杂度为 $O(1)$；

+ 空间复杂度：$O(N \cdot amount)$。

「参考代码 2」给出状态数组多设置一行的写法。

**参考代码 2**：

```Java []
public class Solution {

    public int change(int amount, int[] coins) {
        int len = coins.length;
        // 定义：使用区间 [0, i) 里的硬币，恰好可以凑出面值为 j 的方案总数
        int[][] dp = new int[len + 1][amount + 1];
        // 初始化
        dp[0][0] = 1;

        // 递推开始
        for (int i = 1; i <= len; i++) {
            for (int j = 0; j <= amount; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j - coins[i - 1] >= 0) {
                    dp[i][j] += dp[i][j - coins[i - 1]];
                }
            }
        }
        return dp[len][amount];
    }
}
```

**复杂度分析**：（同「参考代码 1」）。

「参考代码 3」给出了优化空间的代码。

**参考代码 3**：

```Java []
public class Solution {

    public int change(int amount, int[] coins) {
        int len = coins.length;
        if (len == 0) {
            if (amount == 0) {
                return 1;
            }
            return 0;
        }

        int[] dp = new int[amount + 1];
        // 初始化
        dp[0] = 1;
        for (int i = coins[0]; i <= amount; i += coins[0]) {
            dp[i] = 1;
        }

        // 递推开始
        for (int i = 1; i < len; i++) {
            // 从 coins[i] 开始即可
            for (int j = coins[i] ; j <= amount; j++) {
                if (j - coins[i] >= 0) {
                    dp[j] += dp[j - coins[i]];
                }
            }
        }
        return dp[amount];
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N \cdot amount)$，这里 $N$ 是输入数组 `coins` 的长度，`amount` 是总金额，状态转移的时间复杂度为 $O(1)$；

+ 空间复杂度：$O(amount)$。

---

## 例 2：「力扣」第 1449 题：数位成本和为目标值的最大数字（困难）

给你一个整数数组 `cost` 和一个整数 `target` 。请你返回满足如下规则可以得到的 **最大** 整数：

- 给当前结果添加一个数位（`i + 1`）的成本为 `cost[i]` （`cost` 数组下标从 0 开始）。
- 总成本必须恰好等于 `target` 。
- 添加的数位中没有数字 0 。

由于答案可能会很大，请你以字符串形式返回。

如果按照上述要求无法得到任何整数，请你返回 "0" 。

**示例 1：**

```
输入：cost = [4,3,2,5,6,7,2,5,5], target = 9
输出："7772"
解释：添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 "7772" 的代价为 2*3+ 3*1 = 9 。 "977" 也是满足要求的数字，但 "7772" 是较大的数字。
 数字     成本
  1  ->   4
  2  ->   3
  3  ->   2
  4  ->   5
  5  ->   6
  6  ->   7
  7  ->   2
  8  ->   5
  9  ->   5
```

**示例 2：**

```
输入：cost = [7,6,5,5,5,6,8,7,8], target = 12
输出："85"
解释：添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。"85" 的成本为 7 + 5 = 12 。
```

**示例 3：**

```
输入：cost = [2,4,6,2,4,6,4,4,4], target = 5
输出："0"
解释：总成本是 target 的条件下，无法生成任何整数。
```

**示例 4：**

```
输入：cost = [6,10,15,40,40,40,40,40,40], target = 47
输出："32211"
```

**提示：**

- `cost.length == 9`
- `1 <= cost[i] <= 5000`
- `1 <= target <= 5000`

**思路分析**：

+ 由于每一个数可以使用多次，符合「完全背包问题」的特征；
+ 限制条件是：这些数字消耗的和恰好等于 `target`；

+ 与之前的问题不同的是，本题让我们求出一个具体的解，而不是只问最优解是多少。

> 友情提示：动态规划的问题一般只问最优值是多少，而不问具体的解。

+ 由于数字的位数决定了数字的大小，位数越多的数字肯定越大。因此我们需要 **将状态设计成为能够凑成容量的数字的最大位数是多少**，然后根据动态规划的结果，再求解题目问的最大整数。

**状态定义**：

`dp[i][j]` 表示：使用数组 `cost` 前缀区间 `[0..i]` 里的元素能够刚好凑成和为 `j` 的时候的数字的最大位数。

**状态转移方程**：

一个一个考虑增加可以使用的数字，一点一点增大总的消耗。
$$
dp[i][j] = \max(dp[i - 1][j], dp[i][j - cost[i]] + 1) \; if \; j >= cost[i]
$$
**初始化**：

由于要找的是最大值，因此在初始化的时候就应该设置成为一个不可能取到的负值，我们在这里用 $-1$。其它细节请见「参考代码 1」。

**输出**：

最后一行最后一个状态值 `dp[8][target]`。

**空间优化**：

由于当前状态值只参考了上一行的状态值以及当前行的左边的状态值，因此可以采用正序填表的方式将状态数组设置成为一行进行求解。

**如何得到具体的最大数值**

首先需要保证在有解的前提下，即当  `dp[8][target] != -1` 时才存在最大整数，这是因为题目要求所有的消耗数字消耗之和恰好为 `target`。

> 友情提示：下面的描述是难点，大家需要紧抓状态的定义去理解算法的设计思想。

由于我们要找的是 **最大整数**，可以采用的策略是 **让位于高位的数尽量大**，因此在有解的情况下，我们先拼凑出整数的最高位，然后依次拼出次高位，…… 依次进行下去。于是，我们 **可以从 $9$ 到 $1$ 倒序枚举每一个数位可能的取值，只要枚举到这一位的数字的状态值，恰好等于当前需要的位数的值减 $1$**，我们就可以确定当前的数位的值。

下面我们举例说明：

以示例 1 `cost = [4, 3, 2, 5, 6, 7, 2, 5, 5]`，`target = 9` 为例，计算得到的状态数组为：

| `i \ j​` | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0       | 0    | -1   | -1   | -1   | 1    | -1   | -1   | -1   | 2    | -1   |
| 1       | 0    | -1   | -1   | 1    | 1    | -1   | 2    | 2    | 2    | 3    |
| 2       | 0    | -1   | 1    | 1    | 2    | 2    | 3    | 3    | 4    | 4    |
| 3       | 0    | -1   | 1    | 1    | 2    | 2    | 3    | 3    | 4    | 4    |
| 4       | 0    | -1   | 1    | 1    | 2    | 2    | 3    | 3    | 4    | 4    |
| 5       | 0    | -1   | 1    | 1    | 2    | 2    | 3    | 3    | 4    | 4    |
| 6       | 0    | -1   | 1    | 1    | 2    | 2    | 3    | 3    | 4    | 4    |
| 7       | 0    | -1   | 1    | 1    | 2    | 2    | 3    | 3    | 4    | 4    |
| 8       | 0    | -1   | 1    | 1    | 2    | 2    | 3    | 3    | 4    | 4    |

由于 $9$ 个数字我们都可以使用，所以只有最后一行对我们有用。

从 `dp[8][9] = 4` 可知：最大整数一定有 $4$ 位。那么最高位可不可以是 $9$ 呢？如果是 $9$，`cost[9 - 1] = 5`，而 `dp[8][9 - 5] = dp[8][4] = 2` ，这说明最高位如果选择 $9$ ，剩余的消耗 $4$ 能凑出的整数的位数为 $2 < 3$，因此不能选 $9$ ，同理。不能选 $8$。

下面考察是否可以选 $7$，`cost[7 - 1] = 2`，而 `dp[8][9 - 2] = dp[8][7] = 3` 恰好可以凑成三位整数，因此最高位应该选 $7$，后面的过程依此类推，大家可以结合代码进行理解。

「参考代码 1」给出了不优化空间的代码，「参考代码 2」给出了优化空间的代码。


**参考代码 1**：

```Java []
import java.util.Arrays;

public class Solution {

    public String largestNumber(int[] cost, int target) {
        // 第 1 步：使用动态规划计算最大位数
        // dp[i][j] 表示：使用 cost 前缀区间 [0..i] 里的元素能够刚好凑成和为 j 的时候的数字的最大位数
        int[][] dp = new int[9][target + 1];
        for (int i = 0; i < 9; i++) {
            Arrays.fill(dp[i], -1);
        }
        // 初始化
        dp[0][0] = 0;
        for (int j = cost[0]; j <= target; j++) {
            if (dp[0][j - cost[0]] != -1) {
                dp[0][j] = dp[0][j - cost[0]] + 1;
            }
        }
        // 一个数一个数考虑，因此外层循环是 cost
        for (int i = 1; i < 9; i++) {
            for (int j = 0; j <= target; j++) {
                dp[i][j] = dp[i - 1][j];
                if (cost[i] <= j && dp[i][j - cost[i]] != -1) {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - cost[i]] + 1);
                }
            }
        }
        // 判断是否有结果
        if (dp[8][target] == -1) {
            return "0";
        }

        // 第 2 步：根据第 1 步计算的结果，优先考虑数值大的放在高位，还原最大整数
        int t = target;
        // 最大整数的位数
        int len = dp[8][target];
        StringBuilder res = new StringBuilder();
        int i = 8;
        while (t > 0) {
            // 这一步选谁
            int num = -1;
            // 倒着选，如果正着选会选出最小值
            for (int j = 9; j >= 1; j--) {
                if (t >= cost[j - 1] && dp[i][t - cost[j - 1]] == len - 1) {
                    num = j;
                    break;
                }
            }
            res.append(num);
            t -= cost[num - 1];
            len--;
        }
        return res.toString();
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N \cdot target + L \cdot N)$，这里 $N$ 是输入数组 `cost` 的长度，$N = 9$。$L$ 是在有解的情况下，最大整数的位数：`L = dp[8][target]`；
  + 动态规划步骤的时间复杂度为 $O(N \cdot target)$；
  + 计算最大整数的时候，遍历 $1$ 到 $9$ 的次数取决于 `L`。
+ 空间复杂度：$O(N \cdot target + L)$，保存结果集需要空间 `L`。

**参考代码 2**：

```Java []
import java.util.Arrays;

public class Solution {

    public String largestNumber(int[] cost, int target) {
        // dp[i] 表示：和为 i 的时候最长可以填多少个数字
        int[] dp = new int[target + 1];
        Arrays.fill(dp, -1);
        dp[0] = 0;
        for (int c : cost) {
            for (int i = c; i <= target; i++) {
                if (dp[i - c] != -1) {
                    dp[i] = Math.max(dp[i], dp[i - c] + 1);
                }
            }
        }
        // 判断是否有结果
        if (dp[target] == -1) {
            return "0";
        }

        // 在有结果的前提下，倒序反推路径
        int t = target;
        int len = dp[target];
        StringBuilder res = new StringBuilder();
        while (t > 0) {
            int num = -1;
            // 倒着选，如果正着选会选出最小值
            for (int i = 9; i > 0; i--) {
                if (t >= cost[i - 1] && dp[t - cost[i - 1]] == len - 1) {
                    num = i;
                    break;
                }
            }
            res.append(num);
            t -= cost[num - 1];
            len--;

        }
        return res.toString();
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N \cdot target + L \cdot N)$，分析同「参考代码 1」；
+ 空间复杂度：$O(target + L)$。

---

## 总结

动态规划问题我们暂时介绍到这里，动态规划的问题题型比较多，只有见得多了，才能达到举一反三的地步。因此掌握基础的、常见的动态规划问题、状态设计思想是很重要的，希望大家能够反复理解和推敲，而不仅仅只停留在记住「状态设计」和记住「状态转移方程」的阶段，更要想清楚为什么这样设计，通过调试理解理解解决问题的细节。
