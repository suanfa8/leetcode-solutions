# 第 14.1 节 0-1 背包问题

![image.png](https://pic.leetcode-cn.com/1614433306-LBsiZn-image.png)

「背包问题（knapsack problem）」是一类非常经典的有约束条件的最优化问题，并且是 [整数规划](https://baike.baidu.com/item/%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/2452450?fr=aladdin) 问题。

本章节只介绍两类最基本的背包问题：「0-1 背包问题」和「完全背包问题」。其中「0-1 背包问题」是理解「完全背包问题」的基础，更多的背包问题请见本节文末的「参考资料」。

## 0-1 背包问题

有若干个物品，每个物品有两个属性：价值和重量。现在考虑将这些物品装入一个容器，称为「背包」，背包只有一个属性：「最大承重」，**每个物品只有一件**。问如何选择物品，使得所选物品的重量总和在不超过背包的「最大承重」的前提下，这些物品的价值总和最大。

> 背包问题可以简单记为：有约束的最优化问题。「约束」是背包的重量（有些资料上可能称为「体积」，不管是「重量」还是「体积」，都可以理解为「约束」，是想要达到目的所需要付出的代价）。需要「最优化」的是物品总价值，问在条件受限的情况下，求最大利益的值。

**为什么称为「0-1 背包问题」**：由于每一个物品要么被选择放入背包，要么不放入背包，只有不选（用 $0$ 表示）和选（用 $1$ 表示）两种可能，因此称为「0-1 背包问题」。「0-1 背包问题」在「力扣」上没有对应的问题，我们将它形式化描述如下。

> 有 $N$ 个重量和价值分别为 $w_i$ 和 $v_i$ 的物品。从这些物品中挑选总重量不超过 $W$ 的物品，每个物品只有一件，求所有挑选方案中价值总和的最大值。

**提示**：

+ $1 \le N \le 100$
+ $1 \le w_i,v_i \le 100$
+ $1 \le W \le 1000$


输入：
```
N = 4 
w = [4, 3, 1, 1]
v = [300, 200, 150, 200]
W = 5
```

输出：550


一个直觉是：优先选择价值较大的物品装进背包，但是这种思路不能得到最优解。下面是一个反例。

+ 优先选择价值较大的物品装进背包：选择物品 1 （价值 $300$，重量 $4$）和物品 4（价值 $200$，重量 $1$），总价值为 $500$；
+ **最优解**：物品 2 （价值 $200$，重量 $3$）、物品 3（价值 $150$，重量 $1$）和物品 4（价值 $200$，重量 $1$），总价值为 $550 > 500$。

> 友情提示：这种思路称为「贪心」，只关注当前最优选择。但不适用于 0-1 背包问题，在有背包最大称重约束的前提下，贪心的思路不能得到最优解，都谈不上正确性，因此也不能称为算法。

我们依然从暴力解法开始说起。

### 方法一：暴力解法

由于每一件物品都可以放进背包，也可以不放进背包，可以针对每一个物品是否放入背包进行搜索。这样 $N$ 件物品就有 $2^N$ 种选择，再对这 $2^N$ 种选择方案进行遍历选出最大值，总的时间复杂度为：$O((2^N)\cdot N)$。

下图是暴力解法的递归调用树形图：

<![14-01-01.001.jpeg](https://pic.leetcode-cn.com/1606124507-EMtJcM-14-01-01.001.jpeg),![14-01-01.002.jpeg](https://pic.leetcode-cn.com/1606124507-EeSyBq-14-01-01.002.jpeg),![14-01-01.003.jpeg](https://pic.leetcode-cn.com/1606124507-AlrSRX-14-01-01.003.jpeg),![14-01-01.004.jpeg](https://pic.leetcode-cn.com/1606124507-TFzJOy-14-01-01.004.jpeg),![14-01-01.005.jpeg](https://pic.leetcode-cn.com/1606124507-EkKaOv-14-01-01.005.jpeg)>


我们可以发现，在第三层出现了数对 `(3, 1)` ，即：遇到了重复子问题。

![image.png](https://pic.leetcode-cn.com/1606153985-hjSgvT-image.png)

暴力解法考虑了所有的情况，并且 **重复的子问题也进行了计算**，时间复杂度高。可以采用「记忆化递归」的方式进行优化。执行相同参数的部分不会继续求解，由于参数 $W$ 和 $N$ 的组合一共有 $NW$ 种，因此「记忆化递归」的时间复杂度为 $O(NW$) 。

我们已经很熟悉动态规划「自顶向下」的思考方向，这里我们省略「记忆化递归」的参考代码，感兴趣的朋友可以自己实现。

### 方法二：动态规划


![image.png](https://pic.leetcode-cn.com/1614433620-fKSGxq-image.png)

观察到：题目中给出的示例，「物品 1」与「物品 2」 的重量之和（为 $4$）等于「物品 0」 的重量（也为 $4$），但是它们的价值总和（$350$）大于「物品 0」的价值（$300$）， 因此用「物品 1」与「物品 2」的组合替换「物品 0」是更好的方案。

「0-1 背包」问题的「动态规划」算法正是基于比较的思想：**一个一个添加物品，重量一个单位一个单位增加**，每一次考虑一个物品，就比较「选它」和「不选它」两种方案，哪个结果更好。

> 友情提示：这种思想其实也很符合我们日常生活的思维，逐个尝试。在一点一点比较的过程中，选出价值更大且重量更小的物品装入背包。

#### 第 1 步：定义状态

思路是：**一个一个物品考虑是否添加进背包**，并且 **背包有最大承重限制**。根据「无后效性」的动态规划设计原则，将第一维设置成为考虑的物品的下标区间（前缀区间），从 $0$ 开始到 $N - 1$，第二维设置成背包重量，从 $0$ 开始到 $W$。

> 友情提示：「无后效性」告诉我们：有约束可以在状态数组的后面增加一维，这里「背包最大承重」就是约束，固定住 $0$ 到 $W$ 的每一个状态进行讨论，方便状态进行转移。

`dp[i][j]` 表示：考虑下标区间范围是 `[0..i]` 内的所有物品，且重量总和不超过 `j` 时，背包能装下物品的最大价值总和。

#### 第 2 步：推导出状态转移方程

对于下标为 `i` 的物品，有「选」和「不选」两种方案，比较这两种方案选出更好的。 


+ 下标为 `i` 的物品没有被选择时，问题转化成求物品的下标区间 `[0.. i - 1]` 里，选出重量总和不超过 `j` 的最大价值总和，即 `dp[i - 1][j]` 为所求，这里 `i >= 1`； 
+ 下标为 `i` 的物品被选择时，则问题转化成求物品的下标区间 `[0.. i - 1]` 里，选出重量总和不超过 `j - w[i]` 的最大价值总和，即 `dp[i - 1][j - w[i]] + v[i]` 为所求，这里 `i >= 1`，并且 `j - w[i] >= 0` 即 `w[i] <= j` ，也就是说，下标为 `i` 的物品的重量 `w(i)` 要 **小于等于** 当前考虑的背包承重 `j` ，状态转移才能发生。

整理一下，状态转移方程为：

$$
dp[i][j] = \max \left( dp[i - 1][j], \; dp[i - 1][j - w[i]] + v[i] \right), i \ge 1, j \ge w[i]
$$


下面的动画展示了「自底向上」递推求解「0-1 背包问题」的过程。**除了下标为 $0$ 的行以外，每一行的值都参考了上一行 `dp[i - 1][j]` 的值以及 `dp[i - 1][j - w[i]]` 的值**，在下面的动画中使用着重号标记了出来。

<![14-01-01.001.jpeg](https://pic.leetcode-cn.com/1613979833-jRnyRA-14-01-01.001.jpeg),![14-01-01.002.jpeg](https://pic.leetcode-cn.com/1613979833-lJKpYI-14-01-01.002.jpeg),![14-01-01.003.jpeg](https://pic.leetcode-cn.com/1613979833-dlaaIO-14-01-01.003.jpeg),![14-01-01.004.jpeg](https://pic.leetcode-cn.com/1613979833-NBJRxy-14-01-01.004.jpeg),![14-01-01.005.jpeg](https://pic.leetcode-cn.com/1613979833-OQOVwI-14-01-01.005.jpeg),![14-01-01.006.jpeg](https://pic.leetcode-cn.com/1613979833-CnGANi-14-01-01.006.jpeg),![14-01-01.007.jpeg](https://pic.leetcode-cn.com/1613979833-TApFtJ-14-01-01.007.jpeg),![14-01-01.008.jpeg](https://pic.leetcode-cn.com/1613979833-DyvqQM-14-01-01.008.jpeg),![14-01-01.009.jpeg](https://pic.leetcode-cn.com/1613979833-TcBJyc-14-01-01.009.jpeg),![14-01-01.010.jpeg](https://pic.leetcode-cn.com/1613979833-JILrlK-14-01-01.010.jpeg),![14-01-01.011.jpeg](https://pic.leetcode-cn.com/1613979833-FrLmNA-14-01-01.011.jpeg),![14-01-01.012.jpeg](https://pic.leetcode-cn.com/1613979833-KpeWOe-14-01-01.012.jpeg),![14-01-01.013.jpeg](https://pic.leetcode-cn.com/1613979833-uHfUbk-14-01-01.013.jpeg),![14-01-01.014.jpeg](https://pic.leetcode-cn.com/1613979833-MVPrfL-14-01-01.014.jpeg),![14-01-01.015.jpeg](https://pic.leetcode-cn.com/1613979833-zfBqBM-14-01-01.015.jpeg)>

> 第一次接触「0-1 背包问题」可能会觉得很陌生。根据以往同学学习的经验，我们 **强烈建议** 大家自己填一次表，理解「为什么要通过表格记录 **所有的** 状态」，以及状态转移的含义（其实就是在「选」和「不选」中选出最好的）。自己动手填表，比看几次教程要有效得多。


**参考代码 1**：

```Java []
public class Solution {

    public int backpack01(int W, int[] weights, int[] values) {
        int N = weights.length;
        if (N == 0) {
            return 0;
        }

        // dp[i][j] 表示：考虑物品区间 [0..i] 里，不超过背包容量 j，能够获得的最大价值，由于包含价值为 0 的计算，所以 + 1
        int[][] dp = new int[N][W + 1];
        // 初始化：先写第 1 行
        for (int j = 1; j <= W; j++) {
            // 第 1 个物品的体积要小于等于背包容量
            if (weights[0] <= j) {
                dp[0][j] = values[0];
            }
        }
        // 递推开始
        for (int i = 1; i < N; i++) {
            for (int j = 0; j <= W; j++) {
                dp[i][j] = dp[i - 1][j];
                if (weights[i] <= j) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - weights[i]] + values[i]);
                }
            }
        }
        return dp[N - 1][W];
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(NW)$，这里 $N$ 是背包价值数组的长度，$W$ 是背包的容量；
+ 空间复杂度：$O(NW)$。

**说明**：观察状态转移方程，下标为 `i` 的行参考了下标为 `i - 1` 的行的状态值。为了让 `i - 1 >= 0`，下标为 `0` 的行需要初始化。事实上，可以将状态二维数组多设置一行，表示 **添加了一个重量为 $0$、价值为 $0$ 的物品，计算结果与原问题等价**。

下面的「参考代码 2」给出了示例代码。事实上，这样处理「初始化」的思路我们不是第一次见到了。在编码时，需要注意处理下标偏移等细节。

**参考代码 2**：

```Java []
public class Solution {

    public int backpack01(int W, int[] weights, int[] values) {
        int N = weights.length;
        if (N == 0) {
            return 0;
        }

        // dp[i][j] 表示：考虑物品区间 [0..i] 里，不超过背包容量，能够获得的最大价值
        int[][] dp = new int[N + 1][W + 1];
        // 递推开始，以 dp 数组为视角，从 1 开始，到 N 为止
        // 注意：遇到物品的下标都减 1
        for (int i = 1; i <= N; i++) {
            for (int j = 0; j <= W; j++) {
                dp[i][j] = dp[i - 1][j];
                if (weights[i - 1] <= j) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);
                }
            }
        }
        return dp[N][W];
    }
}
```

**复杂度分析**：（同参考代码 1）


---

## 参考资料

+ 崔添翼：《[背包问题九讲 2.0 beta1.2](https://github.com/tianyicui/pack)》。

---

## 总结

+ 请大家通过「0-1 背包问题」的状态设计，理解「无后效性」是如何应用在状态设计上的：**为了使得求解过程满足「无后效性」，在设计状态的时候可以在状态数组后面增加维数**；
+ **特别重要**：「0-1 背包问题」依然是考虑了 **所有** 能够放入背包的物品的组合，并且在尝试放入背包的过程中进行 **比较** 和 **记录** 所有中间过程，通过「自底向上」递推得到所求问题的答案；

> 「动态规划」考虑了一个问题 **所有的** 子问题，「0-1 背包问题」使用「动态规划」的解法也不例外，由于有非常多的子问题，并且有两个维度，因此我们设计一个二维表格记录求解的所有子问题。

+ 如果对于「0-1 背包问题」的状态转移还不太熟悉的朋友，我们强烈建议大家使用一个简单的测试用例，在纸上画表格模拟算法的执行流程；

「0-1 背包问题」有非常经典的优化空间的方法，必须掌握，我们放在下一节说。这就是这一节的内容，感谢大家。

