# 第 11.4 节 典型问题 2：二叉树的最近公共祖先

这一节我们看二叉树的一个非常经典的问题。

---

## 例：「力扣」第 236 题：二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：「对于有根树 T 的两个结点 `p`、`q`，最近公共祖先表示为一个结点 `x`，满足 `x` 是 `p`、`q` 的祖先且 `x` 的深度尽可能大（一个节点也可以是它自己的祖先）。」

例如，给定如下二叉树:  `root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]`

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)



示例 1：

```
输入: root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```


示例 2：

```
输入: root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

<br>

---


首先，我们需要清楚什么是 **二叉树的祖先**。从当前结点向根结点的一条唯一的路径上所有的结点为当前结点的祖先结点，这一点基于一个 **非常重要的事实**，那就是：除了根结点以外，二叉树的每一个结点都只有一个父亲结点。

+ 如果每一个结点有指向父亲结点的引用，可以转换为「力扣」第 161 题（相交链表）；
+ 注意 `p`，`q` 必然存在在这颗二叉树内，且所有结点的值唯一，这题题目给我们的条件；
+ 我们可以从下往上看树的结构，先得到子树的信息，然后才处理根结点的逻辑，因此使用「后序遍历」的思想，即：先对左右子树进行查找，然后再根据左右子树的返回值判断当前结点是不是最近公共祖先结点，容易得出规则如下：
  + 如果左右子树返回值恰好只有一个不为空，把非空的结点传上去；
  + 如果左右子树返回值均为 `null`，说明 `p` 和 `q` 均不在树中， 返回 `null`。
  + 左右子树的返回值都不为空，把当前结点往上面传；
  

按照这种规则，就能够在「深度优先遍历」（后序遍历）完成以后，在根结点得到「二叉树的最近公共结点」。在这个过程中，虽然不符合「最近公共祖先」的语义，但是结果能保证把「最近公共祖先」返回给调用函数。


![11-04-01.gif](https://pic.leetcode-cn.com/1598950470-XfGPKR-11-04-01.gif)

**说明**：这道题光看代码有可能比较难理解题目的意思，建议大家通过 **后序遍历** 的思想，举几个特殊的例子，想一想如何设计规则：通过两个子树的信息向上传递，得到输入结点的最近公共祖先结点。


**参考代码**：

```Java []
public class Solution {

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) {
            return root;
        }

        // 后序遍历
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        // 这一句特别重要，如果左边和右边都非空，把当前结点返回回去
        if (left != null && right != null) {
            return root;
        }

        // 下面的这种写法包含了 left 和 right 同时为空的情况
        if (left == null) {
            return right;
        }
        return left;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是结点个数，每个结点只访问一次；
+ 空间复杂度：$O(N)$，最坏情况下，树退化成链表，即栈里需要树的结点这么多的空间。


---

## 练习

1. 完成 「力扣」第 297 题：二叉树的序列化与反序列化（困难）；
2. 完成 「力扣」第 543 题：二叉树的直径（简单）；
2. 完成 「力扣」第 1443 题：收集树上所有苹果的最少时间（中等）。

---

## 总结

二叉树我们就向大家介绍到这里了，树的问题很多时候需要遍历。尤其要关注 **后序遍历**，理解后序遍历的思想，相信能给解决一些树上的问题一些帮助。







