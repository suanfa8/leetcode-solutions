# 第 8.5 节 典型问题 3：单调栈

这一节我们要介绍栈的具体应用：单调栈（Monotonous Stack）。

单调栈是用于解决特定问题的特殊技巧。使用单调栈解决的问题一般都偏难，想起来很绕，因此思考方法一般也是在纸上画图。这一类问题要么是典型问题，要么是比较困难的问题，好在这些问题其实并不多。

如果只是准备面试，会做一些典型的单调栈的问题即可。这里依然建议大家把主要精力放在学习基础的算法和数据结构知识上。

---

首先要和大家说明的一点是：单调栈不是一个新的数据结构，**单调栈就是普通的栈**。对单调栈中元素的加入和取出依然要满足 **后进先出** 的原则。叫它单调栈是因为：在解决一些特定问题的过程中，栈中的元素在数值上 **恰好** 保持单调性。


用单调栈解决的问题的特点是（有个印象就好，无需记忆）：找出当前元素左边（或者右边）第 $1$ 个比当前元素大或者小的那个元素。

事实上，我们只需要在纸上模拟一下，就容易看出，其实这样的规律是显然的：保持栈中元素单调性的同时，**新栈顶元素就是当前栈顶元素左边第 $1$ 个比当前元素大或者小的那个元素** 。

![image.png](//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75f4a09f657d460baf80ab86b1e25efa~tplv-k3u1fbpfcp-zoom-1.image)


对于使用单调栈解决的问题，一般先考虑暴力解法，然后从 **用空间换时间** 角度出发，看看解决这个问题的过程中是否符合 **后进先出** 的规律，进而考虑 **栈** 是否能够帮助我们高效地解决这个问题。

我们这一节介绍的例子是「力扣」第 42 题：接雨水。

---

## 例：「力扣」第 42 题：接雨水

这道题给我们若干个宽度为 $1$ 的柱子的高度图，问我们在重力平衡系统的作用下，下雨之后能接多少雨水。

![](//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e63279014aca45b7b8faab97ef362863~tplv-k3u1fbpfcp-zoom-1.image)

上面是由数组 `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` 表示的高度图，在这种情况下，可以接 $6$ 个单位的雨水（蓝色部分表示雨水）。

示例:

```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

**思路分析**：我们在双指针那一节曾经介绍过这个问题的解法。事实上，我们通过一点一点分析，可以看出解决这个问题符合 **后进先出** 的规律。

<!-- ![第 42 题：接雨水（单调栈）.mp4](54741b03-0e52-4d20-b5dd-98458ce8b23c) -->


**形成凹槽是能储存雨水的原因**。

我们从左向右一根柱子一根柱子看，观察什么时候会出现凹槽。当出现凹槽的时候，就计算当前形成的凹槽能储存的雨水的量。为了更方便看出规律，我们使用一个相对有代表性的例子向大家进行说明：`[8, 6, 4, 2, 1, 5, 7]`，如下图所示：


<![08-05-01.001.jpeg](https://pic.leetcode-cn.com/1599212659-vJXREZ-08-05-01.001.jpeg),![08-05-01.002.jpeg](https://pic.leetcode-cn.com/1599212659-nmrsOq-08-05-01.002.jpeg),![08-05-01.003.jpeg](https://pic.leetcode-cn.com/1599212659-xAjeSQ-08-05-01.003.jpeg),![08-05-01.004.jpeg](https://pic.leetcode-cn.com/1599212659-fbsVVp-08-05-01.004.jpeg),![08-05-01.005.jpeg](https://pic.leetcode-cn.com/1599212659-NBMLXp-08-05-01.005.jpeg),![08-05-01.006.jpeg](https://pic.leetcode-cn.com/1599212659-RgNUsz-08-05-01.006.jpeg),![08-05-01.007.jpeg](https://pic.leetcode-cn.com/1599212659-IkeZNh-08-05-01.007.jpeg),![08-05-01.008.jpeg](https://pic.leetcode-cn.com/1599212659-vCNXBL-08-05-01.008.jpeg),![08-05-01.009.jpeg](https://pic.leetcode-cn.com/1599212659-DKPdPP-08-05-01.009.jpeg),![08-05-01.010.jpeg](https://pic.leetcode-cn.com/1599212659-iIOWyr-08-05-01.010.jpeg),![08-05-01.011.jpeg](https://pic.leetcode-cn.com/1599212659-DWrnKv-08-05-01.011.jpeg),![08-05-01.012.jpeg](https://pic.leetcode-cn.com/1599212659-trpKcW-08-05-01.012.jpeg),![08-05-01.013.jpeg](https://pic.leetcode-cn.com/1599212659-fEbgOR-08-05-01.013.jpeg),![08-05-01.014.jpeg](https://pic.leetcode-cn.com/1599212659-eNUPNn-08-05-01.014.jpeg)>



我们总结一下规律：

+ **从左向右** 看，在柱形的高度递减（或者非递增）的时候，不能存雨水，我们将它们一次放入一个缓存中；
+ 可以形成凹槽的条件是，当前看到的柱形的高度比此时在缓存中 **最后添加** 的那个柱形的高度严格大，由于 **缓存中保存柱形的高度是单调不增** 的，此时形成了一个凹槽，可以计算出缓存中 **最后添加** 的那个柱形与两边柱形形成的雨水量；
+ 这种计算的顺序符合 **后添加到缓存中的柱形先计算** 的规律，因此，这个缓存是 **栈**；
+ 由于计算存雨水量需要计算两边柱子之间的距离，因此我们 **在栈里存的是柱形的下标**；
+ 雨水量 = 底 $\times$ 高。底 = 左右两个柱形（虚线当做不存在）的下标之差 - 1，高 = 左右两个柱形（虚线当做不存在）高度中较矮的那个。


**参考代码**：

```Java []
import java.util.ArrayDeque;
import java.util.Deque;

public class Solution {

    public int trap(int[] height) {
        int len = height.length;
        if (len < 3) {
            return 0;
        }

        int area = 0;
        Deque<Integer> stack = new ArrayDeque<>(len);
        for (int i = 0; i < len; i++) {
            while (!stack.isEmpty() && height[stack.peekLast()] < height[i]) {
                // 作为底部支撑的那个柱形的下标
                Integer bottomIndex = stack.removeLast();
                // 出栈以后，如果栈为空，说明不能形成凹槽，此时跳过即可
                if (stack.isEmpty()) {
                    break;
                }

                int width = i - stack.peekLast() - 1;
                // 根据木桶原理，高度取决于，i 的高度和弹栈以后的新栈顶元素的高度
                int currentHeight = Math.min(height[stack.peekLast()], height[i]) - height[bottomIndex];
                area += (width * currentHeight);
            }
            // 栈中存下标
            stack.addLast(i);
        }
        return area;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是数组的长度，所有的元素进栈一次，出栈一次；
+ 空间复杂度：$O(N)$，栈中最多存 $N$ 个元素。


---

## 练习

1. 完成「力扣」第 739 题：每日温度；
2. 完成「力扣」第 496 题：下一个更大元素 I；
3. 完成「力扣」第 503 题：下一个更大元素 II；
4. 完成「力扣」第 84 题：柱状图中最大的矩形；
> 友情提示：第 84 题也是「单调栈」算法的经典入门问题，请参考官方题解。
5. 完成「力扣」第 1019 题：链表中的下一个更大节点。

---

## 总结


单调栈的问题希望大家有这样一个认识：解决这些问题需要看到 **后进先出**，所以使用 **栈**，而保持单调性是自然而然的。换言之，这些问题很多时候是有针对性的，保持栈内元素的单调性是结果，而不是原因。




