
# 第 8.9 节 典型问题 3：单调队列

单调队列就是普通的队列，只不过在使用队列的过程中，根据问题的特点保持了队列的单调性。这一节我们来看一个单调队列的经典问题：「力扣」第 239 题。

---

## 例 1：「力扣」第 239 题：滑动窗口的最大值

给定一个数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

示例：

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

滑动窗口的位置                最大值

---------------               -----

[1  3  -1] -3  5  3  6  7       3
1 [3  -1  -3] 5  3  6  7       3
1  3 [-1  -3  5] 3  6  7       5
1  3  -1 [-3  5  3] 6  7       5
1  3  -1  -3 [5  3  6] 7       6
1  3  -1  -3  5 [3  6  7]      7
```

提示：你可以假设 `k` 总是有效的，在输入数组不为空的情况下，`1 ≤ k ≤` 输入数组的大小。

**进阶** ：你能在线性时间复杂度内解决此题吗？

---

比较容易想到的方法是暴力法。

### 方法一：暴力解法

暴力解法的思路是遍历 **所有** `k` 个长度的子区间，分别求出它们的最大值。

**参考代码 1**：

```Java []
class Solution {
    
    public int[] maxSlidingWindow(int[] nums, int k) {
        int len = nums.length;
        if (len == 0){
            return new int[0];
        }
        int[] res = new int[len - k + 1];
        // 枚举所有滑动窗口的终点
        for (int i = k - 1; i < len ; i++) {
            int max = Integer.MIN_VALUE;
            for (int j = i - k + 1; j <= i; j++) {
                max = Math.max(max, nums[j]);
            }
            res[i - k + 1] = max;
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(NK)$，这里 $N$ 是输入数组的长度，$K$ 是滑动窗口的长度；
+ 空间复杂度：$O(1)$。

暴力解法做了很多重复的工作，除了最开始的 $k - 1$ 个数和倒数 $k - 1$ 个数以外，每一个数都参与比较了 $k$ 次。

---

### 方法二：基于暴力算法的优化

<!-- ![...题：滑动窗口的最大值（单调队列）.mp4](b5120125-2887-4366-94c5-093112c6eb40) -->

暴力解法的优化需要注意到以下事实：**如果新来的数比之前的数严格大，那么之前的数就不可能成为滑动窗口的最大值**，可以 **提前** 把它们都从候选集合中删除。依然是我们一步一步模拟窗口滑动的过程，我们就使用题目中的示例进行分析。

（提示：下面的文字有点多，但是可以不用全部看完，重要的部分已经加上了着重号，在理解了算法设计思想以后，建议大家自行分析，并写出代码）。

+ 第 1 步：程序看到 $1$。

`[[1], 3, -1, -3, 5, 3, 6, 7]`

此时还未形成长度为 $3$ 的窗口，右边界右移 $1$ 格。我们先将 $1$ 加入一个缓存。

+ 第 2 步：程序看到 $3$。

`[[1, 3], -1, -3, 5, 3, 6, 7]`

此时还未形成长度为 $3$ 的窗口，但 $3 > 1$，**由于 $3$ 的存在，$1$ 一定不会是现在和将来要形成的滑动窗口的最大值**。于是可以不考虑 $1$，需要将 $1$ 移出缓存，把 $3$ 加入缓存。然后右边界右移 $1$ 格。

+ 第 3 步：程序看到 $-1$。

`[[1, 3, -1], -3, 5, 3, 6, 7]`

当 $-1$ 进来的时候，以后 $3$ 由于到达滑动窗口的左边界而不得不滑出的时候，$-1$ 有可能成为滑动窗口的最大值，因此 $-1$ 需保留。把 $-1$ 加入缓存。当前滑动窗口的最大值为 $3$ ，缓存中的数据为：`[3, -1]`。

当前滑动窗口的最大值为 $3$。

+ 第 4 步：程序看到 $-3$。

`[1, [3, -1, -3], 5, 3, 6, 7]`

此时 $-3$ 比缓存中最近添加的元素 $-1$ 还小，当 $3$ 和 $- 1$ 由于到达滑动窗口的左边界而不得不滑出的时候，$-3$ 有可能成为滑动窗口的最大值，因此 $-3$ 需要加入缓存。此时缓存为 `[3, -1, -3]`。

当前滑动窗口的最大值为 $3$。

+ 第 5 步：程序看到 $5$。

`[1, 3, [-1, -3, 5], 3, 6, 7]`

此时 $3$ 不得不从滑动窗口的左边界滑出。然后 $5$ 进来，$5 > -3$，$5$ 后进来，因此 **$-3$ 一定不可能是当前和以后得到的滑动窗口的最大值**，可以把 $-3$ 从缓存里删除。此时缓存为 `[-1]`。

同理由于 $5 > -1$，$5$ 后进来，因此 $-1$ 一定不可能是当前和以后得到的滑动窗口的最大值，把它从缓存中删除，此时缓存为 `[5]`。

当前滑动窗口的最大值为 $5$。

+ 第 6 步：程序看到 $3$。

`[1, 3, -1, [-3, 5, 3], 6, 7]`

$3 < 5$，当 $5$ 由于到达滑动窗口的左边界而不得不滑出的时候，$3$ 有可能成为滑动窗口的最大值，因此需要将 $3$ 加入缓存。此时缓存为 `[5, 3]`。

当前滑动窗口的最大值为 $5$。

+ 第 7 步：程序看到 $6$。

`[1, 3, -1, -3, [5, 3, 6], 7]`

$6 > 3$，$6$ 还要后进来，因此 $3$ 一定不可能是当前和以后得到的滑动窗口的最大值，可以把 $3$ 从缓存里删除，此时缓存为 `[5]`。同理，$5 > 3$，$5$ 还要后进来，因此 $5$ 一定不可能是当前和以后得到的滑动窗口的最大值，可以把 $5$ 从缓存里删除，接着把 $6$ 加进来。此时缓存为 `[6]`。

当前滑动窗口的最大值为 $6$。

+ 第 8 步：程序看到 $7$。

`[1, 3, -1, -3, 5, [3, 6, 7]]`

$7 > 6$ ，$7$ 还要后进来，因此 $6$ 一定不可能是当前和以后的滑动窗口的最大值，把 $6$ 从缓存中删除，添加 $7$ ，此时缓存为 `[7]`。

当前滑动窗口的最大值为 $7$。

输出：

```
[3, 3, 5, 5, 6, 7]
```

### 为什么是双端队列（重要）


根据上面的分析，需要一个数据结构作为缓存。首先是一个它是线性结构，然后可以想象让滑窗不动，数组动，因此这个线性结构是一个队列。

这个队列需要支持的操作有：

+ 删除队首信息：当滑窗离开左边界的时候，当前最大值需要被删除。注意：这一步需要准确知道队首的下标，因此队列中存的是下标。
+ 查看队首信息：队首元素一定是当前滑动窗口的最大值；
+ 队尾添加：如果一个数有可能是将来的滑动窗口的最大值，我们就把它添加到队尾新；
+ 队尾删除：如果新来的数比当前队尾的数还要大，当前队尾元素一定不可能是滑动窗口的最大值，需要把当前队尾删除。**这个过程是循环进行的**。

整个队列的数值（不是下标）呈现的特征是单调不减的，因此是一个单调队列。这个方便在队首和队尾操作和查看的数据结构是双端队列，双端队列的实现可以是动态的循环数组，也可以是双向链表。


**参考代码 2**：

说明：这个问题的细节比较多，如果对于 $+1$ 、$-1$ 还比较迷惑，对于「大于等于」是不是可以取「等号」还拿不定的话。一定要结合具体的例子和题目中的意思，仔细分析和调试。这个是程序员的基本功。

```Java []
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;

public class Solution {

    public int[] maxSlidingWindow(int[] nums, int k) {
        int len = nums.length;
        if (len == 0 || len < k) {
            return new int[0];
        }
        int[] res = new int[len - k + 1];

        Deque<Integer> deque = new ArrayDeque<>(len - k + 1);
        for (int i = 0; i < len; i++) {
            // 判断队首元素是否移出滑动窗口
            if (i >= k && !deque.isEmpty() && deque.peekFirst() == i - k) {
                deque.removeFirst();
            }

            // 依次判断待添加元素是否比队首元素大，注意可以取等号
            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
                deque.removeLast();
            }

            // 加入队列的是下标
            deque.addLast(i);

            if (i >= k - 1) {
                res[i - k + 1] = nums[deque.peekFirst()];
            }
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是输入数组的长度；
+ 空间复杂度：$O(N)$。
----


## 总结

单调队列的问题和单调栈一样，都很有局限性，应用范围不多。单调队列还应用在以后将要学习的动态规划问题的优化步骤中，这已经是算法竞赛的内容了，感兴趣的朋友可以查阅资料进行学习。

栈和队列的问题我们就介绍到这里了。栈和队列都是线性结构的缓存，应用栈和队列，一定要分析清楚处理问题的先后顺序。

事实上，关于栈和队列这两个数据结构，在计算机的世界里有着很广泛的应用，我们在后续课程的学习中，还会看到它们的身影。下一章节，我们来学习一种特殊的、并且应用十分广泛的队列：优先队列。

