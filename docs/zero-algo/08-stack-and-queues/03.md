# 第 8.3 节 典型问题 1：简化路径

这一节，我们来看一个栈的应用：「力扣」 第 71 题： 简化路径（中等）。

---

## 例：「力扣」 第 71 题： 简化路径

这道题要求我们将一个 Unix 风格的绝对路径转换为规范路径（这里忽略题目中的大段描述）。输入是一个字符串，在这个字符串里有一些斜杠，这些斜杠表示 **目录** 或者 **操作** 的分隔符。

具体来说：

+ 如果是英文字母，就表示一个 **目录**。
+ 如果是一个点或者两个点，表示的是 **操作**。其中一个点 `.` 表示停留在当前目录，两个点 `..` 表示返回上一级目录。

**题意分析**：从题目的文字说明和 $3$ 个示例中我们知道（看示例理解题意很重要）：

+ 规范的路径的 **结尾** 不能有斜杠；
+ 出现两个小圆点 `..` 的时候，它前面的那个表示目的字符串可以当做不存在。即：简化的目的是 **去掉多余的斜杠和目录** 。

我们再分析一下：题目为什么需要我们简化它呢？原因是有 `..` 表示返回上一级目录。例如：`/a/b/../..` 这个表示路径的字符串，表示先进入目录 `a` 再进入目录 `b` ，然后遇到两个`..` 回到它的父目录，也就是回到了目录 `a` ，然后又遇到两个`..` 回到它的父目录，也就是回到了根目录 `/` ，那么这个路径就被简化为一个斜杠 `/`。题目要我们返回这个斜杠。

![image.png](https://pic.leetcode-cn.com/1599116218-BwGcKG-image.png)

另外我们注意到示例 3：有两个斜杠连在一起的情况，此时认为这两个斜杠中间是一个空字符，空字符等价于一个点 `.` ，即什么都不做。

**算法设计**：需要先对字符串根据斜杠 `/`进行分割，得到一个字符串数组。这个字符串数组的字符串可能有以下几种：`.`、`..`、`''`、和表示目录的字母。

从左向右遍历字符串数组，如果遇到字母就直接入栈，如果遇到一个点 `.` 或者空格的时候，就什么都不做。如果遇到两个点 `..` ，就将栈顶元素从栈中弹出。

从上面的例子我们还看出，需要知道上级目录和上上级目录。因此，记录上级目录、上上级目录的变量就是一个列表对象。这就是我们之前说的 **栈和队列都是缓存数据的线性容器**，我们需要把读到的数据暂时存起来，栈和队列就是两种常见的存储数据的容器。

栈顶元素表示了已读出的目录结构中，最先需要被化简（移除）的那个目录结构。

我们看一眼题目中给出的示例 2 和示例 5：`"/a/../../b/../c//.//"`，先读到目录 `a`，然后做了两次回退操作，第 $1$ 次回退的时候，就退到了根目录，事实上已经不能再回退了，此时 `..` 这个操作无效。因此在编码的时候，需要注意：**只有在栈顶元素非空的时候，我们才能进行弹栈的操作**。

**参考代码**：

```Java []
import java.util.ArrayDeque;
import java.util.Deque;

public class Solution {

    public String simplifyPath(String path) {
        String[] dirs = path.split("/");
        if (dirs.length == 0) {
            return "/";
        }

        Deque<String> stack = new ArrayDeque<>();
        for (String dir : dirs) {
            if ("".equals(dir) || ".".equals(dir)) {
                continue;
            }

            if ("..".equals(dir)) {
                // 注意：只有栈非空的时候才能弹出，注意下面 continue; 的作用
                if (!stack.isEmpty()) {
                    stack.removeLast();
                }
                continue;
            }
            stack.addLast(dir);
        }

        StringBuilder stringBuilder = new StringBuilder();
        if (stack.isEmpty()) {
            stringBuilder.insert(0, "/");
        }

        while (!stack.isEmpty()) {
            stringBuilder.insert(0, stack.removeLast());
            stringBuilder.insert(0, "/");
        }
        return stringBuilder.toString();
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是数组的长度，最坏情况下，每个字符串进栈一次，出栈一次，表示操作的字符串还不用进栈出栈，因此时间复杂度是线性的；
+ 空间复杂度：$O(N)$ ，最坏情况下，这个路径字符串本身就是化简过的，栈中就要存字符串长度这么多的字符串（近似，不包括那些斜杠）。

**注意调试**：另外还想说明的一点是：这道题是属于典型的、思想很简单，但是可能第一遍不太容易通过测评的题目。原因是对一些特殊用例的考查不到位。这个时候其实很考验我们编码的技巧，也需要编码规范帮助我们理清思路，例如 `"".equals(dir) || ".".equals(dir)` 表达式里尽量不要出现表示否定的语句，`!stack.empty()` 是例外，因为这句话的语义不会造成理解困难。遇到这种类型的题目，一定要有耐心，输入几个特殊的测试用例，在代码中做一些变量的打印输出，这样的调试是非常有效的。

---

## 练习

1. 完成「力扣」第 20 题：有效的括号；
2. 完成「力扣」第 150 题：逆波兰表达式求值。

  > 友情提示：和计算、表达式相关的问题，一般都会使用栈来解决。

## 总结

这道问题其实没有想象中那么难，完全可以独立完成，关键是很多情况要考虑到，并且注意调试。注意：出栈之前一定要判断一下当前的栈是不是空，否则会抛出异常：`java.util.EmptyStackException`。这就是这一节的内容，感谢大家。


