# 第 8.2 节 栈：后进先出的数据结构

![image.png](https://pic.leetcode-cn.com/1598805093-zoZfWC-image.png)


「栈」是一种 **后进先出** 的数据结构，是一种人为规定的，只能在一端（**栈顶**）进行插入和删除操作，并且在栈非空的情况下，只能查看 **栈顶** 的元素的线性数据结构。


计算机中使用栈的例子：

+ 进制的转换；
+ 在计算机中表达式的计算，几乎都和栈有着密不可分的关系；
+ 只要是函数有嵌套调用，都离不开栈的支持。因为函数的嵌套调用（特殊的例子是递归）就是 **后面遇到的函数需要先执行**，这是典型的栈的应用场景；
+ 在处理 **树结构** 和 **图结构** 的一些问题中，栈发挥着非常重要的作用，这种使用栈的算法叫做 **深度优先遍历** （第 11 章会介绍）。深度优先遍历通常来说是借助递归方法实现的，背后有编程语言的 **系统栈** 的支持。

![08-02-01.gif](https://pic.leetcode-cn.com/1598804346-gFHrNt-08-02-01.gif)

可以这样形象地理解栈：栈是一个竖直摆放的容器，只能从这个容器的顶端拿出数据，为了拿到容器底部的东西，必须把在底部之上的元素全部依次拿出来。

再次和大家强调一下：使用栈作为容器，取出元素的特点是**后进先出**，如果完成一件事情符合后进先出的规律，可以考虑使用栈或者通过递归方法实现。

---

## 为什么限制了「后进先出」

有一个很自然的问题，如果不做这样的限制，不是应用范围更广吗？这里涉及一些工程上设计的思想：

+ 首先，不是功能越多越好。越多的功能很可能带来更多的性能的消耗，需要更多的性能开销；
+ 其次，有安全的问题。在生活中，我们给一个人的权限越来越多，很可能会让这个人无所适从，产生差错。一个比较好的办法就是，需要什么，就给什么，并且一个人只做好份内的事情；
+ 第三，有了这些特定的数据结构，使用的时候语义也会更加清晰，便于交流。他人也更容易知道我们大概是在解决一个什么问题，使用「栈」就说明处理数据的顺序是「后进先出」。

「栈」就是一种在设计上 **刚刚好** ，并且功能「专一」的容器。可别小看「栈」这种看起来受限制的数据结构，它在编程的世界里有着非常广泛的应用。「后进先出」在人类的世界里看起来像是失去了公平，但是我们很多时候处理的问题，恰好符合了「后进先出」的规律。

生活中后进先出的例子：

+ 吃薯片；
+ 从羽毛球筒里拿羽毛球；
+ 教师批改作业本；
+ 餐厅服务员洗盘子。

---

## 抽象数据类型

下面我们介绍一个在软件设计领域比较重要的概念：**抽象数据类型**（Abstract Data Type，ADT）。抽象数据类型是一个抽象的概念，可以将它理解为 Java 的接口，相当于一个软件说明书，定义了输入是什么、输出是什么。

抽象数据类型，关键字在「抽象」，只说能做什么，而不说如何实现；和「循环不变量」一样，通常它们都用语言描述，只要表意清晰即可，而不必在乎用什么形式表示出来。一般地，抽象数据类型会使用表格的形式给出。栈的抽象数据类型如下所示。

### 栈的抽象数据类型

| 返回值           | 方法名             | 方法描述                                                     |
| ---------------- | ------------------ | ------------------------------------------------------------ |
| 构造函数无返回值 | `Stack<Integer>()` | 创建栈，栈内元素为空                                         |
| `boolean`        | `isEmpty()`        | 返回栈是否为空                                               |
| `Integer`        | `size()`           | 返回栈中元素的数量                                           |
| `void`           | `push(int x)`      | 添加元素 `x`                                                 |
| `Integer`        | `pop()`            | 删除栈顶元素（前提：栈非空）                                 |
| `Integer`        | `peek()`           | 查看栈顶元素而不取出（前提：栈非空）<br>peek 有「偷瞄」的意思 |

---

## 栈的实现

栈是规定了只在线性结构的一侧存取的抽象数据类型。栈是抽象数据类型，我们只谈到了它能做什么，而没有说它怎么实现。事实上，栈可以使用数组实现，也可以使用链表实现。类似于 Java 里接口 `List` 和具体实现类 `ArrayList` 和 `LinkedList` 之间的关系。

说明：由于栈和队列的实现较为简单，绝大多数情况下面试的时候不会要求面试者实现。但是栈和队列的底层实现机制是需要掌握的。

### 使用数组实现栈

显然，数组不适合在头部进行删除和添加操作的，但是在数组的尾部进行增加和删除操作是非常容易的，一般的做法是设计一个 `rear` 指针变量（和动态数组那一节介绍的 `size` 的意义相同），指向下一个可以添加的元素的位置。把新添加的元素直接赋值在 `rear` 指针变量所在的位置，然后 `rear` 指针后移一位。

删除操作，其实不用真正将这个元素从数组中抹掉，只要将 `rear` 指针向前移动一位，也就是说 `rear` 指针变量的前面的所有元素才是「栈」里有效的数据的部分，之前 `rear` 所在位置的元素等待被后来的元素覆盖。

这种设计是非常容易理解和常见的，希望大家能够掌握。有兴趣的朋友，可以自己实现一个底层使用 **动态数组** 实现的栈。


### 使用链表实现栈

事实上单链表，就可以作为栈的一个经典实现。

作为链表，一个经典的实现技巧是使用带有虚拟头结点的链表。通过虚拟的头结点我们可以很方便地在链表的头部和尾部删除元素。

下面我们对栈的两种实现做一个简单的对比：


|      | 数组                                                         | 链表                                       |
| ---- | ------------------------------------------------------------ | ------------------------------------------ |
| 优点 | 访问和删除末尾元素快                                         | 动态创建结点和销毁结点，不用考虑扩容和缩容 |
| 缺点 | 需要占用连续的一块内存空间，在扩容和缩容的时候，有一定性能消耗。 | 频繁创建结点和销毁结点其实也有一定性能消耗 |

---

## Java 中的栈


在 Java 中可以看到 [`java.util.Stack`](https://docs.oracle.com/javase/10/docs/api/java/util/Stack.html) 类的官方文档推荐我们使用 `java.util.ArrayDeque` 作为实现。这是由于一些历史的原因，`Stack` 这个类没有设计好。

对于 `ArrayDeque` 这个类我们的使用建议如下：

+ 由于 `ArrayDeque` 天生不是栈的实现类，因此基于 `ArrayDeque` 是数组实现的事实，我们都建议添加和删除元素都在 `ArrayDeque` 的末尾进行；
+ 明确下列方法的语义：`push`（在开头添加） 、`pop`（在开头添加）、`peek`（在开头查看）、`add`（在末尾添加）、`poll`（在开头删除）、`offer`（在末尾添加）、`remove`（在开头删除）。

说明：我们以后的示例代码都会显式使用带 `Last` 后缀的方法，以突出「数组在末尾删除和操作时间复杂度为 $O(1)$，适合作为栈顶」这一语义。


---

## 总结

这就是这一节的内容，本节我们对栈以及栈的应用和实现做了一个简单的介绍。下一节开始我们及介绍栈的一些经典应用，以加深我们对栈的认识。