# 第 3.3 节 希尔排序（选学）

说明：这一节为选学内容，大家跳过完全不影响后续部分内容的学习。下面是希尔排序最重要的几句话总结。

我们知道插入排序在数组接近有序的时候，就能越快完成排序任务。希尔排序是插入排序的优化，基本思想是对输入数组执行多次有**间隔的**插入排序，使得数组逐渐有序。最后再执行一次标准的插入排序，即间隔为 $1$ 的插入排序。

希尔排序的执行性能与「间隔序列」有关，「间隔序列」是希尔排序的「超参数」。（「超参数」是机器学习领域的概念，这里暂时不理解没有关系，我们在「归并排序」那一章节还会向大家提及）。

希尔排序在面试范围内需要知道它是一种缩小增量的插入排序即可，可以记一下时间复杂度的结论，不必深入研究。

![image-20200717162404234](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggu1plx54bj313c0nujuw.jpg)

---

## 希尔排序的基本思想

希尔排序的发明者是 Donald Shell。希尔排序是一种基于插入排序的排序算法，也叫「缩小增量排序」（diminishing increment sort）。我们先看看插入排序的优缺点：

+ 插入排序的优点：对于几乎有序的数组（每个元素距离它排好序以后的位置都不会太远）而言，时间复杂度可以达到线性 $O(N)$；
+ 插入排序的缺点：如果一个较小的数在数组靠后的位置，那么它要来到前面要消耗很长时间。

希尔排序会将数组逐渐整理成「几乎有序」的样子（以便利用插入排序的优点），最后再执行一次「插入排序」，以完成排序任务。希尔使用的是缩小增量（或者称有间隔的）的插入排序方法，以增量为步长划分子序列，即属于同一子序列的元素，下标的步长等于增量。对每一个子序列应用插入排序，不断缩小增量，当增量为 $1$ 的时候所有的数组元素都在一个子序列中，执行一次插入排序，数组最终有序。

下面我们通过具体的例子讲解希尔排序。

---

## 希尔排序的基本思想

<!-- ![...3-03-01-希尔排序（成品）.mp4](a98158cd-db2b-4ed1-a73c-80b79f188734) -->

希尔排序每一轮将数组按照间隔分成若干子序列，再对各个子数组分别使用插入排序，直至最后执行一次间隔为 $1$ 的插入排序，整个数组就有序了。

说明：注意子数组（subarray）与子序列（subsequence）与这两个概念的区别：

+ 子数组是原始数组中的一块连续子区间，子数组的长度可以为 $1$；
+ 子序列不要求在原始序列中是连续的，但**要保证数组中的元素位置相对顺序不变**，子序列的长度可以为 $1$。

我们把上面的动画放在一张静态图中看是这样的。

![03-03-02](https://pic.leetcode-cn.com/59f32560b97be29a1e1c7979558f601416a2033f850293cf51bfa1ca971696a6-image.png)

希尔排序克服了插入排序的缺点，一个较小的数可以很快来到数组靠前的部分。间隔的选择是从大到小直至为 $1$。间隔越大，每一次执行插入排序的元素越少；反之，间隔越小，每一次执行插入排序的元素越多。在最开始的时候参与插入排序的元素个数是较少的，利用了插入排序的优点。之后的每一轮，虽然间隔减少，但是数组越来越有序，插入排序可以较快完成。

---

## 希尔排序的简单实现

希尔排序的执行时间效率和「增量序列」（increment sequence）的选择有关，一种理解上较为简单但是效率并不高的序列就是 Shell 本人建议的序列（希尔增量序列）：
$$
{\cfrac{N}{2},\cfrac{N}{4},\dots,2,1}
$$

该间隔序列是一个等比数列，间隔最大不能超过数组的长度，最小是 1。

**参考代码**：

```Java []
import java.util.Arrays;

public class Solution {

    // 「力扣」第 912 题：排序数组
    // 希尔排序，使用 Shell 建议的序列 N/2,N/4,...,2,1

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        int h = 1;

        int gap = len / 2;
        while (gap >= 1) {
            // 缩小增量的插入排序
            for (int i = h; i < len; i++) {
                insertionForDelta(nums, gap, i);
            }
            gap /= 2;
        }
        return nums;
    }

    /**
     * 将 nums[end] 插入到对应分组的正确位置上，其实就是将原来 1 的部分改成 gap
     *
     * @param nums
     * @param gap  间隔
     * @param end
     */
    private void insertionForDelta(int[] nums, int gap, int end) {
        int temp = nums[end];
        int j = end;
        while (j >= gap && nums[j - gap] > temp) {
            nums[j] = nums[j - gap];
            j -= gap;
        }
        nums[j] = temp;
    }
}
```

**复杂度分析**：

+ 时间复杂度：超出本课程范围，感兴趣的朋友可以查阅相关学术资料（本文后有参考资料）；
+ 空间复杂度：$O(1)$

---

## 间隔序列的选择

下面这个长度为 $16$ 的数组，可以依次选择间隔为 $8$、$4$、$2$、$1$ 分组完成插入排序。我们发现，间隔为 $8$、间隔为 $4$、间隔为 $2$ 时，希尔排序几乎没有做什么事，这是因为**相邻的**间隔如果有公因子，那么上一轮分在一组的数字，下一轮很可能还分在一组。

![03-03-03](https://pic.leetcode-cn.com/c2f17e2efea81880859ffda8295d562f820960aaebb26dea46dfb5be0d357bc0-image.png)



间隔序列的选择，是一个很学术的问题，有计算机科学家专门对此进行了研究。大家可以在网上搜索一下 Knuth 增量序列、Hibbard 增量序列、Sedgewick 增量序列（目前已知最好序列），我们在这里就不扩展了。

---

## 结论

+ 希尔排序的时间复杂度分析较困难，在学术界有大量的研究，在大量的实验的基础上得到结论：当 $N$ 在某个特定的范围内时，希尔排序所需的平均比较次数和平均移动次数大约在 $n^{1.25} \sim 1.6 n^{1.25}$ 范围内（Knuth 《计算机程序设计技巧（第三卷）：排序和查找》；

+ 目前已知最好的增量序列是 Sedgewick 增量序列。

---

### 学习资料

1. 维基百科[「希尔排序」](https://zh.wikipedia.org/wiki/希尔排序) 词条；
2. 《算法（第 4 版）》第 2.1.6 节 《希尔排序》章节。

---

希尔排序是历史上第 1 个时间复杂度低于 $O(N^2)$ 的算法，我们介绍它只是为了拓展「插入排序」算法，体现一个算法优化的过程。感兴趣的朋友，可以在互联网搜索关于希尔排序的研究资料。这就是这一节的内容，感谢大家。