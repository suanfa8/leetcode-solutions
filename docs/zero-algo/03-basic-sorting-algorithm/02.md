# 第 3.2 节 插入排序

这一节我们学习插入排序。

![image-20200715140200321](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggrmd83jh7j319q0twafb.jpg)

---

## 插入排序的基本思想

插入排序的基本思想是：将一个元素插入一个有序数组中，使之成为一个更长的有序数组。

<!-- ![...3-02-01-插入排序（成品）.mp4](f315139a-70aa-43d4-af90-82dff1dc49cb) -->

具体说来，我们需要从第 2 个数开始，依次把这个数插入到它之前已经排好序的部分，这样每一次都能得到比上一次更长的有序数组，直到数组整体有序。

---

## 将一个元素插入一个有序数组的两种方式

以 `[6, 5, 3, 1, 8, 7, 2, 4]` 为例进行讲解。

### 方式一：逐个交换到前面合适的位置

<!-- ![...3-02-02-插入排序（成品）.mp4](c7b11120-f976-448a-8089-8285866c8a4b) -->

第 1 种插入的方式是：`1` 应该放置在下标为 `0` 的那个位置，通过和它前面的那些元素依次交换，最终 `1` 被交换到下标为 `0` 的位置，然后前 $4$ 个数字有序。

由于每一次数组里不同元素的交换，需要进行 $3$ 次赋值操作，这个插入的过程是可以减少赋值操作的，我们看方式二。

### 方式二：先暂存当前变量，然后将前面的若干个元素逐个向后赋值

<!-- ![...3-02-03-插入排序（成品）.mp4](1607541b-e144-427b-8054-a14676a3ec21) -->

第 2 种插入的方式是：先将 `2` 赋值给一个临时的变量，然后将 `2` 之前  `2` 严格小的所有元素从后向前依次赋值，最后一定会空出 $1$ 个位置出来，这个空出来的位置就是 `2` 应该被放置的位置，我们再将它赋值回去。

这种方式比上一种方式好的地方在于，赋值的次数较少。但是真正在实现的时候，并没有第 1 种方式容易。说到这里，大家不妨暂停一下视频，看看自己能不能把这两种方式实现出来，相信会是一个非常不错的编程练习。 

---

## 插入排序的代码实现

### 第 1 版实现：逐个交换到前面合适的位置

**参考代码 1**：

```Java []
public class Solution {

    // 「力扣」第 912 题：排序数组

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组
        for (int i = 1; i < len; i++) {
            for (int j = i; j > 0; j--) {
                if (nums[j - 1] > nums[j]) {
                    swap(nums, j - 1, j);
                } else {
                    break;
                }
            }
        }
        return nums;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```

说明：插入排序每一次都将一个数插入到有序数组合适的位置，选择合适的位置还需要一个循环，因此代码还是一个双重循环的样子。

初始化的时候， 一个元素的数组肯定是有序的，即下标为 `0` 的那个数认为是排好序的。因此，外层循环从 `1` 号下标开始，一直到最后一个元素，每一次将它们依次插入位于它们前面的有序数组中；

内层循环将下标位置 `i` 所在的元素插入到在 `i` **之前**的区间 `[0, i)` 中，是的数组区间 `[0, i]` 成为有序数组；

我们采取的方式是从后向前逐个交换，直到前面的那个元素小于或者等于当前要插入的这个元素。

注意，因为已经排定的部分是有序的，遇到小于等于当前要插入的这个元素的时候，就可以停止了（**这一步很关键**）。不要忘记写 `break`，这是插入排序和选择排序不一样的地方。

由于要看前面的那个元素，因此每一次都需要判断 `j > 0` 是否成立。

**复杂度分析**：

+ 时间复杂度：$O(N^2)$，这里外层循环的变量 `i` 是与数组的长度 $N$ 相关的，内层循环的变量 `j` 是与 `i` 相关的，间接与 $N$ 相关，因此插入排序的时间复杂度是 $O(N^2)$；
说明：面试和笔试中的复杂度分析只需要像这样描述即可。
+ 空间复杂度：$O(1)$，这里不计算输入数组的空间。

#### 第 2 版实现：先暂存当前变量，然后将前面的若干个元素逐个向后赋值

**参考代码 2**：

```Java []
public class Solution {

    // 「力扣」第 912 题：排序数组

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组
        for (int i = 1; i < len; i++) {
            // 先暂存这个元素，然后之前数值严格小于 temp 的所有元素逐个后移
            int temp = nums[i];
            int j = i;
            // 注意边界 j > 0
            while (j > 0 && nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
                j--;
            }

            // 最后这一步容易忽略
            nums[j] = temp;
        }
        return nums;
    }
}
```

**复杂度分析**：（和「参考代码 1」一样）

说明：虽然我们优化了一些步骤，但是赋值 $3$ 次和赋值 $1$ 次，在计算复杂度的时候是没有差别的。

对于「插入排序」我们做以下几点说明。

---

## 插入排序的总结

「插入排序」和「选择排序」一样，也是应用了「减而治之」的思想，每一次插入的操作我们让「未排定的部分」减少 1 个元素，让「已经排序的部分」增加 $1$ 个元素，

与「选择排序」不同的是，插入排序比较的方式是从后向前将依次看到的元素与待插入的元素进行比较，这一步操作不用比较完它前面所有的元素，即：**插入排序内层循环可以提前终止，这一点是插入排序非常重要的性质**。

如果**待排序的数组是「接近有序」的数组（即数组中的元素离它最终排定以后的位置很近）和元素个数较少的数组**，插入排序就可以很快完成排序任务。选择排序就不具备这样的特点。一个非常极端的例子是：我们就对一个已经有序的数组，使用插入排序，每一轮插入排序就只要看一下前面的那个元素，发现不能再往前面移动了，马上进入下一层循环。

结论：「插入排序」最好的时间复杂度为 $O(N)$。

下面我们介绍**哨兵技巧**。

---

## 哨兵（Sentinel）

以上两版代码，在内层循环里都有 `j > 0` 这个判断条件，有一种插入排序的写法，先找到整个数组中最小的那个元素，把它交换到数组的第 $1$ 个位置（下标为 $0$），后面的逻辑就可以去掉 `j > 0`。这样的技巧有一个很形象的名字，叫「哨兵」，即放置一个元素，通常是边界位置，起到「站岗放哨」的作用，它能帮助我们：1、回避边界条件；2、减少分类讨论。

哨兵这个技巧在解决一些编程的问题上，会使得问题简化，最典型的例子是「单链表」的一些操作，这一点我们以后再向大家介绍。

面试中如果考到插入排序，写出「参考代码 1」或者「参考代码 2」都是可以的。

**参考代码 3**：

```Java []
public class Solution {

    // 「力扣」第 912 题：排序数组

    public int[] sortArray(int[] nums) {
        int len = nums.length;

        // 先选出整个数组中最小的元素，将它交换到下标为 0 的位置
        int minIndex = 0;
        for (int i = 1; i < len; i++) {
            if (nums[i] < nums[minIndex]){
                minIndex = i;
            }
        }
        swap(nums, 0, minIndex);

        // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组
        for (int i = 1; i < len; i++) {
            int temp = nums[i];
            int j = i;
            // 省去了 j > 0 这个判断
            while (nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
                j--;
            }
            nums[j] = temp;
        }
        return nums;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```

**复杂度分析**：（和「参考代码 1」一样）

---

## 课后练习

1. （必做）编写工具类，实现以下功能，比较「选择排序」、「冒泡排序」、「插入排序」的性能。


+ 生成随机数组；
+ 生成几乎有序的数组，并且调用者可以大致控制生成数组的随机程度；
  + 提示：将一个完全有序的数组，随机交换两个元素的位置，交换次数越多，有序性越差，随机性越好）；
+ 生成完全逆序的数组；
+ 设计测试排序函数是否正确的测试函数；
+ 设计测试排序函数执行时间的函数，用户比较不同排序算法的性能。

提示：一开始可以只实现功能，不必考虑过多抽象、封装的特性。我们会在这个课程的代码仓库中，给出参考代码。

2. （选做）找到插入的位置，可以使用二分查找，这样的插入排序叫作「折半插入排序」，实现「折半插入排序」。









