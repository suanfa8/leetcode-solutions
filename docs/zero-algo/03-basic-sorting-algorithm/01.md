# 第 3 章 基础排序算法

这一章我们向大家介绍「排序算法」。

![image.png](https://pic.leetcode-cn.com/1638778267-fYKDrK-image.png)



虽然现在编程语言的库函数都提供了排序的功能，但经典的排序算法里应用了非常重要的算法思想，并且面试官也喜欢问它们。「排序算法」是非常好的学习材料。

我们在这一章会学习到的经典的算法思想有：分而治之、贪心算法。还会接触到「假设修正法」、「打擂台算法」、「哨兵」、「双指针」、「循环不变量」这样的算法技巧。特别地，通过「归并排序」和「快速排序」这两个特别重要的排序方法，更进一步理解「**递归**」函数的编写与应用。

对于排序算法的学习，还有助于我们对「时间复杂度」这个概念有更进一步的理解，我们在第 1 章的时候提到过「时间复杂度」是一个动态的概念，「动态」这个词就可以通过这一章的内容加深体会。

数组在内存中是连续存储的，我们可以通过数组元素的下标，以 $O(1)$ 的时间复杂度访问到数组中的任意一个元素，数组的这个特性叫做随机访问（Random Access），这个前提是很重要的。

为了突出算法思想，我们只介绍整型数组的排序，并且，我们默认执行的排序任务是升序排序。对于对象数组的排序任务，以及降序排序的任务，可以类似地去完成。

我们这一章的任务是编写一个又一个的排序算法。在「力扣」上有这样一道问题：「力扣」第 912 题：排序数组。

---

# 第 3.1 节 选择排序

首先向大家介绍的排序算法是「选择排序」。

![image.png](https://pic.leetcode-cn.com/1638777706-pCrDvm-image.png)

## 选择排序的基本思想

<!-- ![...3-01-01-选择排序（成品）.mp4](7d5b376e-077a-42b1-9ef5-4fd633cf3c41) -->

「选择排序」的基本思想在我们的生活中很常见：按照数组元素的数值从小到大依次把它们选出来。具体来说，只要依次选择出数组中最小的元素，第 2 小的元素，以此类推，就能得到原始数组的一个升序排列。大家想一想，如果让你来实现选择排序，你会怎样编码？

---

## 选择排序的具体步骤

「选择排序」每一轮都选取「未排定的部分」的最小元素，然后将它**交换**到「未排定的部分」的第 1 个位置。下面我们通过一个具体的例子，说明选择排序的执行步骤。

例：将数组 `[8, 3, 9, 6, 4, 1, 5, 2, 10, 7]` 升序排序。

+ 首先经过一次扫描，通过逐个比较，找到整个数组中最小的元素 `1`，把它交换到这个数组的开头，交换以后，`1` 就呆在了最终应该在的位置；
+ 接下来，继续扫描未排定的部分，选出最小的元素 `2`，把它交换到未排定的部分的第 1 个位置，这个位置就是 `2` 这个元素最终应该呆的位置；
+ 接下来的操作，我们就不赘述了。直到「未排定的部分」只剩下一个元素，此时，我们就不用比较了，它一定是整个数组中最大的那个元素。到此为止，我们就得到了原始数组的升序排序结果。

### 选择排序的代码实现

**参考代码 1**：

```Java []
public class Solution {
  
    // 「力扣」第 912 题：排序数组

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 最后一轮只有一个元素，一定是最大的元素，因此写 i < len - 1
        for (int i = 0; i < len - 1; i++) {
            // 在 [i + 1, len - 1] 区间里选择最小的元素的下标
            int minIndex = i;
            for (int j = i + 1; j < len; j++) {
                if (nums[j] < nums[minIndex]) {
                    minIndex = j;
                }
            }
            swap(nums, minIndex, i);
        }
        return nums;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```

说明：选择排序的代码 Java 版本是可以通过的，Python 版本提交以后，会出现 TLE（超时）提示，我们看一下超时的数据，会发现是一个规模较大的数据，这个时候，大家不要灰心，在规模较大的数据上超时，至少说明的算法是正确的。

下面是「参考代码 1」 的说明：

+ 先将数组的长度保存下来，因为这个值后面还会用到；
+ 选择排序要经过若干次扫描，每次扫描排定一个元素。若干次扫描，得用一个循环；每一次扫描也是一次循环；因此，代码写出来是一个双层循环；
+ 最后一轮只剩下一个元素，它一定是整个数组中最大的元素，因此外层循环可以继续的条件是 `i < len - 1`，即外层循环的终止条件是 `i == len - 1` ；
+ 内层循环的作用是：选出「未排定部分」的最小元素，然后交换到未排定区域的起始位置，因此这个最小元素的**下标**很重要，这个代码的写法是一种非常经典的写法，叫做「假设修正法」：先假设「未排定部分」的 1 个元素是「未排定部分」的最小元素，如果扫描到的元素的值比当前 `minIndex` 所指向的元素还要严格小，就把 `minIndex` 的值更新为这个更小的元素的下标，这一趟扫描完以后，把 `minIndex` 所指向的元素交换到未排定部分的起始位置。这种一趟扫描选出最值的方法，有一个很形象的名字叫：**打擂台算法**；

接下来说两点编码上的规范：

+ 通常一个问题的输入如果是数组，需要将输入数组的长度存成一个变量，因为输入数组的长度在后面编码的过程中很可能会多次用到；
+ 交换数组中两个元素的方法，建议大家抽取成一个私有的方法，虽然只有 $3$ 行代码，但它的逻辑相对于选择排序而言，是一个次要逻辑，抽取成为私有方法，以突显代码的主要逻辑。

「选择排序」虽然简单，但通过我们刚才的分析，写对选择排序还是有一些注意事项的。我们给出编写了测试用例和调试代码的版本：

**参考代码 2**：

```Java []
import java.util.Arrays;

public class Solution {

    // 「力扣」第 912 题：排序数组

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 最后一轮只有一个元素，一定是最大的元素，因此写 i < len - 1
        for (int i = 0; i < len - 1; i++) {
            // 在 [i + 1, len - 1] 区间里选择最小的元素的下标
            int minIndex = i;
            for (int j = i + 1; j < len; j++) {
                if (nums[j] < nums[minIndex]) {
                    minIndex = j;
                }
            }
            swap(nums, minIndex, i);

            // 调试语句，检查排序过程是否正确
            System.out.println(Arrays.toString(nums));
        }
        return nums;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }

    public static void main(String[] args) {
        int[] nums = {8, 3, 9, 6, 4, 1, 5, 2, 10, 7};
        Solution solution = new Solution();
        int[] res = solution.sortArray(nums);
        System.out.println(Arrays.toString(res));
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N^2)$，这里 $N$ 表示数组的长度；
把每一轮循环需要进行比较的次数和交换的次数列出来，很显然每一轮循环都需要进行 $1$ 次交换。注意：即使当前「未排定部分」最小的元素恰好就在「未排定部分」的第 1 位，也执行了一次交换。
  + 第 $1$  轮：与 $N-1$ 个数比较，交换 $1$ 次；
  + 第 $2$ 轮：与 $N-2$ 个数比较，交换 $1$ 次；
  + …
  + 第 $N-1$ 轮：与 $1$ 个数比较，交换 $1$ 次。
一共比较了 $(N - 1) + (N - 2) + \dots + 1 = \cfrac{1}{2}N(N-1)$ 次，交换 $N -1$ 次。把这些操作的次数求和，得 $\cfrac{1}{2}N(N - 1) + (N - 1)$。可以不用展开计算这个表达式的值是多少，因为在计算复杂度的时候，多项式保留次数最高的那个项，并且将乘法系数认为是 $1$，因此时间复杂度是：$O(N^2)$。
+ 空间复杂度：$O(1)$，只使用到常数个临时变量，这里不计算输入数组的空间。

选择排序有这样两个特点。

---

## 选择排序的特点

### 交换的次数最少

如果一个排序任务交换的成本很高，可以考虑使用选择排序。

### 运行时间与输入无关

每一趟扫描，除了扫描的元素比上一轮少了一个以外，选择排序没有记住更多的信息。一个极端的例子是，已经是排好序的数组，选择排序还需要一次又一次地扫描。

这两点是选择排序区别于其它排序算法的特点。后续学到的算法或多或少都与输入数据的形态相关，即一个已经排好序的数组或者一个接近排好序的数组和一个随机数组，使用其它的排序算法它们所消耗的时间是有差别的。

---

## 选择排序体现的算法思想

### 贪心算法

每一轮外层循环，我们只选出「未排定部分」最小的元素，这种「局部最优，则整体最优」的思想叫做「贪心算法」，这里要说明的一点是：贪心算法和绝大多数算法一样，我们能使用这个算法，一定是和这个问题的特点和我们要完成的任务相关的。「贪心算法」这里大家有个印象就好，我们在后面的章节会专门学习这个算法。以下是「贪心算法」的两个说明：
+ 严格意义上「贪心算法」是需要证明的，通常来说比较难，且理论化。不过好在刷题这件事情上不需要证明，并且面试、笔试的过程中也弱化了对「贪心算法」问题的证明过程；
+ 这里「贪心算法」的证明要使用到「循环不变量」这个概念。我们会放在后面介绍这个非常有用的概念。

### 减而治之

「选择排序」每一轮排定一个数，这种逐渐缩小问题规模的思想是「减而治之」，我们在上一章学习「二分查找」的时候已经接触过这个思想了。

算法思想是我们学习算法的重要内容，希望大家在做题的过程中、乃至做题完成以后，能够有意识地去想一想，这个问题用到的是什么算法思想，简单做一个概括和分类，相信对于大家的算法学习是非常有帮助的，

---

## 选择排序的优化

选择排序是一个效率不高的算法，效率不高的原因是：每一次循环没有为下一次循环记录更多的信息。事实上，有一个数据结构，能够帮助我们在每次「未排定的部分」里快速地选择出当前最小的元素，这样的数据结构是「堆」，进而衍生出的「堆排序」就是「选择排序」的优化排序算法。「堆排序」将在第 9 章介绍。

---

## 练习

最后我们为大家留了 3 个练习：

1. （必做）「力扣」第 1 题：两数之和（简单）；
2. （必做）「力扣」第 11 题：盛最多水的容器（中等）；
> 这两个问题暂时只需要大家实现暴力解法就可以了，感兴趣的朋友可以在题解区和评论区看一下「标准的」解法。
3. （选做）查阅资料实现「冒泡排序」（Bubble Sort） 的基本思想，并实现「冒泡排序」提交到力扣第 912 题：排序数组。

提示：「冒泡排序」有一个优化，如果检测出数组已经排好序，就可以提前终止算法。大家学习完成以后，可以将它与选择排序做一个比较。

---

这就是这一节的内容，下一节我们学习「插入排序」，感谢大家。

