+ 「算法」和「数据结构」不是脑筋急转弯，恰好很多时候它们很死板，熟练掌握它们是一名软件工程师的基本功。有了算法和数据结构的思维，会让我们习惯地去考虑编写软件的性能问题，能收获除了刷题以外的软技能，也能让我们得到更多的机会；
+ 「算法」和「数据结构」虽然很重要，但它不是软件工程师工作的全部，也不是准备面试和笔试的全部。大家在刷题上的投入的时间和精力需要合理分配；
+ 代码的可读性非常重要，对于自己和他人查找问题十分有帮助。把代码写得简单易懂，很多时候只是态度问题，最重要的指标有：方法名、变量名表意清晰、一行代码只做一件事情。可读性强、易于维护、扩展是更重要的，不要去追求代码行数最少和破坏可读性的简洁、优雅；
+ 时间复杂度是一个 **动态** 概念，它不等价于程序的运行时间，时间复杂度表示的是程序 **随着数据规模的增加而产生的变化的快慢**。「算法」和「数据结构」这两个体系中非常重要的算法思想是「空间换时间」，对于软件编写来说，要时间的要求远高于对空间的要求。

## 第 2 章 二分查找

+ 学习二分查找，正确的做法是：根据题意，分析清楚如何利用问题的 **单调性**，设计分支条件，逐步缩小搜索区间。还有一些问题，没有明显的单调性，但是依然可以通过合理的设计分支条件，达到缩小搜索区间的目的。

+ **算法思想**：减而治之（逐渐缩小搜索区间）。

+ 常见的二分查找的写法有 `while (left <= right)`  和 `while (left < right)`  两种。它们的区别如下：
  +  `while (left <= right)` 在循环体里直接搜索目标值，把区间分成 3 个部分。退出循环以后，`right` 在左，`left` 在右，需要考虑返回 `left` 还是 `right`；
  +  `while (left < right)` 在循环体里通过排除一定不存在目标元素的区间，把区间分成 2 个部分。退出循环以后，有 `left == right` 成立，因此无需考虑返回 `left` 还是 `right`。

+ 我们详细介绍了 `while (left < right)` 写法的细节：

  + 始终思考下一轮搜索区间是什么，如果是 `[mid, right]` 就对应 `left = mid`，如果是 `[left, mid - 1]` 就对应 `right = mid - 1`，是保留 `mid` 还是 `mid + 1`、`mid - 1` 就在这样的分析中完成，所以一定不是通过记忆；
  + 从一个元素什么时候不是解开始考虑下一轮搜索区间是什么，把区间分为 2 个部分，这样的分析，会使得问题会变得简单很多，这是一条非常有用的经验；
  + 每一轮区间被划分成 2 部分，理解 区间划分决定中间数 `mid`  的取法；
    + 划分为 `[left, mid]` 与 `[mid + 1, right] `的时候，`mid` 被分到左边，对应 `int mid = left + (right - left) / 2`；

    + 划分为 `[left, mid - 1]` 与 `[mid, right]`的时候，`mid` 被分到右边，对应 `int mid = left + (right - left + 1) / 2`；

    + 至于为什么划分是这种对应关系，原因在于区间只有 2 个数的时候，如果中间数的取法不对，一旦进入的分支不能使得区间缩小，会出现 **死循环**。如果觉得很难理解，在代码中打印出关键的变量，就能发现原因；

  + 退出循环的时候有 `left == right` 成立，此时如果能确定问题一定有解，返回 left 即可，如果不能确定，需要单独判断一次。 

+ 上面的内容虽然看起来多，但是如果我们能够掌握合理的分析问题的方法，相信二分查找对于我们来说一定不是难事。

大家一定要多做练习，耐心调试，一定可以运用自如。
一定不可以套用模板做题，应该去分析问题的单调性和如何缩减搜索区间。

## 第 3 章 基础排序算法

+ 「选择排序」是最简单的排序算法，选择最小值的过程需要「打擂台」。「选择排序」的优化是「堆排序」；「选择排序」是交换次数最少的排序算法，如果一个排序任务交换成本大，应该使用「选择排序」

+ 「插入排序」是一种可以提前终止内层循环的排序方法，在数组接近有序的时候，「插入排序」的性能非常好；

+ 「希尔排序」。「希尔排序」不是面试笔试的考点，了解思想即可；

## 第 4 章 高级排序算法

### 归并排序

+ 是理解递归函数执行流程的非常好的学习材料；
+ 对待排序区间每一次都「无脑地」一分为二，递归执行排序完成以后，再做合并；
+ 采用「空间换时间」的方式，让较小的元素一下子来到了数组的前面；
+ 「归并排序」是稳定排序，因此对「对象类型」的排序任务一般使用「归并排序」；

### 快速排序

+ 「快速排序」在「分」这件事情上做足了功夫，所以没有「合」的操作；
+ 「快速排序」的核心操作是 `partition`，而写对  `partition` 需要明确我们编写的变量的「循环不变量」定义；

+ 合适的切分元素，会使得下一轮递归参与比较的元素越来越少；
+ 几类极端测试用例使得快速排序性能降低，可以做如下实验：

| 特殊测试用例       | 解决方案                         |
| ------------------ | -------------------------------- |
|                    | 随机选择切分元素（或者三向取中） |
| 有很多重复元素数组 | ，或者                           |

+ 快速排序不稳定性。

## 滑动窗口与双指针

+ 这两类问题很有典型性，都是基于 **暴力解法** 的优化。在学习这一类问题的时候，需要先思考暴力解法；
+ 掌握典型的问题的解法；
+ 画图帮助分析。

### 滑动窗口

+ 使用两个指针变量表示一个窗口（这一类问题通常讨论的对象是一个区间）；
+ 先移动右边指针找到一个可行解；
+ 然后移动左边指针找到最优解；
+ 然后交替执行第 2 步和第 3 步。

这样左右指针只需要遍历整个数组一次，就完成了目标值的计算。

### 双指针

+ 使用两个变量，一个在数组的开头，一个在数组的末尾，向中间相向而走。

---

不管是「滑动窗口」还是「双指针」，都可以基于问题的特点，，因此降低的时间复杂度。



## 链表

+ 链表的问题没有太多技巧，需要用到技巧的问题也不多。
+ 「修改结点指针的指向」的问题一定要在纸上画出具体步骤，远比在脑子里想象要来得有效、高效；
+ 「快慢指针」的问题需要留意，典型问题不多；
+ 对链表的操作如果涉及到链表的第 1 个结点，需要设置虚拟头结点以避免复杂的分类讨论；
+ 注意调试，链表的可以增加两个用于调试的方法：① 根据数组创建链表；② 根据头结点打印一个链表。







### 栈

+ 看到栈，想到开口向上的杯子，只能在一端操作；
+ 「栈」的应用十分广泛；典型应用：深度优先遍历；
+ 使用「栈」的问题需要分析出解决这个问题恰好符合「后进先出」的规律。

### 队列

+ 使用「队列」的问题需要分析出解决这个问题恰好符合「后进后出」的规律；
+ 典型应用：广度优先遍历；

## 单调栈与单调队列

+ 单调栈就是普通的栈，单调队列就是普通的队列；
+ 单调栈和单调队列的应用很有局限性，只能解决特定的问题；
+ 需要搞清楚的问题是：恰好保证了「单调栈」与「单调队列」单调的合理性；
  + 因为需要解决相应的问题，才保证了单调的特点。

---

单调栈的经典例题：

+ 第 42 题
+ 第 84 题

单调栈的经典例题：

+ 第 239 题



并查集是一种孩子结点找父亲结点而形成的树形结构，可以简单记为「找爸爸」。

只要题目中有连通性，可以考虑使用并查集完成。

并查集补充例题和讲解。

第 128 题：[题解](https://liweiwei1419.gitee.io/leetcode-algo/2017/10/24/leetcode-algo/0128-longest-consecutive-sequence/)

第 990 题：等式方程的可满足性 [视频题解](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/solution/deng-shi-fang-cheng-de-ke-man-zu-xing-by-leetcode-/)

第 952 题：按公因数计算最大组件大小 [题解](https://leetcode-cn.com/problems/largest-component-size-by-common-factor/solution/bing-cha-ji-java-python-by-liweiwei1419/)

第 945 题：使数组唯一的最小增量 [题解](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/tan-xin-suan-fa-bing-cha-ji-java-by-liweiwei1419/)



树的问题可以很复杂，基础的「二叉树」是理解高级数据结构「线段树」「并查集」「红黑树」的基础。并且**「树」的问题也是理解「递归」的很好的学习材料**。



- 「力扣」第 46 题是入门问题，需要理解「回溯算法」通过 **深度优先遍历** 的方式，得到一个问题 **所有** 的解；
- 既然是  **深度优先遍历** ，在解决问题的时候，需要先画出这个问题的树形图；
- 因此使用回溯算法解决的问题，问法基本都是这样的「输出所有的 **具体** 解」。这一类问题的解决方案通常有这样的特点：**解决一个问题需要多个步骤，每一个步骤有多种选择**；
- 「回溯」指的是对象类型的变量，在回到之前位置的时候，需要恢复成和原来一样；