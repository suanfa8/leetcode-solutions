# 第 1 节 已学知识回顾

我们已经学习完了一些知识，下面总结的部分，我们尝试将他们串联起来，帮助大家理清知识结构。让我们跳出解题的细节，做一些反思和总结。我们把每一章重点的内容归纳成思维导图，帮助大家复习和回顾相关知识点。如果有一些问题还比较陌生，大家需要回头阅读相关章节，并重新完成相关的练习，查漏补缺。希望能够帮助大家更进一步 **体会「算法」和「数据结构」的设计思想**和 **解决问题的基本思路**。

## 第 1 章 课程简介与时间复杂度

这一章节我们介绍了「时间复杂度」概念和应该如何理解「时间复杂度」，并且我们还强调了写出可读性强的代码的重要意义。

![image.png](https://pic.leetcode-cn.com/1616816865-wgwSZM-image.png)

## 第 2 章 二分查找

「二分查找」」算法是「减而治之」算法思想的体现：每一步通过有限次操作，将问题规模缩减，直至问题解决。「减治」算法也可以理解为「排除法」，每一步排除了一定不是目标元素的部分，使得下一轮考虑的问题规模减少。

「减而治之」与「分而治之」的区别：

+ 适用「减而治之」的问题，通过合理的设计分支条件，将一个大规模的问题只转化成一个规模更小的子问题；
+ 适用「分而治之」的问题，将一个大规模的问题转化成若干个（大于等于 2 个）子问题，需要等待子问题逐步求解完成很以后，再综合各个子问题的解，得到原问题的解。

![image.png](https://pic.leetcode-cn.com/1616818516-xPjSNt-image.png)

掌握「二分查找」的细节也绝非难事：一定不可以套用代码模板。应该：先仔细审题、分析题目中隐含的单调性，或者可以使得问题规模缩减的条件。遇到问题的时候，一定要有耐心，**重视「调试」「打印输出变量」「观察程序的执行流程」这些看起来很笨，但是确确实实是学习「算法」和「数据结构」的重要方法**，我们在编写代码的时候，一定要清楚每一个变量、每一行代码的含义。

## 第 3 章 基础排序算法

这一章节我们学习了「选择排序」「冒泡排序」（作为练习）「插入排序」和「希尔排序」（选学）。这些排序算法虽然应用不多，但是在数据量很少的场景下，简单的排序算法很可能是最合适的排序算法，并且理解「基础排序算法」也是理解「高级排序算法」的基础。

![image.png](https://pic.leetcode-cn.com/1616819614-TvMuaW-image.png)

这一章很重要的任务是做实验：自己编写测试用例，测试在不用数据规模，以及不同类型的待排序数组上（完全有序的数组、完全逆序的数组、接近有序的数组）不同的排序任务的执行效果和时间差异。

我们还介绍了「稳定性」「原地排序」等概念。

本章节我们还介绍了一个重要的概念：循环不变量。它并不是一个很深奥的名词，即使没有这个概念我们在编码的过程中也在无意识地做到了这一点。「循环不变量」是我们在设计算法的时候需要遵循的准则，即「初始时」「循环过程中」「终止」的时候都保持不变的性质，严格遵守「循环不变量」也是我们写正确的代码的前提。

## 第 4 章 高级排序算法

这一章节学习的「归并排序」和「快速排序」是非常重要的排序算法。它们都使用了「分而治之」的思想，把大问题逐个拆分，然后分别解决以后，基于子问题求解的结果，原问题得到了解决，使得时间复杂度降低。

「归并排序」和「快速排序」是熟悉「递归」方法的重要学习材料，要重视对它们的学习和研究。

![image.png](https://pic.leetcode-cn.com/1616824523-VuhlnK-image.png)

「快速排序」有如下知识点还需要和大家强调：

+ 特殊测试用例对「快速排序」的影响：
  + 对于有序数组（逆序数组），没有随机选择切分元素 `pivot` 的时候，递归树会严重偏斜，时间复杂度是 $O(N^2)$；
  + 有很多和切分元素 `pivot` 的值相等的时候，会造成递归树偏斜，可以
    + 使用双指针把重复元素等概率分到两边；
    + 三指针把重复元素挤到中间；

下面 3 个问题非常重要，一定要熟练掌握。

- 「力扣」第 75 题：颜色分类（基于快速排序）；
- 「力扣」第 215 题：数组第 k 大元素（基于快速排序）；

上面两题非常重要，一定要在自己理解的基础上基于「循环不变量」写对。

- 《剑指 Offer》第 51 题：逆序对的个数（基于归并排序）。

## 第 5 章 非比较排序算法

这一章的内容不是面试考点。

+ 非比较排序利用了参与比较的元素的数值，看到数值，就知道它应该放在哪个位置，所以称之为「非比较排序算法」；
+ 这三类算法，思想都是「空间换时间」，都是稳定排序，且都不是原地排序算法。

![image.png](https://pic.leetcode-cn.com/1616825730-UkTWiw-image.png)

典型问题：

+ 「力扣」第 41 题：缺失的第一个正数；
+ 「力扣」第 287 题：寻找重复数。

解决它们的思想是「原地哈希」，这一点基于待处理的数组的值在一个特定的范围内，可以认为每个桶只有一个元素。

## 第 6 章 滑动窗口与双指针

「滑动窗口」与「双指针」解决的是数组中的特定问题，它们都是基于「暴力解法」的优化，一下子排除了很多「暴力解法」需要考虑的子问题，使得时间复杂度降到线性级别。依然是思考清楚为什么可以使用「滑动窗口」或者「双指针」，是更重要的，很多时候我们需要画图帮助分析如何对「暴力解法」进行优化。

![image.png](https://pic.leetcode-cn.com/1616826599-neKTmC-image.png)

+ 使用「滑动窗口」解决的典型问题有：
  + 「力扣」第 3 题：无重复字符的最长子串
  + 「力扣」第 209 题：长度最小的子数组
  + 「力扣」第 76 题：最小覆盖子串
  + 「力扣」第 424 题：替换后的最长重复字符
  + 「力扣」第 1004 题：最大连续1的个数 III

+ 使用「双指针」解决的典型问题有：
  + 「力扣」第 11 题：盛最多水的容器
  + 「力扣」第 167 题：两数之和 II - 输入有序数组
  + 「力扣」第 42 题：接雨水

## 第 7 章 链表

链表的问题都很基础，通常题目会让我们修改结点的指向。解决这一类问题也没有特别的技巧，不要放在脑子里想，在草稿纸上根据简单的测试用例，画图想清楚操作的先后顺序即可。在面试和笔试中如果出现「链表」的问题，一定要争取完成。

![image.png](https://pic.leetcode-cn.com/1616827501-cvKApa-image.png)

**典型问题**：

+ 「力扣」第 19 题：删除链表的倒数第 N 个结点
+ 「力扣」第 141 题：环形链表
+ 「力扣」第 142 题：环形链表 II
+ 「力扣」第 160 题：相交链表
+  「力扣」第 355 题：设计推特
+ 「力扣」第 460 题：LFU 缓存
+ 「力扣」第 146 题：LRU 缓存机制
+ 「力扣」第 1206 题：设计跳表

## 第 8 章 栈与队列

我们首先介绍了动态数组，动态数组在底层是还是静态数组。动态数组需要懂实现原理，Java 里的 ArrayList ，C++ 里的 Vector 都是动态数组。动态数组看起来是动态的，但底层依旧是「静态数组」，动态数组封装了一些静态数组的操作，看起来像是动态的意义；

我们还需要了解动态数组的扩容机制。

「栈」和「队列」都是这样一种数据结构，当我们暂时不能确定结果的时候，就把数据暂存起来，当我们能够得到确定结果的时候，就把它们删除，只不过它们的应用场景恰好符合了「后进先出」或者「先进先出」。

![image.png](https://pic.leetcode-cn.com/1616827955-ZrtRWE-image.png)

**典型问题**：

普通的栈的问题：

+ 「力扣」第 20 题：有效的括号

+ 「力扣」第 32 题：最长有效括号

+ 「力扣」第 71 题：简化路径

+ 「力扣」第 150 题：逆波兰表达式求值

理解栈的应用「单调栈」的问题：

+ 「力扣」第 496 题：下一个更大元素 I
+ 「力扣」第 739 题：每日温度
+ 「力扣」第 84 题：柱状图中最大的矩形
+ 「力扣」第 42 题：接雨水

数组应用于队列实现的两个设计问题：

+ 「力扣」第 622 题：设计循环队列
+ 「力扣」第 641 题：设计循环双端队列

理解队列的应用「单调队列」的问题：

+ 「力扣」第 239 题：滑动窗口的最大值

两个高频问题：

+ 「力扣」第 232 题：用栈实现队列
+ 「力扣」第 225 题： 用队列实现栈

## 第 9 章 优先队列

优先队列用于 **动态地** 选取当前任务中优先级最高的任务。这一章节介绍的两个例题：多路归并和 TopK 问题的解法都是非常经典的、高频的问题。

![image.png](https://pic.leetcode-cn.com/1616831869-sDSvAg-image.png)

我们建议大家多手写几次「最大堆」和「最小堆」，以熟悉它们的基本操作：`sift up` 和 `sift down`。

调整「堆」的操作依然利用到了「循环不变量」：**我们在添加数据和删除数据的时候，总是尽可能地做出最少的调整，使得新添加的数据和原来的数据保持了「堆」的定义**。

**典型问题**：

+ 「力扣」第 295 题：数据流的中位数
+ 「力扣」第 23 题：合并K个升序链表
+ 「力扣」第 215 题：数组中的第K个最大元素
+ 「力扣」第 347 题：前 K 个高频元素
+ 「力扣」第 692 题：前 K 个高频单词
+ 「力扣」第 703 题：数据流中的第 K 大元素

## 第 10 章 并查集

![image.png](https://pic.leetcode-cn.com/1616832873-GDQfWj-image.png)

**典型问题**：

+ 「力扣」第 990 题：等式方程的可满足性
+ 「力扣」第 547 题：省份数量
+ 「力扣」第 959 题：由斜杠划分区域
+ 「力扣」第 1202 题：交换字符串中的元素
+ 「力扣」第 947 题：移除最多的同行或同列石头
+ 「力扣」第 765 题：情侣牵手
+ 「力扣」第 778 题：水位上升的泳池中游泳
+ 「力扣」第 399 题：除法求值
+ 「力扣」第 803 题：打砖块（困难）

## 第 11 章 二叉树

树的问题常常可以通过编写递归方法实现，事实上，递归方法的实现其实是对树执行了一次深度优先遍历。「树」的问题在「力扣」上有很多，除了我们选择的例题之外，大家还需要多多练习，以掌握递归方法的编写和解决问题的算法思想。

我们尤其要向大家提到「后序遍历」，这种一层一层向上汇报的遍历思想，应用十分广泛。

![image.png](https://pic.leetcode-cn.com/1616833273-kdRjyL-image.png)

树的问题几乎都是用「深度优先遍历」或者「广度优先遍历」的思想，在遍历的过程中记录一些信息。我们就不罗列树的典型问题了。特别邀请大家注意「后序遍历」的思想在解题过程中的应用。

「二分搜索树」结合了「链表」的动态特点，并维护了「有序」性，使得数据可以方便地存储和查找，是一类查找表的重要实现（另一类查找表是「哈希表」）。理解「二分搜索树」是理解「红黑树」的基础。

## 第 12 章 回溯算法

有一类问题，它们呈现这样的特点：解决一个问题有多种方法，每一种方法有多个步骤。**「回溯算法」用于得到所有的方法的所有步骤。「动态规划」和「贪心算法」不关心具体解，用于得到所有方法的最优解或者计数**。

回溯算法其实就是对问题抽象出来的树形结构执行一次深度优先遍历，在深度优先遍历的过程中，**对象类型变量在回到它之前遍历过的结点的时候，需要恢复**，这样就不用保存每一个阶段的所有变量，只需要在恰当的时刻保存结果。

回溯算法本质上是一次遍历，因此复杂度很高，有些教程上也叫暴力搜索。因此编码降低复杂度就很重要，有些问题可以根据问题的特点，一边遍历一边判断这一条分支搜索是否可以得到需要的解，这样的一边遍历一边判断的方式叫做 **剪枝**。「力扣」第 47 题和第 39 题、第 77 题就有典型的剪枝的应用。

![image.png](https://pic.leetcode-cn.com/1616835584-tnMxfr-image.png)

**典型问题**：

+ 「力扣」第 46 题： 全排列
+ 「力扣」第 47 题： 全排列 II
+ 「力扣」第 22 题：括号生成
+ 「力扣」第 17 题：电话号码的字母组合
+ 「力扣」第 39 题：组合总和
+ 「力扣」第 40 题：组合总和 II
+ 「力扣」第 51 题：N 皇后
+ 「力扣」第 37 题：解数独
+ 「力扣」第 60 题：排列序列
+ 「力扣」第 77 题：组合
+ 「力扣」第 79 题：单词搜索
+ 「力扣」第 78 题：子集
+ 「力扣」第 79 题：子集 II

这一章节还有一类问题，称为「Flood Fill」，其实就是在一个抽象的图形结构上执行一次「深度优先遍历」，代码比较难一次写对，也不方便调试，大家在练习的时候需要多一些耐心。

## 第 13 章 动态规划（上）

「动态规划」问题的问法具有这样的特点：**只问最优值，不问具体解**。因此我们没有必要使用「回溯算法」得到一个问题的所有具体解，然后再求最优解，这样计算复杂度较高。

![image.png](https://pic.leetcode-cn.com/1616836302-rkIUJT-image.png)

这一章节我们通过一些经典的问题，将「动态规划」的问题进行了分类。大家在做练习的时候需要把握：

+ 如何定义子问题，即如何定义「状态」；
+ 如果状态转移不满足「无后效性」，可以对状态数组进行升维，即固定住要讨论的状态，状态转移就会相对容易。

对于「无后效性」的理解非常关键，如何消除无后效性，给状态数组升维，其实就是记录了更多的状态，方便了分类讨论。

掌握「动态规划」不是短期可以见效的，需要大量的练习和思考。尤其是对经典问题的状态设计的研究。

**典型问题**：

+ 「力扣」第 53 题：最大子序和
+ 「力扣」第 5 题：最长回文子串
+ 「力扣」第 300 题：最长递增子序列
+ 「力扣」第 120 题：三角形最小路径和
+ 「力扣」第 198 题：打家劫舍  
+ 「力扣」第 124 题：二叉树中的最大路径和

## 第 14 章 动态规划（下）

这一章节我们介绍了「动态规划」的经典问题「背包问题」中的「0-1 背包问题」和「完全背包问题」。

+ 将「背包的容量」设计为状态，是「无后效性」思想的典型应用。「背包问题」的基础是「0-1 背包问题」，「完全背包问题」基于「0-1 背包问题」的讨论；
+ 需要理解「0-1 背包问题」和「完全背包问题」的「空间优化技巧」；
+ 如果需要套用「背包问题」一定需要注意题目中的条件和目标与「背包问题」是否符合。

「力扣」上的背包问题不多，因此我们给出的例题和练习是需要熟练掌握的。

## 第 15 章 贪心算法

不同于「动态规划」，「贪心算法」只需要考虑原问题的其中一个子问题，并且逐步递推求解就可以得到原问题的最优解。

「贪心算法」当然可以递归实现，但由于每一个问题都只需要转化成其中一个子问题，通常「贪心算法」都是递推实现的。

![image.png](https://pic.leetcode-cn.com/1616836887-PNBXVI-image.png)

掌握「贪心算法」依然需要一定量的练习，才能理解「贪心选择性质」在「贪心算法」上的应用。

