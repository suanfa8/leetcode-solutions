# 第 15.4 节 贪心算法问题选讲 - 3

使用「贪心算法」完成的问题，除了「零钱兑换」，还有一类非常经典的问题称为「活动选择问题」。这一类问题的场景是给出一个数组，数组里的元素表示一个一个的区间，问我们如何安排这些区间，实现某个最优化目标。

这一类问题一个常见的套路是：**按照区间的右端点升序排序**。这是因为：

+ 对区间进行排序便于我们判断区间之间是否重合；
+ **根据直觉**：每一次选择区间的时候，只看当前还未选择的最早结束的区间。由于选择了最早结束的区间，接下来遍历到的区间就有更多的机会与之前选择的区间不重合。

思考这一类问题的技巧依然是 **根据示例，可以是题目中给出的示例，也可以是自己脑海中想象的具有特殊性、代表性的示例，在草稿纸上画出示意图**。

---

## 例 1：「力扣」第 435 题：无重叠区间（中等）

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**注意:**

1. 可以认为区间的终点总是大于它的起点。
2. 区间 `[1,2]` 和 `[2,3]` 的边界相互“接触”，但没有相互重叠。

**示例 1:**

```
输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

### 方法一：动态规划

原问题可以转化为「最多保留 `N` 个区间，使得它们互不重叠」，输出 `len - N`，这里 `len` 是输入数组的长度。此时，问题就转换成为了「最长上升子序列」问题，可以使用「动态规划」的方法完成计算。

为了方便判断区间是否重叠，我们需要对输入数组按照区间的 **左端点** 升序排序。


**参考代码 1**：

```Java []
import java.util.Arrays;
import java.util.Comparator;

public class Solution {

    public int eraseOverlapIntervals(int[][] intervals) {
        int len = intervals.length;
        if (len == 0) {
            return 0;
        }

        // 按照区间左端点升序排序
        Arrays.sort(intervals, Comparator.comparingInt(interval -> interval[0]));
        
        int[] dp = new int[len];
        Arrays.fill(dp, 1);

        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i; j++) {
                if (intervals[j][1] <= intervals[i][0]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        return len - Arrays.stream(dp).max().getAsInt();
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N^2)$，其中 $N$ 是输入数组的长度，假设使用「快速排序」，时间复杂度为 $O(N \log N)$，动态规划的时间复杂度为 $O(N^2)$；

+ 空间复杂度：$O(N)$，假设使用「快速排序」，空间复杂度为 $O(\log N)$，状态数组的大小为 $N$。

其实将输入数组中的元素按照右端点升序排序也能完成题目要求的任务，并且时间复杂度更低，这其中就利用到了「贪心选择」的性质。

#### 方法二：贪心算法

**「贪心算法」的直觉**：

将区间按照右端点升序排序，每一步选择结尾最早的区间，接下来选择的时候才有可能有更多的区间与已经选择的区间没有重叠。如果选择的两个不重叠的区间结尾越靠前，后面的区间就有更多的机会容纳更多的区间，得到的不重合的区间的个数就最多。

具体来说，在选择了一个区间以后，我们需要记录 **当前选择的区间的右端点 `end`**。如果新遍历到的区间的区间的左端点在之前所选择的区间的右端点的左边，就发现了区间重合的情况。

在实际的代码编写中，我们可以将区间按照 **右端点** 排序，然后遍历它们。如果当前遍历到的区间与上一个区间不重合，即当前遍历到的区间的左边界 **大于等于** `end`（注意：根据例 3，这里可以取「等于」），那么就可以选择这个区间，并且将 `end` 更新为当前遍历到的区间的右边界。

以 `intervals = [[1, 3], [2, 4], [4, 5],[6, 7],[6, 8],[7, 9]]` 为例，我们画出示意图如下：

![image.png](https://pic.leetcode-cn.com/1616657695-cfsima-image.png)

图中的所有区间按照右端点升序排序，然后我们遍历这些区间，每一次选择结束较早的、且与之前的区间不重合的区间，**留给后面富裕的区间长度就更长**，这样才能保留更多不重合的区间。

**参考代码 2**：

```Java []
import java.util.Arrays;
import java.util.Comparator;

public class Solution {

    public int eraseOverlapIntervals(int[][] intervals) {
        int len = intervals.length;
        if (len == 0) {
            return 0;
        }

        // 按照区间右端点升序排序
        Arrays.sort(intervals, Comparator.comparingInt(interval -> interval[1]));

        int end = intervals[0][1];
        int maxLen = 1;
        for (int i = 1; i < len; ++i) {
            if (end <= intervals[i][0]) {
                maxLen++;
                end = intervals[i][1];
            }
        }
        return len - maxLen;
    }
}
```

**复杂度分析**：

- 时间复杂度：$O(N \log N)$，其中 $n$ 是区间的数量。其中 $N$ 是输入数组的长度，假设使用「快速排序」，时间复杂度为 $O(N \log N)$，遍历输入数组时间复杂度为 $O(N)$；

- 空间复杂度：$O(\log N)$，假设使用「快速排序」，空间复杂度为 $O(\log N)$。

---

## 例 2：「力扣」第 452 题：用最少数量的箭引爆气球（中等）

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 **$x_{start}$**，**$x_{end}$**，且满足 $x_{start} \le x \le x_{end}$，则该气球会被引爆。可以射出的弓箭的数量没有限制。弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 $points$ ，其中 $points [i] = [x_{start}, x_{end}]$ ，返回引爆所有气球所必须射出的最小弓箭数。

**示例 1：**

```
输入:
[[10,16], [2,8], [1,6], [7,12]]

输出:
2

解释:
对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。
```

**示例 2：**

```
输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
```

**示例 3：**

```
输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
```

**示例 4：**

```
输入：points = [[1,2]]
输出：1
```

**示例 5：**

```
输入：points = [[2,3],[2,3]]
输出：1
```

**提示：**

- $0 \le points.length \le 10^4$
- $points[i].length == 2$
- $-2^{31} \le x_{start} < x_{end} \le 2^{31} - 1$

**思路分析**：对于一些物理的问题、画面感比较强的问题，例如当前需要解决的区间问题，我们建议大家通过研究示例，在草稿纸上画出示意图，打开思路。

我们将示例 1 所示的情况在草稿纸上画出示意图，这里为了示意方便，我们将一只气球使用一个区间表示。图中红色区域是不同区间的交集，在红色区域使用一支箭会击穿较多气球。

![image.png](https://pic.leetcode-cn.com/1616658776-oAJMcB-image.png)


**「贪心算法」的直觉**：

可以发现，如果两个气球（区间）有公共的部分（根据示例 2 和示例 3，有公共部分包括区间端点重合），我们可以使用一支箭将它们击穿。因此我们希望如果这些气球表示的区间的重合部分越多，那么我们需要使用的箭的数量就越少。因此贪心的地方是：**区间重合的部分越多越好**。在计算结果的时候，如果若干个区间有交集，它们只记录 $1$。

计算若干个区间的交集，我们需要对区间进行排序。我们「按照区间的左端点升序排序」和「按照区间的右端点升序排序」这两种方式都试试。

### 方法一：按照区间的左端点升序排序

+ 此时左端点已经升序排序，为此我们需要关注的是新遍历到的区间的右端点和已经遍历到的区间的右端点的最小值（因为需要取交集）；
+ 如果新遍历到的区间的左端点 **严格大于** 之前遍历到的区间的右端点，说明此时需要新使用一支箭，否则说明两个区间有交集，此时不需要新使用一支箭。

**参考代码**：

```Java []
import java.util.Arrays;
import java.util.Comparator;

public class Solution {

    public int findMinArrowShots(int[][] points) {
        int len = points.length;
        if (len < 2) {
            return len;
        }

        Arrays.sort(points, Comparator.comparingInt(o -> o[0]));
        int res = 1;
        
        // 当前区间的结尾下标
        int end = points[0][1];
        for (int i = 1; i < len; i++) {
            if (points[i][0] > end) {
                res++;
                end = points[i][1];
            } else {
                end = Math.min(end, points[i][1]);
            }
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N \log N)$，时间复杂度主要集中在排序方法上，之后遍历数组的时间复杂度为 $O(N)$，此时 $O(N \log N + N) = O(N \log N)$；
+ 空间复杂度：$O(\log N)$，假设排序方法为快速排序，排序方法需要使用的空间大小为 $\log N$。

### 方法二：按照区间的右端点升序排序

+ 此时右端点已经升序排序，为此我们需要关注的是新遍历到的区间的左端点；
+ 如果当前新遍历到的新区间的左端点 **严格大于** 之前遍历到的区间的右端点（区间已经按照右端点升序排序），此时就需要新使用一支箭，否则说明两个区间有交集，此时不需要新使用一支箭。

**参考代码**：

```Java []
import java.util.Arrays;
import java.util.Comparator;

public class Solution {

    public int findMinArrowShots(int[][] points) {
        int len = points.length;
        if (len < 2) {
            return len;
        }

        Arrays.sort(points, Comparator.comparingInt(o -> o[1]));
        int end = points[0][1];
        int res = 1;
        for (int i = 1; i < len; i++) {
            if (points[i][0] > end) {
                end = points[i][1];
                res++;
            }
        }
        return res;
    }
}
```

**复杂度分析**：（同参考代码 1）

---

## 例 3：「力扣」第 253 题：会议室 II（中等、会员题）

给你一个会议时间安排的数组 `intervals` ，每个会议时间都会包括开始和结束的时间 `intervals[i] = [start_i, end_i]` ，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。

**示例 1：**

```
输入：intervals = [[0,30],[5,10],[15,20]]
输出：2
```

**示例 2：**

```
输入：intervals = [[7,10],[2,4]]
输出：1
```

**提示：**

- `1 <= intervals.length <= 10^4`
- `0 <= start_i < end_i <= 10^6`

**思路分析**：

+ 区间问题找到解题思路的方式依然是 **画图**，并且根据经验，我们 **总是希望之前的会议越早结束越好**，这是因为 **如果一个会议结束得越早，那么后面的会议可以开始且不同时进行的概率就会越大**；
+ 不同于之前我们之前介绍的区间当中的问题，当前问题其实要求我们回答的是 **可以同时进行的会议有多少个**；
+ 因此，我们可以按照会议的开始时间升序排序，然后我们需要关注每个会议结束的时候，即需要 **动态维护** 同时进行的会议的结尾的时间，并且我们关心会议结束的时间，最合适的数据结构是「优先队列」，需要维护的点是「结束时间最早结束越好」；
+ 当一个会议的开始时间 **大于等于** 在优先队列的队首元素的时候，说明一个会议已经结束，此时需要将它从优先队列中出队，注意：这样的过程很可能是重复多次的，请见「参考代码」中的注释。

**参考代码**：

```Java []
import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

public class Solution {

    public int minMeetingRooms(int[][] intervals) {
        int len = intervals.length;
        if (len < 2) {
            return len;
        }

        Arrays.sort(intervals, Comparator.comparingInt(o -> o[0]));
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        int res = 0;
        for (int[] interval : intervals) {
            // 这个过程很可能会弹出很多会议，因此使用 while
            while (!minHeap.isEmpty() && interval[0] >= minHeap.peek()) {
                minHeap.poll();
            }
            minHeap.add(interval[1]);
            res = Math.max(res, minHeap.size());
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N \log N)$，这里 $N$ 是输入数组的长度，时间复杂度主要集中在对输入数组排序上；
+ 空间复杂度：$O(N)$，如果使用快速排序，使用的空间大小为 $O(\log N)$，优先队列在最坏情况下使用的大小为 $N$。


---

## 总结

对「活动选择问题」感兴趣的朋友，可以阅读《算法导论》第 16.1 节《活动选择问题》，该部分介绍了严谨的数学证明。