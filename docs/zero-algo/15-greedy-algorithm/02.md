# 第 15.2 节 贪心算法问题选讲 - 1

这一节我们介绍两个使用「贪心算法」解决的问题。大家可以结合下面的要点理解「贪心算法」：

+ 每一步只做出当前看起来最好的选择；
+ 每一步只记录了和当前决策有关的变量，使用的变量个数与问题的规模无关；
+ 通过比较「动态规划」算法与「贪心算法」的异同，理解「贪心选择性质」，并且尝试证明「贪心选择性质」成立。

对于例题的描述，我们将按照以下三部分进行描述，帮助大家更好地掌握贪心算法。

1. 贪心算法的直觉；
2. 参考代码；
3. 贪心选择性质的证明。

由于我们这个教程并非严格的学术教材，为了突出想法的直观，除非有必要，不会使用大量使用数学公式和符号，目的是想让大家思考解决问题最重要的部分。严谨的数学证明，感兴趣的朋友可以自行完成或者参考「力扣」的官方题解。



「贪心算法」很多时候需要借助直觉猜想和直观描述。为了使得结果最优，只要每一步最优，就可以得到最优的结果。下面是一个生活中的例子，帮助大家理解什么叫「贪心」。

如果我们每一次测验都是全班第一名，那么经过这若干次测验以后，我们的总分也一定是全班第一名。这也是一种「贪心」的算法，证明可以采用「反证法」，假设在「贪心算法」的基础上做了一点点修改，进而证明得到的结果一定不会比「贪心算法」得到的结果更优。这样的证明通常只是在语言表达上比较书面化，但是其中所蕴含的道理是不难明白的。

---


## 例 1：「力扣」第 122 题：买卖股票的最佳时机 II（中等）

给定一个数组，它的第 `i` 个元素是一支给定股票第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1：

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

示例 2：

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```


示例 3：

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**思路分析**：

这个问题的最先容易想到的思路是 **枚举所有可能的** 买入和卖出的情况，然后在它们当中进行比较，得出最大值，就是最大利润，使用「回溯算法」或者「动态规划」都是可以的。

**「贪心算法」的直觉**：

我们先叙述解决当前问题的直觉：**由于不限制交易次数**，只要保证在低价时买入，在高价时卖出，就能得到所有的收益。即从第 2 天开始，「今天的股价 - 昨天的股价」得到的结果有 3 种可能：① 正数；② $0$ ；③ 负数。贪心算法的决策是：**只加正数**。但这里要说明的一点是：

> 只可以用贪心算法计算题目要求的最大利润，**计算的过程并不是真正交易的过程**。

下面说明贪心算法计算得到的结果的等价性。以 `[1, 2, 3, 4]` 为例，这 `4` 天的股价依次上升，按照贪心算法，得到的最大利润是：

```java
res =  (prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])
    =  prices[3] - prices[0]
```

+ 等式第 1 行：按照贪心算法：在下标为 `1`、`2`、`3` 的这 3 天，由于每一天的股价都比昨天高，我们做的操作都是「买进昨天的，卖出今天的」，大家认真思考就会发现，其实这种操作题目是不允许的；
+ 等式第 2 行：操作为：「在下标为 `0` 的那一天买入，在下标为 `3` 的那一天卖出」。

上面两种操作得到的结果是一样的，这是我们对 「**计算的过程并不是真正交易的过程**」 的解释。

因此我们根据「贪心算法的直觉」设计算法如下：从第 `i` 天（ `i >= 1`）开始，与第 `i - 1` 的股价比较。如果股价有上升（严格上升），就将升高的股价（ `prices[i] - prices[i- 1]` ）记入总利润，按照这种算法，得到的结果就是符合题意的最大利润。

**参考代码**：

```Java [] 
public class Solution {

    public int maxProfit(int[] prices) {
        int res = 0;
        int len = prices.length;
        for (int i = 0; i < len - 1; i++) {
            int diff = prices[i + 1] - prices[i];
            if (diff > 0) {
                res += diff;
            }
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 表示股价数组的长度；
+ 空间复杂度：$O(1)$。


**「贪心选择性质」的证明**：

我们容易看出：对任何局部最优解的修改都会造成全局的结果变得更差，因此可以使用「反证法」。

**反证法**：假设现在有一个新的解，只有有一步决策我们在原来「贪心算法」描述的最优解的基础上 **换成了** 加上 $0$ 或者「负数」得到的解是更优的，又由于 $0$ 或者「负数」一定小于「正数」，因此新的解一定不会比原来的最优解值更大，假设不成立。

**总结**：

当前设计的算法之所以可以称为「贪心算法」，是因为：

+ 每一阶段的决策我们只考虑了「昨天的股价」和「今天的股价」这两个因素，与昨天之前的股价（不包括昨天）都没有关系；
+ 在当前看来只要是赚钱的，我们都进行了交易，符合「每一步总是做出在当前看来最好的选择」（可以不考虑那些不盈利的选择，结果正确），并且局部最优解组成了全局最优解；
+ 我们也不用像「动态规划」算法那样记录从下标 $0$ 开始的 **每** 一天对应某种操作的时候，利润是增加还是减少。我们也不用像「回溯算法」那样，尝试枚举每一步可能的操作，并且比较 **所有** 可能的方案的结果，选出最优值。「贪心算法」在时间复杂度和空间复杂度上都是最优的。

> 友情提示：
>
> 可以应用「贪心算法」的问题，有这样的特点：如果我们只描述「贪心算法」本身，就有一种没有说清楚的感觉。所以我们一定需要说清楚「贪心选择性质」，或者证明贪心算法成立的原因。
>
> 虽然「贪心算法」在时间复杂度和空间复杂度上都达到了最优，但是它的应用条件非常强，当前问题如果没有「不限制交易次数」这个条件，贪心算法的正确性就不成立。

---

## 例 2：「力扣」第 561 题：数组拆分 I

给定长度为 `2n` 的整数数组 `nums` ，你的任务是将这些数分成 `n` 对, 例如 `(a1, b1), (a2, b2), ..., (an, bn)` ，使得从 `1` 到 `n` 的 `min(ai, bi)` 总和最大。

返回该 **最大总和** 。

**示例 1：**

```
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
```

**示例 2：**

```
输入：nums = [6,2,6,5,1,2]
输出：9
解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9
```

**提示：**

- $1 \le n \le 10^4$
- $nums.length == 2 * n$
- $-10^4 \le nums[i] \le 10^4$

**题意分析**：两两配对，每一个数对选出最小值，使得所有数对的最小值的 **和** 最大。

**「贪心算法」的直觉**：

+ 配对的两个数里，较大的数会被「消去」，所以输入数组里最大的数一定会被消去，为了得到「配对以后取最小、最小值的和最大」的结果，需要让「倒数第二大的数」和「最大的数」配对，好让「倒数第二大的数」作为一个加法项被保留；
+ 解决了上述问题以后，问题就转化为「剩下的 $2 \times n - 2$ 个数的配对问题」。可以按照上一点的描述让「倒数第三大的数」和「倒数第四大的数」配对，「倒数第三大的数」一定会被消去，而「倒数第四大的数」作为一个加法项被保留。

综上所述，题目给出的输入数组的长度为偶数，按照上面两点，可以对输入数组升序排序（降序排序也可以，我们以升序排序为例说明），然后相邻位置 「两两配对」，升序情况下，被下标为偶数（下标从 $0$ 开始）的所有元素的和加起来就是题目要求的最大值。

**参考代码**：

```Java []
import java.util.Arrays;

public class Solution {

    public int arrayPairSum(int[] nums) {
        int len = nums.length;
        Arrays.sort(nums);
        int res = 0;
        for (int i = 0; i < len; i += 2) {
            res += nums[i];
        }
        return res;
    }
}
```

**复杂度分析**：

- 时间复杂度：$O(N\log N)$，对输入数组排序的时间复杂度为 $O(N\log N)$，遍历输入数组的时间复杂度为 $O(N)$；
- 空间复杂度：$O(\log N)$，这里假设使用「快速排序」，快速排序需要使用的栈的大小为 $\log N$。

**「贪心选择性质」的证明**：

和例 1（「力扣」第 122 题）一样，在数组有序的前提下，每一步的选择我们都不可能再优化，由于对任何局部最优解的修改都会造成全局的结果变得更差，因此可以使用「反证法」。

**反证法**：假设现在有一个新的解，只有一步决策我们在原来「贪心算法」描述的最优解的基础上做了修改。不是一般性，我们使用 `[0, 1, 2, 3, 4, 5, 6, 7]` 作为例子进行说明。

![image.png](https://pic.leetcode-cn.com/1616000567-EaOrwF-image.png)

我们尝试对选中的元素 $2$ 进行交换。 

+ 它不能与有序数组中任意一个偶数交换，因为这样的交换没有意义。因此只能和奇数交换；
+ 也不能与比它小的奇数交换，假如交换 $1$ 和 $2$。
  + $2$ 被交换到 $0$ 的右边，一定不会被选中；
  + 由于数组有序，被交换过来的数在 $2$ 的左边，肯定比 $2$ 小，因此结果不会更好。如下图所示：

![image.png](https://pic.leetcode-cn.com/1616000592-CgkpaG-image.png)

+ 也不能与比它大的奇数交换，假如交换 $2$ 和 $5$。
  + 被交换过来的数一定会比 $3$ 大，因此 $3$ 被选中，$3$ 只比 $2$ 多 $1$；
  + $2$ 被交换到它的右边，由于数组有序，$2$ 一定会被选中，原来的数被替换成 $2$，但是原来的数与 $2$ 之间至少有两个数（一个奇数 $3$、一个偶数 $4$），这一部分少掉的值至少为 $2$，大于上一点描述中少掉的 $1$，因此结果也不会更好。如下图所示： 

![image.png](https://pic.leetcode-cn.com/1616000624-jYTdHR-image.png)

因此，我们证明了对「贪心算法」描述的最优解进行了任意的修改以后，都不会使得结果变得更好。

---

## 总结

+ 「贪心算法」想法的由来，取决于问题本身，而对问题描述的理解，和示例的研究，可以帮助我们进行大胆的猜测，进而不管是通过「在线系统的测试用例测评（虽然不可靠）」，还是通过自己去思考严谨的「数学证明」去完善一道题的解法；
+ 证明「贪心选择性质」可能很多时候看起来很难，因为引入了数学的公式和符号。但事实上，绝大部分 **基础的** 贪心算法问题并不需要这么做；
+ 证明一件事情，是为了让这件事情更有说服力，使用数学的公式和符号是更严谨的表达，我们可以通过阅读公式和符号，去理解作者本身想表达的意思的能力。



