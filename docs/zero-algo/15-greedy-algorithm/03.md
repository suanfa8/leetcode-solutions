# 第 15.3 节 贪心算法问题选讲 - 2

这一节的问题我们都可以出了「动态规划」和「贪心算法」的解法，用以展示它们二者之间的区别：

+ 「动态规划」需要考虑一个问题的所有子问题；
+ 「贪心算法」只需要考虑特定的子问题，逐步递推求解。

---

## 例 1：「力扣」第 135 题：分发糖果（困难）

老师想给孩子们分发糖果，有 $N$ 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

+ 每个孩子至少分配到 $1$ 个糖果。
+ 相邻的孩子中，评分高的孩子必须获得更多的糖果。

那么这样下来，老师至少需要准备多少颗糖果呢？

示例 1：

```
输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
```


示例 2：

```
输入: [1,2,2]
输出: 4
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
```

**思路分析**：根据题目中的要求「相邻的孩子中，评分高的孩子必须获得更多的糖果」可知：当前位置的小朋友需要分到的糖果数至少要比他左边的小朋友（如果有的话，得分还比他低）多 $1$ 颗，也至少要比他右边的小朋友（如果有的话，得分还比他低）多 $1$ 颗。需要同时满足这两个条件，因此当前位置的小朋友需要得到的糖果数为：

+ 规则 1：他的左边得分比他低的小朋友得到的糖果数；
+ 规则 2：他的右边得分比他低的小朋友得到的糖果数。

二者的最大值，再加一。我们可以遍历该数组两次，一次从左到右遍历数组，记录满足「规则 1」需要多少糖果，一次从右到左遍历数组，记录满足「规则 2」需要多少糖果，然后同时遍历「规则 1」和「规则 2」数组，得到最终结果。

**参考代码 1**：

```Java []
import java.util.Arrays;

public class Solution {

    public int candy(int[] ratings) {
        int len = ratings.length;

        int[] left = new int[len];
        int[] right = new int[len];

        // 注意：每个小朋友至少分到一个苹果
        Arrays.fill(left, 1);
        Arrays.fill(right, 1);

        // 第 1 步：正反各遍历一次
        // 0 号下标不考虑
        for (int i = 1; i < len; i++) {
            if (ratings[i] > ratings[i - 1]) {
                left[i] = left[i - 1] + 1;
            }
        }
        // 下标 len - 1 不考虑
        for (int i = len - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) {
                right[i] = right[i + 1] + 1;
            }
        }

        // 第 2 步：把上面的两个数组各遍历一次
        int res = 0;
        for (int i = 0; i < len; i++) {
            res += Math.max(left[i], right[i]);
        }
        return res;
    }
}
```

**复杂度分析**：

- 时间复杂度：$O(N)$，其中 $N$ 是输入数组的长度。我们遍历了两次输入数组，还同时遍历了 `left` 和 `right` 数组；
- 空间复杂度：$O(N)$，我们使用了 $2N$ 长度的数组。

这样的算法也有「贪心」的思想，体现在：如果当前位置的小朋友，如果我们给他 $4$ 颗糖果就能满足要求，绝不会给 $5$ 颗甚至更多。但是我们设计的算法「贪心」的味道又不是很强。这是因为：

+ 需要记录与问题规模相当的变量；
+ 执行了 $3$ 次 $O(N)$ 复杂度的遍历操作，我们先记录了满足「规则 1」和「规则 2」的数组，最后一次遍历的时候，才决定给每个小朋友分配多少颗糖果。

那么我们可不可以只遍历一次，就得到总的需要的最少的糖果数呢。

---

一次遍历，我们每看到一个元素的时候，就需要想是不是可以 **只根据之前看到的数据决定当前需要的糖果数**。

<![0135.001.jpeg](https://pic.leetcode-cn.com/1616059427-woetGb-0135.001.jpeg),![0135.002.jpeg](https://pic.leetcode-cn.com/1616059427-wZqBWL-0135.002.jpeg),![0135.003.jpeg](https://pic.leetcode-cn.com/1616059427-XiWSLY-0135.003.jpeg),![0135.004.jpeg](https://pic.leetcode-cn.com/1616059427-xdcLzm-0135.004.jpeg),![0135.005.jpeg](https://pic.leetcode-cn.com/1616059427-hpZOOU-0135.005.jpeg),![0135.006.jpeg](https://pic.leetcode-cn.com/1616059427-tOTzmE-0135.006.jpeg),![0135.007.jpeg](https://pic.leetcode-cn.com/1616059427-Kxlrji-0135.007.jpeg)>

我们归纳一下上面幻灯片中的算法设计思想：

+ 如果小朋友的得分处于「严格上升」的区间里：此时当前看到的小朋友的得分 **严格大于** 他（她）左边的小朋友的得分，那么给当前小朋友的糖果数就需要比他（她）左边的小朋友多 $1$ 个，且只需要多 $1$ 个；
+ 如果小朋友的得分处于「严格下降」的区间里：
  + 首先给当前小朋友 $1$ 颗糖果；
  + 然后再检查给了 $1$ 颗糖果以后，已经遍历到的在「严格下降」的区间里的小朋友得到的糖果数是不是符合题目要求，如果不符合，需要补充相应数量的糖果，补充的糖果数与「最近的严格上升里的最后一个元素的值」和「当前严格下降区间的长度」有关：
    + 如果「当前严格下降区间的长度」小于等于「最近的严格上升里的最后一个元素的值」，总的糖果数只需要加上「当前严格下降区间的长度」即可（**如果相邻位置的两个小朋友评分一样，其中一个小朋友的糖果数不需要比另一个严格多 $1$ 个**）；
    + 否则，「当前严格下降区间的长度」严格大于「最近的严格上升里的最后一个元素的值」，除了总的糖果数加上「当前严格下降区间的长度」以外，「最近的严格上升里的最后一个小朋友给的糖果数还需要加 $1$ 颗。

下面我们考虑相邻的两个元素，下面我们考虑位置相邻的两个小朋友平分一样的情况。我们依然根据具体例子画图分析，分为两种情况，相等的时候处于「上升区间」和处于「下降区间」。

![0135.008.jpeg](https://pic.leetcode-cn.com/1616059427-FJKeWB-0135.008.jpeg)


**参考代码 2**：

```Java []
public class Solution {

    public int candy(int[] ratings) {
        int len = ratings.length;
        if (len == 0) {
            return 0;
        }

        int res = 1;
        // 最近的、处于上升区间里的最后一个元素的值
        int up = 0;
        // 下降区间的元素的长度
        int down = 0;

        // 上升区间里，循环变量 i 的左边一个位置的小朋友得到的糖果数
        int prev = 0;

        for (int i = 1; i < len; i++) {
            if (ratings[i - 1] < ratings[i]) {
                up++;
                down = 0;
                prev = up;

                res += (up + 1);
            } else if (ratings[i - 1] == ratings[i]) {
                // 不管处于上升区间还是下降区间，这三个变量都重置为 0
                up = 0;
                prev = 0;
                down = 0;

                // 不管处于上升区间还是下降区间，此时都只贪心地给当前小朋友 1 颗糖果
                res += 1;
            } else {
                // 此时处于下降区间
                up = 0;
                down++;

                if (down <= prev) {
                    res += down;
                } else {
                    res += down + 1;
                }
            }
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是输入数组的长度，我们只遍历了输入数组一次；
+ 空间复杂度：$O(1)$。只使用了常数个临时变量。

---

## 例 2：「力扣」第 53 题：最大子序和（中等）

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 **示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [0]
输出：0
```

**示例 4：**

```
输入：nums = [-1]
输出：-1
```

**示例 5：**

```
输入：nums = [-100000]
输出：-100000
```

**提示：**

- $1 \le nums.length \le 3 * 10^4$
- $-105 \le nums[i] \le 10^5$

**进阶**：如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

在《动态规划（上）》章节，我们向大家讲解过这个问题，如果忘记了的朋友可以再复习一下。

**「贪心算法」的直觉**：

我们从左到右遍历数组的每一个元素，我们计算累积的和，如果累积的和是负数，就需要舍弃掉之前累积的所有元素的和，并且从下一个位置开始重新计算累积和。这是因为一个数再加上一个负数，值一定会变得更小。

**参考代码**：


```Java []
public class Solution {

    public int maxSubArray(int[] nums) {
        int sum = 0;
        // 注意：由于题目要找最大值，res 不可以初始化成 0
        int res = nums[0];
        for (int num : nums) {
            if (sum >= 0) {
                sum += num;
            } else {
                sum = num;
            }
            res = Math.max(res, sum);
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是输入数组的长度；
+ 空间复杂度：$O(1)$。

---

## 例 3：「力扣」第 376 题：摆动序列（中等）

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

**示例 1:**

```
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
```

**示例 2:**

```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```

**示例 3:**

```
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```

**进阶:**
你能否用 $O(n)$ 时间复杂度完成此题?

这个问题我们在「动态规划」章节的学习当中，把它作为了练习。

### 方法一：动态规划

「动态规划」的方法基于求解过程需要满足「无后效性」，定义状态如下：

+ `dp[i][0]` 表示：以区间 `[0..i]` 个元素中的 **某一个** 为结尾的最长的上升的「摆动序列」的长度；
+ `dp[i][1]` 表示：以区间 `[0..i]` 个元素中的 **某一个** 为结尾的最长的下降的「摆动序列」的长度。

> 友情提示：区别于「力扣」第 300 题（最长上升子序列）与「力扣」第 53 题（最大子序和），状态的定义中不要求 `nums[i]` 必需被选取。可以思考：如果要求 `nums[i]` 必需被选取，推导状态转移方程会造成什么问题？

当遍历到一个新的数时，这个数与之前被选择的「摆动子序列」的最后一个元素相比，可能的变化情况有 3 种：① 上升 ② 下降 ③ 等于。为了避免叙述冗长，「动态规划」解法的「状态转移方程」「初始化」「输出」我们写在「参考代码 1」中。

**参考代码 1**：

```Java []
public class Solution {

    public int wiggleMaxLength(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }

        int[][] dp = new int[len][2];
        dp[0][0] = 1;
        dp[0][1] = 1;
        for (int i = 1; i < len; i++) {
            if (nums[i - 1] < nums[i]) {
                // 情况 1：上升
                // 保持不变，相当于 nums[i] 不选
                dp[i][0] = dp[i - 1][0];
                // 接在原来下降的部分后面形成更长的子序列
                dp[i][1] = dp[i - 1][0] + 1;
            } else if (nums[i - 1] > nums[i]) {
                // 情况 2：下降
                // 接在原来上升的部分后面形成更长的子序列
                dp[i][0] = dp[i - 1][1] + 1;
                // 保持不变，相当于 nums[i] 不选
                dp[i][1] = dp[i - 1][1];
            } else {
                // 情况 3：nums[i - 1] == nums[i]，可以认为 nums[i] 没有出现过一样
                dp[i][0] = dp[i - 1][0];
                dp[i][1] = dp[i - 1][1];
            }
        }
        return Math.max(dp[len - 1][0], dp[len - 1][1]);
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，其中 $N$ 是输入数组的长度；
+ 空间复杂度：$O(N)$，为了记录所有的状态，我们使用的状态数组的大小为 $2N$。

事实上，我们将示例 2 在草稿纸上画出示意图。

![image.png](https://pic.leetcode-cn.com/1616000292-JpMJDG-image.png){:align=center}

发现：**只需要关注上面「折线图」中上升和下降的转折点**，把它们单独拿出来，就构成了原始输入数组的一个长度最长的「摆动序列」。

### 方法二：贪心算法

**「贪心算法」的直觉**：

只关注「拐点」。这是因为我假设当前遍历到的元素在一个上升的区间当中，如果这个值越大，那么它的下一个元素数值的变化减少的概率你越大，如果「下一个元素数值的变化减少」真的发生了，摆动序列的长度就增加了 $1$。

![image.png](https://pic.leetcode-cn.com/1616000310-XLXKTD-image.png){:align=center}


在编写代码的过程中，需要注意「等于」的情况，我们将其它的细节放在「参考代码 2」中。

**参考代码 2**：

```Java []
public class Solution {

    public int wiggleMaxLength(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }

        int prev = 0;
        int curr;

        int res = 1;
        for (int i = 1; i < len; i++) {
            curr = nums[i] - nums[i - 1];
            if ((curr > 0 && prev <= 0) || (curr < 0 && prev >= 0)) {
                res++;
                prev = curr;
            }
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(n)$，其中 $n$ 是序列的长度，我们只需要遍历该序列一次；
+ 空间复杂度：$O(1)$。我们只需要常数空间来存放若干变量。

**本题总结**：

+ 动态规划问题须要考虑 **所有的** 情况，并使用状态表格记录求解过程中需要计算的所有状态；
+ 贪心算法每一步决策的时候只关注当前阶段相关变量的值，不同于动态规划，历史的变量的值不需要保存。

---

## 总结

「贪心算法」的解决思路通常来自直觉，为了得到直观的思路，我们通常需要根据问题场景，在草稿纸上画出示意图，或者根据题目中的示例进行充分的讨论和研究，通常示例就会对解决问题的思路给出一些启发。

