# 15-1 贪心算法和动态规划的关系

![image.png](https://pic.leetcode-cn.com/1616652755-koENHr-image.png)


## 贪心算法概述

「贪心算法」是对完成一件事情的方法的描述。之所以称为「算法」，前提是：它必须是「正确的」。「贪心算法」即：用目光短浅的方法也可以完成任务的正确的方法。

理解「贪心算法」需要与「动态规划」进行对比，「动态规划」每个阶段需要解决所有的子问题，而 **「贪心算法」的每个阶段只需要解决其中一个子问题** 。

「贪心」这个词可以理解成为生活中的贪心，表示了对一件利益相关的事情的期待：如果买东西，我们希望花的钱越少越好；如果卖东西，我们希望卖出的钱越多越好。生活中的「贪心」往往是一种贬义的评价，而在算法的世界里，我们说完成一件事情可以用贪心算法，首先肯定了「贪心算法」是正确的（其实「贪心算法」是一种比「动态规划」算法更高效的算法），再者往往我们会问自己一个问题：「贪心算法」为什么是正确的，即「证明贪心算法的有效性（合理性）」。

要说明一个问题不能应用「贪心算法」，只需要举出一个反例，但要证明「贪心算法」的正确性并不容易。

---

## 贪心算法和动态规划的关系

「贪心算法」和「动态规划」都适用于：完成一件事情分成多个步骤，每一个步骤有多种选择。

「贪心算法」的思路是：在每一步只要选择「最极端」的做法就可以达到全局最优。可以使用「贪心算法」与我们面对的问题高度相关，可以应用「贪心算法」的前提是：

+ 问题具有「最优子结构」：较小规模问题的最优解组成了较大规模问题的最优解，这一点与「动态规划」相同；
+ 问题具有「贪心选择性质」：从子问题的局部最优解可以通过 **递推** 得到全局最优解。

「动态规划」与「贪心算法」的区别是：

+ 动态规划在每一个阶段考虑了 **所有** 可能的选择；

<![DP-Bottom2Up.001.jpeg](https://pic.leetcode-cn.com/1616382731-qwbRYw-DP-Bottom2Up.001.jpeg),![DP-Bottom2Up.002.jpeg](https://pic.leetcode-cn.com/1616382731-Ikwkpe-DP-Bottom2Up.002.jpeg),![DP-Bottom2Up.003.jpeg](https://pic.leetcode-cn.com/1616382731-EGkcha-DP-Bottom2Up.003.jpeg),![DP-Bottom2Up.004.jpeg](https://pic.leetcode-cn.com/1616382731-tMtNiY-DP-Bottom2Up.004.jpeg),![DP-Bottom2Up.005.jpeg](https://pic.leetcode-cn.com/1616382731-oAYEKk-DP-Bottom2Up.005.jpeg),![DP-Bottom2Up.006.jpeg](https://pic.leetcode-cn.com/1616382731-xxGYbE-DP-Bottom2Up.006.jpeg),![DP-Bottom2Up.007.jpeg](https://pic.leetcode-cn.com/1616382731-kwawro-DP-Bottom2Up.007.jpeg),![DP-Bottom2Up.008.jpeg](https://pic.leetcode-cn.com/1616382731-QyVRee-DP-Bottom2Up.008.jpeg),![DP-Bottom2Up.009.jpeg](https://pic.leetcode-cn.com/1616382731-QhanVE-DP-Bottom2Up.009.jpeg),![DP-Bottom2Up.010.jpeg](https://pic.leetcode-cn.com/1616382731-WENICE-DP-Bottom2Up.010.jpeg),![DP-Bottom2Up.011.jpeg](https://pic.leetcode-cn.com/1616382731-gzkvll-DP-Bottom2Up.011.jpeg),![DP-Bottom2Up.012.jpeg](https://pic.leetcode-cn.com/1616382731-DjSHMP-DP-Bottom2Up.012.jpeg),![DP-Bottom2Up.013.jpeg](https://pic.leetcode-cn.com/1616382731-WHCiFL-DP-Bottom2Up.013.jpeg),![DP-Bottom2Up.014.jpeg](https://pic.leetcode-cn.com/1616382731-UrMWrb-DP-Bottom2Up.014.jpeg),![DP-Bottom2Up.015.jpeg](https://pic.leetcode-cn.com/1616382731-TxWLle-DP-Bottom2Up.015.jpeg)>

可以看出：**「自底向上」求解「动态规划」问题实际上完成了一次「树」的「后序遍历」**，这样的过程表现为：除了最基本的问题以外，求解过程中遇到的所有问题之前都计算过。

+ 贪心算法在每一个阶段只需要考虑其中一个选择，可以忽略一些不必要的选择的计算。

<![greedy.001.jpeg](https://pic.leetcode-cn.com/1616382564-nludQh-greedy.001.jpeg),![greedy.002.jpeg](https://pic.leetcode-cn.com/1616382564-EiIDEN-greedy.002.jpeg),![greedy.003.jpeg](https://pic.leetcode-cn.com/1616382564-IzsIuO-greedy.003.jpeg),![greedy.004.jpeg](https://pic.leetcode-cn.com/1616382564-DFcDhV-greedy.004.jpeg),![greedy.005.jpeg](https://pic.leetcode-cn.com/1616382564-qkOPyb-greedy.005.jpeg)>

之所以可以只考虑一个选择方案，和当前我们面对的问题高度相关，即问题必需具有「贪心选择性质」。下面我们通过具体的例子讲解「贪心选择性质」。

---

## 通过具体例子理解「动态规划」与「贪心算法」的区别

例：「力扣」第 322 题：零钱兑换。

给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**示例 4：**

```
输入：coins = [1], amount = 1
输出：1
```

**示例 5：**

```
输入：coins = [1], amount = 2
输出：2
```

**提示：**

- $1 <= coins.length <= 12$
- $1 <= coins[i] <= 2^{31 - 1}$
- $0 <= amount <= 10^4$

**分析**：在《动态规划（上）》的章节里，我们向大家介绍过这个问题「动态规划」的解法。

**联系生活中的场景**：我们要将钱找给他人的时候，我们总是 **想办法让找给别人的钱数尽可能的少**。具体的方案是：先尽量给出较大面额的钞票，然后尽量给出次大面额的钞票，以此类推，直到刚好凑出要找给别人的钱的总数。可以这样做的一个隐含条件是：**生活中可以选用的纸币的面值只有 100 元、50 元、20 元、10 元、5 元、2 元、1 元、5 角、2 角、1 角**，这些纸币的面值决定了找零钱这件事情具有「贪心选择性质」。

下面我们编写代码验证这件事情。下面列出了「动态规划」的代码和「贪心算法」的代码，并对它们计算的结果进行比较。

**参考代码**：

```Java []
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
import java.util.stream.IntStream;

public class Solution {

    public static final Random random = new Random();

    /**
     * 参数：执行测试的次数
     */
    public static final int TIMES = 1000;

    public int changeForDP(int[] coins, int amount) {
        // 优化空间的动态规划代码
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (i - coin >= 0 && dp[i - coin] != amount + 1) {
                    dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
                }
            }
        }

        if (dp[amount] == amount + 1) {
            dp[amount] = -1;
        }
        return dp[amount];
    }

    /**
     * 注意：该算法仅在 coins = [1, 2, 5, 10, 20, 100] 等具有贪心选择性质的面值列表下有效
     *
     * @param coins
     * @param amount
     * @return
     */
    public int changeForGreedy(int[] coins, int amount) {
        // 将 coins 倒序排列
        coins = IntStream.of(coins).boxed().sorted(Comparator.reverseOrder()).mapToInt(Integer::intValue).toArray();
        int res = 0;
        int index = 0;
        // 贪心的点：尽可能多地优先选择面值大的纸币
        while (amount > 0) {
            // 这一步算出当前面值的纸币需要使用多少张
            int count = amount / coins[index];
            // 纸币数加入总数
            res += count;
            // 扣除了当前使用掉的纸币以后还剩下多少金额
            amount %= coins[index];
            // 考虑下一种面额的纸币
            index++;
        }
        return res;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] coins = new int[]{1, 2, 5, 10, 20, 50, 100};

        for (int i = 0; i < TIMES; i++) {
            int amount = random.nextInt(5000);
            int resOfDp = solution.changeForDP(coins, amount);
            // System.out.println("动态规划 => " + resOfDp);
            int resOfGreedy = solution.changeForGreedy(coins, amount);
            // System.out.println("贪心算法 => " + resOfGreedy);
            if (resOfDp != resOfGreedy) {
                throw new RuntimeException("测试不通过！");
            }
        }
        System.out.println("测试通过！");
    }
}
```

不论代码执行多少次，贪心算法和动态规划的结果都一样，但是贪心算法复杂度更低。

### 「力扣」第 322 题：零钱兑换「贪心算法」的正确性解释

下面我们给出「贪心选择性质」成立的解释，为了突出直观，我们不使用严谨的数学证明。

由于候选纸币（硬币）的面值为 `[1, 2, 5, 10, 20, 50, 100]`，这样的数列有如下性质：

+ 首先，一定有 $1$，这样可以保证对任意一种金额都存在找零钱方案；
+ 其次，较大面值的纸币（硬币），一定可以等价地替换成为比它面值更小的纸币（硬币）的组合；
+ 更重要的是：较大面值的纸币（硬币）的面值一定 **大于等于** 它 $2$ 倍比它面值 **小一点** 的纸币（硬币）的面值，例如：$100 = 2 \times 50$、$50 = 2 \times 20 + 10$、$20 = 2 \times 10$、$10 = 2 \times 5$、$5 = 2 \times 2 + 1$、$2 = 2 \times 1$。

以上的 3 点性质决定了，如果我们可以使用较小的金额的纸币（硬币）的组合替换一张较大的纸币（硬币），我们一定要这样做，才会让最后兑换的纸币（硬币）数量最少。

从当前这个例子，我们还可以得出一个结论：**贪心算法不需要记录以前的阶段的结果，只需要记录和当前的阶段有关的变量**，也就是说 **贪心算法所需要的空间也不和问题的规模相关**。

---

## 贪心选择性质

「贪心算法」并不是针对所有的问题都适用。适用「贪心算法」的前提是问题满足 **贪心选择性质**。所谓「贪心选择性质」，即：**从局部最优解可以推导出全局最优解（每一步都选择一个局部最优解，可以得到全局最优解）**。

---

## 要说明不能使用贪心算法，只需要举出一个反例

可以使用「贪心算法」需要严格的数学证明，但是不可以使用「贪心算法」只需要举出一个反例，这里我们介绍两个反例。

**反例 1**：我们在「第 14.1 节 0-1 背包问题」里介绍过「不可以优先选择价值较大的物品装进背包」，这种思路不能得到最优解。

**反例 2**：「力扣」第 279 题：完全平方数

给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。

给你一个整数 `n` ，返回和为 `n` 的完全平方数的 **最少数量** 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

**提示：**

- $1 \le n \le 10^4$

**分析**：

+ 看例 1，$n = 12$。如果使用贪心算法，$12$ 不是完全平方数，严格小于 $12$ 的最大的完全平方数是 $9$，$12 - 9 = 3$。而 $3$ 不是完全平方数，严格小于 $3$ 的完全平方数只有 $1$，$3 = 1 + 1 + 1$。因此 $12 = 9 + 1 + 1 + 1$ 比示例 1 给出的 $12 = 4 + 4 + 4$ 用的完全平方数多。说明 **不可以通过「贪心选择」，忽略「动态规划」需要考虑的子问题，因此贪心选择性质不成立**。

---

## 「贪心算法」的思考路径

可以使用贪心算法的问题需要 **先根据直觉进行猜测**，然后尝试举出反例。如果能够举出一个反例，就可以说明「贪心算法」在当前问题上并不适用。

如果不能够举出反例，分以下两种情况：

**情况 1**：就尝试写一个「贪心算法」，能够通过 **所有** 测试用例，说明「贪心算法」可能是有效的。

在线测评系统的每一道问题，即使有很多测试用例，也是有限的，很有可能存在一条测试用例恰好是不能够使用「贪心算法」的反例。「能够通过 **所有** 测试用例」的结果仅供参考，但可以肯定的是，不能够通过测评的测试用例，一定是不可以使用「贪心算法」的反例。

**情况 2**：尝试证明贪心选择性质成立。

可以根据个人情况掌握「贪心算法」的证明。由于「贪心算法」的证明一般比较难，在机试的时候是不要求的（没有相关的测评机制判断正确与否），但是面试的时候面试官很可能会要求候选人简单介绍思路，因此要求我们对于给出的贪心算法，要能掌握常见的证明的思路（反证法、数学归纳法），这需要我们积累一定的经验。

---

## 总结


+ 「贪心算法」首先需要保证正确性，只有结论正确才可以称之为「算法」；
+ 「贪心算法」与动态规划的相同之处：① 完成一件事情分成多个步骤，完成一件事情分成多个步骤，在每一个步骤有多种选择； ②都有「最优子结构」； ③ 都具有「无后效性」；
+ 「贪心算法」与「动态规划」的不同之处：由于「贪心选择性质」成立，「动态规划」在每一个步骤有多种选择中选出一种只考虑当前步骤下最「好」的结果，而不考虑其它方案，降低了时间复杂度和空间复杂度；
+ 「贪心算法」一般根据问题先猜测，然后尝试举反例。举不出反例的时候，如果有足够的测试用例，并且测试用例可靠，可以使用测试用例测试贪心算法的有效性，但是更严格的证明还应该使用数学的形式化证明。如果只是针对应试准备算法的内容和平时的学习，可以不用掌握非常严格的数学证明；
+ 「贪心算法」由于每一阶段要选出最优，一般而言对数据需要先排序；
+ 一些使用「贪心算法」解决的问题，往往可以借助画图，获得直观上的灵感，进而大胆猜想、尝试举出反例、进而验证。

---

「贪心算法」的内容就这么多，还是和「回溯算法」「动态规划」一样，「算法」这一块的知识需要大量的练习和思考，才能够对设计算法的思想有足够清晰的认识，接下来我们就通过一些具体的问题，向大家讲解应该如何学习「贪心算法」和理解「贪心算法」的思想。


