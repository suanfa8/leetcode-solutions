# 第 5.4 节 排序算法总结

![image-20200722153422804](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggzsdfk7srj31gy0pgwlc.jpg)

这一节的内容主要是帮助大家回顾排序算法。堆排序我们没有介绍，因为我们还没有介绍「堆」，借助「堆」能够在下一轮以 $O(1)$ 的时间复杂度选出最小元素，而每一步维护「堆」的时间复杂度是 $O(\log N)$。冒泡排序虽然我们也没有介绍，不过我们已经将它作为练习出现在「选择排序」那一章节里，因此不妨碍我们总结它。

十大排序算法里，前七个可以归为一类，它们都是基于比较的排序算法：要排定一个数，一定得看过其它的数以后，才能排定这个数。

而剩下的「计数排序」、「基数排序」、「桶排序」都体现了「桶」的思想。可以认为桶是有序的码放的，我们看到一个数的时候，根据这个数本身的大小，就能知道它应该位于什么位置，它们的时间复杂度虽然相较于前七个要低，但这三个排序算法的使用有局限性：

+ 桶排序在数据均匀分布，且范围不能太大的情况下表现良好；
+ 计数排序在要求排序关键字少，重复元素多的时候表现良好；
+ 基数排序相比较于计数排序而言，减少了桶的个数。

> 友情提示：时间复杂度低，并不意味着执行时间较少，时间复杂度只是一个估算，时间复杂度也不是排序算法的唯一指标。

在基于比较的排序方法里，选择排序、冒泡排序、插入排序都是线性的算法，都得通过一个一个比较完成，因此需要两层循环，它们的时间复杂度为 $O(N^2)$，空间复杂度为 $O(1)$。而归并排序借助了额外的空间和递归调用栈使得靠后的较小元素一下子来到了数组靠前的位置；快速排序借助 partition 过程和递归调用栈使得每一次 partition 需要比较的元素个数越来越小。「归并排序」和「快速排序」使用「分治思想」通过「递归」实现，使得平均复杂度可以达到 $O(N \log N)$，这其中也体现了「空间换时间」的思想。

---

## 排序算法对数据的理解能力

选择排序是一个不太灵活的排序方法，每一轮看完不能为下一轮提供有用的信息，而插入排序、冒泡排序可以提前检测到数组是否有序，以加快排序速度。选择排序并非一无是处，它的优点是交换的次数最少，如果交换的成本比较大，适合使用选择排序。

插入排序在数组越有序的时候排序越快，这里有序指的是升序，如果数组是接近降序的话，插入排序会很慢。而快速排序在数组越有序的时候排序越慢，因为越有序不管是升序还是降序，递归树的深度都增加，我们可以采用随机化切分元素的办法使得最差时间复杂度出现的概率大大降低。

快速排序还特别适用于有大量重复值的元素的排序。

堆排序是选择排序的优化，希尔排序是插入排序的优化。归并排序和快速排序都有各自的优化技巧，当处理的元素个数较少的时候，可以在归并排序和快速排序的子过程里使用插入排序。

---

## 额外空间复杂度

基于比较的排序算法，除了归并排序和快速排序，它们都仅仅只是借助了交换时候需要的 $1$ 个辅助空间，因此空间复杂度是 $O(1)$。

归并排序在归并的时候，需要借助和原始数组同等大小的空间。并且归并排序和快速排序都用到了「栈」作为辅助的数据结构。

---

## 原地排序

基于比较的排序算法，除了归并排序，都是原地排序。但是原地排序不等于空间复杂度为 $O(1)$，特殊的例子是快速排序，它需要的空间是递归栈，用户保存递归的过程中的临时信息。

桶排序、计数排序、基数排序基于桶的思想，都是非原地排序。

---

## 排序算法的稳定性

如果实现上一不小心，有可能会把本来可以实现成稳定排序的算法给实现成不稳定的。在插入排序和归并排序的介绍中，我们都强调过这个细节。

基于比较的排序算法，只要是线性的，一个一个比较过去的，都是稳定的排序算法，我们回想一下插入排序、冒泡。而归并借助了辅助空间以后，仍然可以做到稳定。

而选择排序、堆排序、希尔排序、快速排序元素的交换具有跳跃性，显然不是稳定排序。快速排序因为不具有稳定性，因此对象类型的排序算法一般使用归并排序或者是归并排序的变种。

三个基于桶思想的排序算法都是稳定的排序算法，要特别注意这些算法是如何保证稳定性。

另外，只要指定好比较规则，即使是非稳定的排序算法也可以把它变成稳定的排序算法，这一过程叫做稳定化。

### 总结

排序章节的内容我们都介绍完了，这一部分的内容有点多，希望大家能够多家体会多种排序算法的基本思想，尤其是递归方法的编写和细节。更多排序算法的细节可以通过系统库的源代码进行学习。本章只介绍了在内存中的排序算法，也叫做内排序，外排序的知识需要大家查阅相关资料进行学习。下一章，我们学习数组中常见两类问题：「滑动窗口」和「双指针」，感谢大家。


