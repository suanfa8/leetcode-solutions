# 第 5 章 非比较排序算法

![image.png](https://pic.leetcode-cn.com/8bf17d84acfe03305f1e6ce5de0041e04940bac7abe06fb3e2abe653dd0a91b8-image.png)

第 3 章、第 4 章学习的排序方法，它们都是基于比较的排序方法。我们在这一章节将要学习的「计数排序」、「基数排序」和「桶排序」都是非比较的排序方法。「非比较」是指：一个元素在排好序以后的位置，是由它自己的值决定的。「非比较」排序中蕴含了「哈希表」的思想。

需要说明的是，这 3 种排序方法，在一般的面试中考察的比重较低，暂时跳过，或者不研究这些排序方法的具体细节是没有问题的，可能会考察的是非比较排序的算法思想、典型例题，能描述并且知道应用场景即可。

> 友情提示：「排序」这 3 个章节的学习，重点需要放在「归并排序」和「快速排序」中，还有将来要学习的「堆排序」。

---

# 第 5.1 节 计数排序


![image-20200722142618643](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggzqep96khj316m0mwad8.jpg)

---

## 计数排序的基本思想

计数排序的基本思想是：将元素的值，看成计数数组的下标。

计数排序顾名思义：通过统计每个元素出现的次数完成排序任务。还记得我们之前做过的荷兰国旗问题（「力扣」第 75 题：颜色分类）吗？分别数出 $0$、$1$、$2$ 的个数，再依次赋值回去，就完成了排序，这种做法就是计数排序。我们把相同的 $0$、$1$、$2$ 不加区别地对待，放置在一起，然后再拿出来。如果是对象数组（多关键字），这样做就会丢失稳定性。如果排序任务对稳定性没有要求，这种做法是完全可以的。计数排序的非稳定实现非常简单，我们留给大家完成。

这一节要介绍的「稳定的」计数排序，这种稳定性，我们在下一节介绍的基数排序就会用到。


---

## 计数排序的适用场景

为了使得我们介绍计数排序的思想更加直观，我们在这里对参与排序任务的数据范围做一些假设，而这些假设恰恰好就是计数排序能够发挥作用的地方。

+ 假设输入数组是整型数组；
+ 假设输入数组中的元素的值都是非负整数，即在 $[0, 10000]$ ，这里 $10000$ 是我们为了便于说明问题设计的，没有特别含义，这个值越小越好（当然不能严格小于 $0$）。

---

## 计数排序的稳定实现

为了维护计数排序的稳定性，除了计数之外，我们还需要做一点工作。以数组：`[2, 5, 3, 0, 2, 3, 0, 3]` 为例。

第 1 步：得到计数数组，计数数组的元素个数等于原始数组的最大元素 $+ 1$：


| 计数 | 2    | 0    | 2    | 3    | 0    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    |

请注意：这里我们就利用了计数排序的基本思想，把数值看成计数数组的下标。

我们看到 $3$ 出现了 $3$ 次。很显然这 $3$ 个 $3$ 一定排在前面 $2$ 个 $0$ 和 $2$ 个 $2$ 的后面，因此我们可以再进一步，计算出前缀和数组。

第 2 步：将计数数组改造成「前缀和」计数数组：

| 前缀和计数 | 2    | 2    | 4    | 7    | 7    | 8    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标）       | 0    | 1    | 2    | 3    | 4    | 5    |

「前缀和」计数数组的意义如下为：排好序以后，最后一个 `0` 位于数组的第 $2$ 个位置（下标为 $1$），最后一个 `2` 位于数组的第 $4$ 个位置（下标为 $3$），以此类推。通过「前缀和」计数数组，我们可以很清楚地知道最后一个元素在排好序以后应该位于什么位置，因此我们可以**从后向前**一次遍历原始数组，把值赋值回去，这样就能保证排序以后数组的稳定性。

这样说不是很清晰，接下来我们来看这一步具体是如何操作的。

第 3 步：从后向前赋值回原始数组。

最后一个元素是 $3$，看「前缀和」计数数组，我们知道 $3$ 一定位数原始数组的第 $7$ 位，即下标是 $6$ 的位置。因此在下标 $6$ 位置上先写上 $3$。同时，「前缀和」计数数组 $3$ 所对应的数值减 $1$，表示下一个 $3$ 位于排好序以后的第 $6$ 个位置，即下标为 $5$ 的位置。

|      |      |      |      |      |      |      | 3    |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |

此时「前缀和」计数数组：

| 前缀和计数 | 2    | 2    | 4    | 6    | 7    | 8    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标）       | 0    | 1    | 2    | 3    | 4    | 5    |

倒数第 $2$ 个元素是 $0$，看「前缀和」计数数组，我们知道 $0$ 一定位数原始数组的第 $2$ 位，即下标是 $1$ 的位置。因此在下标 $1$ 的位置上写上 $0$。同时，「前缀和」计数数组 $0$ 所对应的数值减 $1$，表示下一个 $0$ 位于排好序以后的第 $1$ 个位置，即下标为 $0$ 的位置。

|      |      | 0    |      |      |      |      | 3    |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |

此时「前缀和」计数数组：

| 前缀和计数 | 1    | 2    | 4    | 6    | 7    | 8    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标）       | 0    | 1    | 2    | 3    | 4    | 5    |

倒数第 $3$ 个元素是 $3$，看「前缀和」计数数组，我们知道 $3$ 一定位数原始数组的第 $6$ 位，即下标是 $5$ 的位置。因此我们在下标的 $5$ 位置上写上 $3$。同时，「前缀和」计数数组 $3$ 所对应的数值减 $1$，表示下一个 $3$ 位于排好序以后的第 $5$ 个位置，即下标为 $4$ 的位置。

|      |      | 0    |      |      |      | 3    | 3    |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |

此时「前缀和」计数数组：

| 前缀和计数 | 1    | 2    | 4    | 5    | 7    | 8    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标）       | 0    | 1    | 2    | 3    | 4    | 5    |

下面的步骤相信大家也都会了，我们就不赘述了。

看到 $2$：

|      |      | 0    |      | 2    |      | 3    | 3    |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |

此时「前缀和」计数数组：

| 前缀和计数 | 1    | 2    | 3    | 5    | 7    | 8    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值       | 0    | 1    | 2    | 3    | 4    | 5    |

看到 $0$：

|      | 0    | 0    |      | 2    |      | 3    | 3    |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |

此时「前缀和」计数数组：

| 前缀和计数 | 0    | 2    | 3    | 5    | 7    | 8    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    |

看到 $3$：

|      | 0    | 0    |      | 2    | 3    | 3    | 3    |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |

此时「前缀和」计数数组：

| 前缀和计数 | 0    | 2    | 3    | 4    | 7    | 8    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标）       | 0    | 1    | 2    | 3    | 4    | 5    |

看到 $5$：

|      | 0    | 0    |      | 2    | 3    | 3    | 3    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |

此时前缀和计数数组：

| 前缀和计数 | 0    | 2    | 3    | 4    | 7    | 7    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标）       | 0    | 1    | 2    | 3    | 4    | 5    |

看到 $2$：

|      | 0    | 0    | 2    | 2    | 3    | 3    | 3    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标） | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |

此时「前缀和」计数数组：

| 前缀和计数 | 0    | 2    | 2    | 4    | 7    | 7    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数值（数组下标）       | 0    | 1    | 2    | 3    | 4    | 5    |

我们再回顾一下计数排序的基本思想：对于每一个输入数组的元素，计算严格小于它的元素的个数（前缀和计数数组），进而把它放到输出数组对应的位置上。倒序赋值回去保证了稳定性。希望大家能够想清楚这里使用前缀和计数数组，并且倒序赋值回去的有效性。

如果理解了上面计数排序的算法流程，再看计数排序的适用场景就会比较容易理解。

---

## 计数排序的适用场景

+ 数据的范围小；
+ 重复键值多。

例如：年龄、考试成绩等。如果键值有负数和小数的时候怎么办呢？我们可以将参与排序的关键字与非负整数建立一一对应的关系。

说明：计数排序利用了**非负整数**可以作为数组的下标。因此参与排序的元素的值不能太大，否则创建出很大的数组、计算前缀和是浪费资源的。下标是一个非负整数，天然具有顺序性，而通过下标就可以得到每一个数值的个数，通过查询「前缀和」计数数组就能知道它排好序以后所处的位置。

---

## 代码编写

这里为了突出计数排序的基本思想，去掉了一些细枝末节的地方，只考虑待排序数组的值均为非负整数的情况。

**参考代码 1**：

```Java []
public class CountingSort {

    public void sort(int[] nums) {
        int len = nums.length;
        int max = nums[0];
        // 检验数据有效性
        // 找到数组中的最大值，以确定计数数组的长度
        for (int i = 1; i < len; i++) {
            if (nums[i] > max) {
                max = nums[i];
            }
            // 数据有效性校验，因为要将数值作为数组 count 的下标使用，因此 nums[i] 不能小于 0
            if (nums[i] < 0) {
                throw new IllegalArgumentException("该数组不适合使用计数排序");
            }
        }

        // 第 1 步：对原始数组进行计数，这里将原始数组的值，作为了计数数组的下标
        int[] count = new int[max + 1];
        // 遍历原始数组，完成计数
        for (int i = 0; i < len; i++) {
            count[nums[i]] += 1;
        }

        // 第 2 步：将 count 数组改造成前缀和数组，我们需要的是前缀和，在原地进行变换即可
        // 由前缀和数组就可以推出这个元素所在的位置
        for (int i = 1; i <= max; i++) {
            count[i] += count[i - 1];
        }

        // 为了写回去，需要对原始数组做一个拷贝
        int[] numsCopy = new int[len];
        for (int i = 0; i < len; i++) {
            numsCopy[i] = nums[i];
        }
        // 使用 Java 语言可以使用下面这一行代替
        // System.arraycopy(nums, 0, numsCopy, 0, len);

        // 第 3 步：从后向前扫描，依次把看到的数写回原始数组，从后向前是为了保证稳定性
        for (int i = len - 1; i >= 0; i--) {
            // 位置有一个偏移，在纸上写出来就很容易发现规律
            int position = count[numsCopy[i]] - 1;
            // 把看到的数覆盖回去
            nums[position] = numsCopy[i];
            // 前缀和减一，作为下一个看到的相同数存放位置的依据
            count[numsCopy[i]]--;

            // 以上三行，可以用下面这一行代替，但不建议这样写
            // nums[--count[numsCopy[i]]] = numsCopy[i];
        }
    }
}
```

说明：该程序需要自行编写测试用例。

**复杂度分析**：

+ 时间复杂度：$O(N + K)$，这里 $N$ 是数组的长度，$K$ 是数组的最大值。如果 $K$ 很大，会占用很多空间，在计算前缀和计数数组的时候，复杂度也会增加，此时不适合使用计数排序；
    + 统计数组中数值的范围：$O(N)$；
    + 计数需要看数组 1 次：$O(N)$；
    + 计算前缀和计数数组：$O(K)$；
    + 从后向前赋值需要看数组一次。
+ 空间复杂度：$O(N + K)$，根据代码和时间复杂度的分析不难得到。

---

## 总结

+ 计数排序的适用范围：范围小；重复键值多；可以与非负整数建立一一对应关系。
+ 描述「计数排序」算法流程：计算计数数组、将计数数组改造成前缀和数组、从后向前遍历原始数组，依次得到遍历到的数在排好序以后应该在的位置；
+ 计数排序是非原地排序；
+ 计数排序是稳定排序。

我们把之前的表格完善一下：


|          | 最坏时间复杂度 | 平均时间复杂度                     | 最好时间复杂度 | 额外空间复杂度 | 稳定性 | 是否原地排序 |
| -------- | -------------- | ---------------------------------- | -------------- | -------------- | ------ | ------------ |
| 选择排序 | $O(N^2)$       | $O(N^2)$                           | $O(N^2)$       | $O(1)$         | 不稳定 | 原地排序     |
| 冒泡排序 | $O(N^2)$       | $O(N^2)$                           | $O(N)$         | $O(1)$         | 稳定   | 原地排序     |
| 插入排序 | $O(N^2)$       | $O(N^2)$                           | $O(N)$         | $O(1)$         | 稳定   | 原地排序     |
| 希尔排序 | $O(N^2)$       | $O(n^{1.25}) \sim O(1.6 n^{1.25})$ | (没有相关研究) | $O(1)$         | 不稳定 | 原地排序     |
| 归并排序 | $O(N \log N)$  | $O(N \log N)$                      | $O(N \log N)$  | $O(N)$         | 稳定   | 非原地排序   |
| 快速排序 | $O(N^2)$       | $O(N \log N)$                      | $O(N \log N)$  | $O(\log N)$    | 不稳定 | 原地排序     |
| 计数排序 | $O(N + K)$     | $O(N + K)$                         | $O(N + K)$     | $O(N + K)$     | 稳定   | 非原地排序   |

说明：计数排序中， $N$ 是数组的长度，$K$ 是数组的最大值（假设数组的最小值为 $0$）。

---

## 练习

1. 使用计数排序完成「力扣」第 912 题：排序数组（中等）。
说明：注意题目中给出的输入数组元素的取值范围。

---


下一节我们学习基于「计数排序」的「基数排序」。感谢大家。