# 第 5.3 节 桶排序

![image.png](https://pic.leetcode-cn.com/b3efeff54d3dfd06d3394de1f990a733d9a9d1f0f7044d686ce8f1b5aaea2f74-image.png)

---

## 桶排序的基本思想

桶排序使用「分而治之」的思想，将待排序数组分配到若干个桶内，然后再对每个桶各自执行一次排序任务。桶内的排序可以使用不同的排序方法，每个桶内排序完成以后，**依次**将每个桶内的元素取出来，最终得到一个有序数组。

---

## 通过例子理解桶排序的基本思想

![05-03-01](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggzqvvwifdg30u00gw4r8.gif)

+ 将要排序的数分到几个大小相同的子区间里，这些子区间称为「桶」；
+ 分别对每个桶里的数据进行排序（我们这里使用插入排序）；
+ 按照顺序把各个桶中的元素依次取出。

通过这个例子，我们可以归纳出桶排序的适用范围。

---

## 桶排序的适用范围

+ 数据均匀分布，不会出现很多数落在同一个桶中的情况；
+ 如果步长、桶数设置合理，每个桶使用插入排序，即能加快排序，又能保证数据的稳定性。

下面我们来看一下代码，同样是为了突出体现桶排序的基本思想，这里只考虑待排序数组的值均为非负整数的情况。

**参考代码 1**：

```Java []
public class BucketSort {

    public void sort(int[] nums) {
        int len = nums.length;
        int max = nums[0];
        // 第 1 步：找到数组中的最大值，以确定计数数组的长度
        for (int i = 1; i < len; i++) {
            if (nums[i] > max) {
                max = nums[i];
            }
            // 数据有效性校验，因为要将数值作为 count 的索引用，因此 nums[i] 不能小于 0
            if (nums[i] < 0) {
                throw new IllegalArgumentException("该数组不适合使用计数排序");
            }
        }

        // 第 2 步：计算出最大的数字有几位，这个数值决定了桶的个数
        int maxLen = getMaxLen(max);
        // 步长
        int step = 1000;
        // 决定设置几个桶
        if (maxLen < 5) {
            // 如果最大数小于 10000
            // 3 位数就设置 100 个桶
            // 2 位数就设置 10 个桶
            step = (int) Math.pow(10, maxLen - 1);
        }
        // System.out.println("步长：" + step);

        // 桶的个数
        int bucketLen = max / step + 1;
        // System.out.println("桶的个数：" + bucketLen);

        // 因为不能确定每个桶存放的数据量，因此每个桶的长度都设置为 len
        int[][] temp = new int[bucketLen][len];
        int[] next = new int[bucketLen];

        // 第 3 步：分桶
        for (int i = 0; i < len; i++) {
            // 找到所在的桶的索引
            int bucketIndex = nums[i] / step;
            // 在该桶中放入元素
            temp[bucketIndex][next[bucketIndex]] = nums[i];
            // 该桶存放的元素个数 + 1
            next[bucketIndex]++;
        }

        // 第 4 步：对于每个桶执行插入排序
        for (int i = 0; i < bucketLen; i++) {
            insertionSort(temp[i], next[i] - 1);
        }

        // 第 5 步：从桶里依次取出来
        int index = 0;
        for (int i = 0; i < bucketLen; i++) {
            int curLen = next[i];
            for (int j = 0; j < curLen; j++) {
                nums[index] = temp[i][j];
                index++;
            }
        }
    }

    private void insertionSort(int[] arr, int endIndex) {
        for (int i = 1; i <= endIndex; i++) {
            int temp = arr[i];
            int j = i;
            while (j > 0 && arr[j - 1] > temp) {
                arr[j] = arr[j - 1];
                j--;
            }
            arr[j] = temp;
        }

    }

    /**
     * 获取一个整数的最大位数
     *
     * @param num
     * @return
     */
    private int getMaxLen(int num) {
        int maxLen = 0;
        while (num > 0) {
            num /= 10;
            maxLen++;
        }
        return maxLen;
    }
}
```

### 复杂度分析

+ 时间复杂度：$O(N)$，这个复杂度是平均时间复杂度。注意这个结论是线性的，这个结论需要严格证明，不过这个证明过于理论化，有兴趣的朋友可以阅读《算法导论》相关章节的内容。最差时间复杂度是：$O(N^2)$，即：全部数据落在一个桶的时候；

由于我们会在桶排序最合适使用的场景下才使用桶排序，因此不考虑最坏时间复杂度。下面我们给出一个不太严谨的、感性的理解：分桶以后，每个桶使用插入排序的时间复杂度虽为平方级别，如果桶设置合理，桶内的排序可以达到接近线性级别，因此整体时间复杂度为 $O(N)$。

+ 空间复杂度：$O(M)$，这里 $M$ 是一个相对笼统的概念，$M$ 需要根据具体实现的细节来定，如果能够预知每个桶最多能装多少元素，可能这个 $M$ 会很大，如果每个桶设置成为链式结构，$M$ 的值会相对较小一些。

---

## 稳定性和是否原地排序

桶排序是稳定排序，不是原地排序。这里同样是桶内的排序需要是稳定的排序，整体才会是稳定的。

---

## 非比较排序的思想

到此为止，三种非比较的排序我们都介绍完了，我们再回顾一下这三类排序的共同特点。

+ 都需要借助额外的空间完成排序，它们都是非原地排序；
+ 它们都有一定的机制保证了排序的稳定性；
+ 三种非比较排序的应用场景有一定局限性，一般来说，要求数据范围不能太大；
+ 非比较的意思是：程序只需要看到这个元素，这个元素的数值就能决定了它所在位置，而不需要通过和其它元素的比较。这样的思想是**「桶」的思想**，这种思想**是「哈希表」（散列表）思想**的基础。

「力扣」上不会单独考「计数排序」、「基数排序」、「桶排序」，但有一些问题是基于「桶」的思想得以解决的。

---

## 总结

我们继续完善表格：


|          | 最坏时间复杂度 | 平均时间复杂度                     | 最好时间复杂度 | 额外空间复杂度 | 稳定性 | 是否原地排序 |
| -------- | -------------- | ---------------------------------- | -------------- | -------------- | ------ | ------------ |
| 选择排序 | $O(N^2)$       | $O(N^2)$                           | $O(N^2)$       | $O(1)$         | 不稳定 | 原地排序     |
| 冒泡排序 | $O(N^2)$       | $O(N^2)$                           | $O(N)$         | $O(1)$         | 稳定   | 原地排序     |
| 插入排序 | $O(N^2)$       | $O(N^2)$                           | $O(N)$         | $O(1)$         | 稳定   | 原地排序     |
| 希尔排序 | $O(N^2)$       | $O(n^{1.25}) \sim O(1.6 n^{1.25})$ | (没有相关研究) | $O(1)$         | 不稳定 | 原地排序     |
| 归并排序 | $O(N \log N)$  | $O(N \log N)$                      | $O(N \log N)$  | $O(N)$         | 稳定   | 非原地排序   |
| 快速排序 | $O(N^2)$       | $O(N \log N)$                      | $O(N \log N)$  | $O(\log N)$    | 不稳定 | 原地排序     |
| 计数排序 | $O(N + K)$     | $O(N + K)$                         | $O(N + K)$     | $O(N + K)$     | 稳定   | 非原地排序   |
| 基数排序 | $O(KN)$        | $O(KN)$                            | $O(N^2)$       | $O(K + N)$     | 稳定   | 非原地排序   |
| 桶排序   | $O(N^2)$       | $O(N)$                             | $O(N)$         | 根据情况定     | 稳定   | 非原地排序   |

**说明**：

+ 计数排序中， $N$ 是数组的长度，$K$ 是数组的最大值（假设数组的最小值为 $0$）；
+ 基数排序中， $N$ 是数组的长度，$K$ 是最大值的位数（关键字的个数）。

---

## 练习

1. 完成「力扣」第 41 题：缺失的第一个正数（困难）；
2. 完成「力扣」第 268 题：缺失数字（简单）；
3. 完成「力扣」第 287 题：寻找重复数（中等）；
说明：这道题要求「**不能**更改原数组（假设数组是只读的）」，可以暂时无视这一条说明。
4. 完成「力扣」第 442 题：数组中重复的数据（中等）；
5. 完成「力扣」第 448 题：找到所有数组中消失的数字（简单）；
6. 使用桶排序完成「力扣」第 912 题：排序数组（中等）。

---

下一节对排序算法做一个总结，感谢大家。


