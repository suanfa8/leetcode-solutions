# 第 9.3 节 将数组整理成堆

![image.png](https://pic.leetcode-cn.com/1599729230-VSsnex-image.png)


我们前两节所学习的知识，需要将数组中的元素 **一个接一个地** 放进堆中，才能得到一个堆有序的数组。这一节我们介绍一种方式，可以直接将数组整理成堆有序的样子。这种操作称为 `Heapify`（堆化）。

`Heapify` 有两种思路：自上而下和自下而上。

---

## 自顶向下（一般不用）

自上而下的 `Heapify` 的思路其实非常简单：只要从这个二叉堆的第 $2$ 个结点开始，依次执行 `siftUp` 操作即可。其实仔细想一想，这和一个接一个把数组元素添加到一个最大堆中是等价的。 

![image.png](https://pic.leetcode-cn.com/1599568363-dtkFGW-image.png)


每一次执行 `siftUp()` 操作，可以认为是从上至下使得堆有序的部分越来越大。

**参考代码 1**：

说明：`Heapify` 的逻辑通常写在构造函数里。

```Java []
public MaxHeap(int[] arr) {
    // 把外部传来的从下标 0 开始存储数据的数组，赋值给内部从下标 1 开始存储数据的数组
    System.arraycopy(arr, 0, data, 1, size);

    // 自上而下，复杂度为 O(N \logN)
    for (int i = 2; i <= size; i++) {
        siftUp(i);
    }
}
```

---

## 自底向上（推荐做法）

另一种更有效的策略是自底向上依次执行 `siftDown` 操作，向下调整。我们可以 **一下子把整棵树一半以上的元素都跳过** ，从第 $1$ 个非叶子结点处开始执行 `siftDown`。

![image.png](https://pic.leetcode-cn.com/1599571151-fKbcfi-image.png)

在这里我们有必要讨论一下 `siftDown` 的合理性：由于从第 $1$ 个非叶子结点开始，它的上面不是堆有序，但是所有的叶子结点，只有 $1$ 个结点，是堆有序的。因此在自底向上调整堆的过程中，通过 `siftDown` 操作使得堆有序的部分越来越多。

因此，如果大家记不太清楚「自顶向下」和「自底向上」的 `Heapify` 的操作的方向，那没有关系，就想一想：**哪个方向是堆有序的，就应该朝着哪个方向操作，这样才会使得堆有序的部分越来越多**，直至覆盖整个数组。

![image.png](https://pic.leetcode-cn.com/1599571519-TAwztS-image.png)


| 操作     | 具体描述                               | 合理性解释                 | 时间复杂度    |
| -------- | -------------------------------------- | -------------------------- | ------------- |
| 自顶向下 | 从非根结点开始逐个上移（`siftUp`）     | 每一个结点朝上看是堆有序的 | $O(N \log N)$ |
| 自底向上 | 从非叶子结点开始逐个下移（`siftDown`） | 每一个结点朝下看是堆有序的 | $O(N)$        |

在这里要特别说明的是：自底向上建堆的方式，相对于自上而下建堆的方式要快很多。

这是因为：

+ 从执行「上浮」或者「下沉」的次数来看，自底向上少了很多操作。在完全二叉树中，叶子结点的个数几乎占了整棵树结点总数的一半。因此 **有一半以上的结点数都不用操作**。叶子结点不操作，并不意味着它们的位置不会调整，它们会在以后的 `siftDown` 过程中逐渐调整位置；
+ 自顶向下，虽然一开始堆有序的部分很少，但是随着程序的执行，堆有序的部分越来越多。在最后一层叶子结点的部分，**在最糟糕的情况下，每个结点都要执行时间复杂度为 $O(\log N)$ 的操作才能调整到正确的位置**；
+ 自顶向下，越到后面须要时间复杂度为 $O(\log N)$ 才能调整到正确的位置的结点越来越多。而自底向上，最后一步须要 $O(\log N)$ 时间复杂度才能调整到正确的位置的结点越来越少。

以上几点决定了「自底向上」是一种更高效的使得数组「堆有序」的方式，时间复杂度为 $O(N)$（这个结论须要证明，请见参考资料）。因此 `Heapify` 在一般情况下，**特指「自底向上」建堆的方式**。


**参考代码 2**：

```Java [] 
public MaxHeap(int[] arr) {
    capacity = arr.length + 1;
    data = new int[capacity];
    size = arr.length;
    for (int i = 0; i < size; i++) {
        data[i + 1] = arr[i];
    }
    // 从 1 开始编号的堆最后一个非叶子结点的下标是 size / 2 （画图就可以观察出来）
    for (int i = size / 2; i >= 1; i--) {
        siftDown(i);
    }
}
```

有了 `heapify` 的知识作为铺垫，下一节我们介绍「堆排序」的内容。


---

## 练习

+ 可以根据这两节的介绍，为优先队列的实现增加泛型，使用自己实现的优先队列完成「力扣」中标注为「堆」的问题。我们在典型问题中会给出参考代码。

---


## 参考资料

+ 《算法导论》第 6 章，第 6.3 节《建堆》。

---

## 总结

自下而上的建堆方式一开始就排除了一半的结点，这种建堆方式复杂度更低。结论需要有感性的理解：时间复杂度为 $O(N)$，这里 $N$ 是输入数组的长度。如果不是写专业的科研论文，证明可以忽略。

这就是这一节的内容，感谢大家。

