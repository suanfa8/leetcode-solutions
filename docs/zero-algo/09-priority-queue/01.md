# 第 9 章 优先队列

这一章要向大家介绍的数据结构是 **优先队列** ，优先队列在生活中的应用十分广泛。不同于普通的队列，优先队列在元素 **出队** 的时候做了特殊的规定：按照元素的 **优先级顺序** 出队。

优先队列可以帮助我们在一系列 **动态** 发生的任务列表中，高效地寻找优先级最高的任务。

![image.png](https://pic.leetcode-cn.com/1599723977-OqKnXC-image.png)



## 第 9.1 节 优先队列与堆

优先队列是抽象数据类型（Java 用户可以理解只定义接口，不规定实现），堆是具体的、高效的实现。在一些编程语言的实现中，二者不加区分。

---

## 生活中的优先队列

我们每天工作和生活的待办事项，很多时候需要按照一定优先级顺序完成。我们总是最先处理 **最紧急** 或者 **最重要** 的任务。任务列表有一个特点，**它们不会一次性全部呈现在我们面前**，也就是说，它们是动态发生的：

+ 有一些事情会因为一些原因突然变得很重要、很紧急，我们必需最先处理它们（优先级提升）；
+ 还有一些事情可能因为不可控的因素被延后或者取消（优先级下降）。

在服务行业，很多时候并不是先到先得，有些用户对商家的产品投入了大量的金钱和时间，商家把这些用户尊称为 VIP，通常对 VIP 用户的需求最先予以响应，并尽可能提供更高质量的服务。

医院每天在不同时刻都会有人前来诊治，医院需要根据病人的病情决定优先诊治谁，诊治病人的顺序不是按照先到先诊治的顺序进行的。

在操作系统中，如果一个进程到达的时候， CPU 是空闲的，则它会一直占用 CPU 直到该进程结束。如果在这个过程中，有一个比它优先级更高的进程要运行，这个新的（优先级更高的）进程会占用 CPU，而老的线程只有等待这个优先级更高的进程执行完毕，才有机会得到执行。

---

## 什么是优先级

优先级通常被表示成一个 **可以比较** 的数值。有的时候数值越大，优先级越高；有时候数值越小，优先级越高。**数值与优先级的关系，通常是人为定义的**。

为了找到最高优先级的元素，可以对当前所有的数据排序，每一次排序操作时间复杂度为 $O(N \log N)$，整体上时间复杂度是  $O(N^2 \log N)$。这样的操作回答了我们不需要知道的问题。很多场景下我们只需要知道当前优先级最高的那个元素， **不需要维护所有的元素的优先级**。但是，在数据动态变化的场景下，每一次都排序就会很耗时。

优先队列就是一个刚刚好的数据结构，帮助我们在动态的场景下，高效地选取优先级最高的元素。

---

## 优先队列的实现

以我们现在所学的知识，要实现一个优先队列并不难。把所有的待排序的元素放在数组里，有以下两种方案实现优先队列的功能：

+ 有序数组：入队时维护有序性。出队的时候，以 $O(1)$ 的时间复杂度找到优先级最高的元素；
+ 无序数组：事实上也可以不维护优先队列的顺序，在出队的时候遍历数组（时间复杂度 $O(N)$），选出优先级最高的元素。

我们把两种实现方案的「入队」和「出队」操作的时间复杂度列在下面这张表中，发现两种方案 **至少有一个** 操作是线性复杂度，即：在最坏情况下，不得不把整个数组的元素都看一遍。

| 优先队列实现 | 入队   | 出队   |
| -------------- | ------ | ------ |
| 有序数组       | $O(N)$ | $O(1)$ |
| 无序数组       | $O(1)$ | $O(N)$ |

有没有更好的实现方案，能够将「入队」和「出队」的时间复杂度平衡起来。事实上，「堆」就是更高效的数据结构。

根据我们对有序数组和无序数组的分析，我们发现：**如果不改变线性的数据存储的方式，就不能突破时间复杂度为 $O(N)$ 的限制**，因此我们必须考虑其它的数据的组织方式。

---

## 树形结构

事实上，确定当前优先级最高的元素并不需要与所有的其它元素进行比较。在体育比赛中，有一种比赛机制叫做淘汰赛，假设有 $N$ 名选手参赛，决出第 $1$ 名的方式是两两进行一场比赛，输的那一方被淘汰。在这个规则下，只需要进行 $N - 1$ 场比赛就可以确定冠军是谁。

![image.png](https://pic.leetcode-cn.com/1599276082-GLyuMG-image.png)

而确定亚军，只需要对那些 **所有输给冠军** 的选手也按照同样的方式每举行一场比赛，在这些输给冠军的选手里选出那个最优秀的选手，就是亚军。而那些都没有机会和冠军过招的选手，自然就没有必要参与角逐亚军的比赛。

这个例子说明：在优先队列的应用场景下，使用 **树形结构** 是更好的选择。

---

## 完全二叉树与满二叉树

首先我们介绍 **完全二叉树**。完全二叉树首先是一棵二叉树（每个结点最多有 $2$ 棵子树）。「完全」的意思是：在二叉树的基础上，从上至下、从左至右没有空结点。

![image.png](https://pic.leetcode-cn.com/1599523838-fwOAlc-image.png)

如果 **完全二叉树** 的最后一层没有空结点，此时完全二叉树称为 **满二叉树**。将满二叉树每一层结点的个数依次排列开来，是一个 **等比数列**。

注意：有一些教程的满二叉树和完全二叉树的定义与我们不同，大家需要结合语境理解。

### 使用数组表示完全二叉树（重要）

完全二叉树有个重要的性质：它 **可以使用数组表示**。这是因为按照从上至下、从左至右的顺序给完全二叉树编号，任意结点的父亲结点和子结点的下标是有规律的。这一点决定了，在完全二叉树中，左右子结点、父结点可以根据当前下标数值 **互相访问**：

+ 根据父亲结点的下标，可以访问到它的两个子结点；
+ 根据子结点的下标，可以访问到它的唯一的父亲结点。

使用数组存放二叉树的优点是：**不用维护左右子结点、父结点的引用关系**。这是因为如果我们给二叉树的结点的顺序编号，就不难发现它们的规律。下面的图展示了父亲结点的下标与孩子结点的下标的关系。

### 从下标 $0$ 开始存储数据

![image.png](https://pic.leetcode-cn.com/1599523946-CmKupZ-image.png)


我们还可以从下标 $1$ 开始编号，此时从父亲结点和子结点的下标关系从形式上看会更简单一些，少了偏移量的计算。

**说明**：无须记忆这个规律，如果忘记了，可以在纸上画一棵完全二叉树观察得到下标之间关系。

### 从下标 $1$ 开始存储数据

![image.png](https://pic.leetcode-cn.com/1599523983-sfIGbE-image.png)


---

## 堆有序

我们先介绍「最大堆」。最大堆是完全二叉树，满足任意某个结点的值，总是不大于其父亲结点的值。也就是说：从任意一个局部看，子结点的值一定不会超过父结点的值。这是一种特殊意义下的 **有序** 的树形结构，称之为 **堆有序**。

在这种定义下，**树根结点这个元素一定是这棵二叉树中值最大的结点** ，所以「最大堆」也叫做「大顶堆」、「大根堆」。

![image.png](https://pic.leetcode-cn.com/1599724990-TRNbNc-image.png)


同理，可以定义「最小堆」、「小顶堆」、「小根堆」。

![image.png](https://pic.leetcode-cn.com/1599725015-CHmFux-image.png)

> 友情提示：堆中的元素在增加、删除的过程中，始终维护了「堆有序」的性质。这一点也是维护「循环不变量」思想的体现。

如果一个数组表示的树形结构符合上述性质，这个数组称为堆（`Heap`），这个性质称为「堆有序」。我们举的例子总是以数值最大作为优先级最高，此时称为 **最大堆**。而数值越小，优先级越高的堆，称之为 **最小堆**。


---

## 总结

优先队列不同于普通的队列：
+ 普通队列：按照时间顺序出队，先进先出，后进后出；
+ 优先队列：出队顺序与入队顺序无关，按照元素的优先级顺序出队。

请重点理解下面的内容，**特别重要**：
+ 优先队列的应用场景：在 **动态变化** 的数据集合里选出优先级最高的元素，因此没有必要维护所有的元素的大小关系；
+ 为了避免线性扫描，因此将数据组织成 **树形结构**；
+ 优先队列的高效实现是堆，堆是一个完全二叉树，因此 **可以存储在数组里**，并且父亲结点和孩子结点可以很方便地互相访问；
+ 堆只需要维护了 **局部顺序**，时间复杂度更低。

这就是这一节的内容，感谢大家。

