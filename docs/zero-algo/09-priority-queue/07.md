# 第 9.7 节 索引堆（选学）

这一节我们向大家介绍「索引堆」。索引堆，**用数组的下标表示一个堆**，也就是在原来堆的基础上，**维护了数字和下标的信息**。需要说明的是：

+ 索引堆不是一个常见的数据结构，但它并不难理解，只是在刚开始学习的时候，会感觉到有一些绕；
+ 索引堆在绝大多数编程语言里都没有实现，因此需要我们自己编写；
+ 索引堆在普通的堆的基础上加上了「索引数组」和「反向查找」技术，这两个技术也不难，本质上 **都是「空间换时间」思想的应用**。

在「力扣」中可以使用索引堆解决的问题非常有限，我们在这里向大家介绍索引堆的只是，只是做一个补充，即使是「索引数组」和「反向查找」这两个听起来有点高大上的技巧，只要大家深入理解它们设计的思想，就会发现其实没有那么难。

如果大家暂时不需要用到索引堆的内容，或者觉得不感兴趣，或者觉得很难理解，完全可以跳过这部分内容的学习，直接进入下一章。

说明：由于索引堆是专有名词，我们这一节和下一节关于数组「下标」的叙述都换成「索引」，二者表示的意思是等价的。

---


## 需求：堆中的元素优先级发生变化

我们知道优先队列应用于数据是 **动态** 变化的场景，动态变化是指：数据可能随时添加进来，优先级最高的元素处理完成以后我们就不再需要它。

索引堆的出现来源于这样一种需求：数据的优先级是 **动态变化** 的。例如医院的病人的病情有可能突然恶化，此时诊治病人的优先级需要提高；也有可能病人的病情突然好转，此时诊治病人的优先级就相应地需要降低。那么 **如何找到需要提升优先级或者降低优先级的病患**，并修改它的优先级，就需要使用 **索引数组** 的技巧。

「索引数组」将数值和元素的下标做了一一映射，注意：**数组的下标和对应的数据就是一一对应的关系** 。例如：我们想对家人按照身高从低到高进行排序，一种办法是：把一家人都喊到客厅，让他们自己比较身高，找到自己所在的位置。在这个方法里，我们直接面对的是每个人的身高数据。

![image.png](https://pic.leetcode-cn.com/1599801766-ceSWGI-image.png)

如果家人特别多的话，把他们全部喊到客厅排序是一个比较麻烦的事情。一种解决的办法是：把家人和他们的对应的身高一起放在 Excel 表格里，排好序以后，每个人记住自己的相对位置或者绝对位置就可以了。在 Excel 表格里，家人的名字和身高数据 **放置在一行**，表示了对应关系。

如果有一天，妹妹的身高蹿到了 172 cm，我们可以通过妹妹的名字找到她的身高数据，将它修改成 172 cm，然后排在我的后面即可。如果直接面对身高数据，我们需要找到妹妹原来的身高数据，然后修改它。那么问题来了，这里妈妈的身高也是 167 cm。**如何找到妹妹的身高数据，并修改数值** ，是索引堆要解决的问题。数据的 **动态变化** 就体现在这样的场景下。

![image.png](https://pic.leetcode-cn.com/1599802693-HUjivn-image.png)

---

## 索引堆（让索引数组表示的数据堆有序）

左边是一个「堆有序」的树形结构。在建立了对应关系以后，我们使用代表数据的关键字（为了方便说明，我们使用称呼，事实上应该使用 `id`）替换数据，右边的树形结构就是一个索引堆。


![image.png](https://pic.leetcode-cn.com/1599803187-LAJxPW-image.png)


当数据发生变化的时候，可以在索引堆上调整它们的位置。在这个过程中 **称呼和身高的对应关系保持不变**。例如：当我的身高从 170 cm 长到 180 cm 的时候，我的身高数据在索引堆中就上浮到原来的父亲结点：

![image.png](https://pic.leetcode-cn.com/1599803473-WKXGER-image.png)

索引堆就是通过这样的方式达到了 **动态修改数据** 的目的。具体实现上，**只需要在原来最大堆（最小堆）的基础上，添加一个表示索引的数组**，同时维护索引数组，让 **索引数组所表示的数据堆有序** 即可。那么如何维护索引数组，让索引数组堆有序呢？其实很简单，把握住一点即可：**在调整堆的过程中，参与比较的是原始数据，而位置变化体现在索引数组上**。

---

## 代码实现

> 友情提示：可以基于前几节最大堆的实现进行修改，对比添加的逻辑，可以减缓学习的曲线。这些内容不是很难，只是很烦，需要耐心调试而已。再次和大家强调，索引堆不是面试中算法的考点。

添加的逻辑只有 $2$ 个：

+ 把原来 `data` 数组上的操作都换成 `indexes` 数组；
+ 新增 `change()` 方法，实现的功能是：改变某个元素的优先级。



下面我们具体看一下代码实现。


### 把原来 `data` 数组上的操作都换成 `indexes` 数组

初始化 `data` 数组。

**参考代码 1**：

```Java []
private int[] data;
private int[] indexes;
private int size;
private int capacity;

public IndexMaxHeap(int capacity) {
    data = new int[capacity + 1];

    indexes = new int[capacity + 1];

    size = 0;
    this.capacity = capacity;
}
```

具体修改索引堆的操作只会出现在 `siftUp` 和 `siftDown` 中。

> **注意：比较的是 `data` 的值，修改的是 `indexes` 的值。**

**参考代码 2**：

**说明**：这里基于「先暂存，再逐个移动，最后赋值」 的方式添加逻辑。

```Java []
private void siftUp(int k) {
    int tempIndex = indexes[k];
    int tempValue = data[indexes[k]];
    while (k > 1) {
        if (data[indexes[k / 2]] < tempValue) {
            indexes[k] = indexes[k / 2];
            k /= 2;
        } else {
            break;
        }
    }
    indexes[k] = tempIndex;
}
```

因为我们此时需要维护的是 `indexes` 数组的索引，为此我们还需要先把此时在 `k` 这个位置的索引也暂存起来。并且，只要是原来 `data` 数组在的地方，前面需要再套一层 `indexes[k]`（`indexes[k]` 查询到的是在 `k` 这个位置存放的是第几号元素，就相当于通过 `indexes` 数组查到了，这个位置的人的名字一样，然后再放到 `data` 数组中就可以查询到对应的身高数据）。我们需要先把此时在 `k` 位置上的索引先存起来，然后 `siftUp()` 的时候，把父结点以及祖父结点中比自己小的结点的索引值依次向下赋值，直到 `k` 来到了它应该来的位置，把这个位置的索引值赋值成一开始保存的索引值。

`siftDown()` 中也是同样的操作：只要有比较的地方，我们都得先套一层 `indexes`；有赋值的地方，都针对的是 `indexes` 数组赋值。

**参考代码 3**：

```Java []
private void siftDown(int k) {
    int tempIndex = indexes[k];
    int tempValue = data[indexes[k]];
    // 只要它有孩子，注意，这里的等于号是十分关键的
    while (2 * k <= size) {
        int j = 2 * k;
        if (j + 1 <= size && data[indexes[j + 1]] > data[indexes[j]]) {
            j++;
        }
        if (tempValue >= data[indexes[j]]) {
            break;
        }
        indexes[k] = indexes[j];
        k = j;
    }
    indexes[k] = tempIndex;
}
```

对于 `poll()` 和 `offer()` 这两个方法也需要做一点修改：`poll()` 方法，我们更关心的是索引，因此返回的是索引。

**参考代码 4**：

```Java []
public int poll() {
    if (size == 0) {
        throw new IllegalArgumentException("堆为空。");
    }
    int ret = indexes[1];
    indexes[1] = indexes[size];
    size--;
    siftDown(1);
    return ret;
}
```

**参考代码 5**：

```Java []
public void offer(int index, int item) {
    if (size + 1 > capacity) {
        throw new IllegalArgumentException("堆空间已满。");
    }

    // 转换成内部数组的索引
    index++;

    if (index < 1 || index > capacity || indexes[index] != 0) {
        throw new IllegalArgumentException("用户提供的 index 不合法。");
    }

    data[index] = item;
    indexes[index] = index;

    size++;
    // 考虑将它上移
    siftUp(size);
}
```

而 `offer()` 方法，我们的需求则是在某个 `index` 所在的位置插入一个元素。一个可能的应用场景就是，我们刚刚执行了 `poll` 方法，表示 `poll` 那个位置的元素就为空了，然后我们马上在刚刚 `poll` 的那个位置插入一个元素。 

### 新增 `change()` 方法，实现的功能是：改变某个元素的优先级

当然，更普遍的一个方法是 `change()` 我们需要修改一个位置上的元素的优先级。首先我们需要将外部传来的索引做一个转换，因为我们内部的不论是索引数组还是真正存放数组的那个数组，都是以 `1` 开始存放元素的。然后我们需要通过遍历的方式，找到 `i` 在索引数组（索引堆）中的位置，之后将 `j` 这位置执行一次上浮操作，再执行一次下沉操作。让这个修改了优先级以后的元素放在合适的位置。

**参考代码 6**：

```Java []
public void change(int i, int item) {
    i++;
    data[i] = item;
    // 找到 index[j] = i，j 表示 data[i] 在堆中的位置之后 siftUp(j)，再 siftDown(j)
    for (int j = 1; j <= size; j++) {
        if (indexes[j] == i) {
            // 找到了 j
            siftDown(j);
            siftUp(j);
            return;
        }
    }
}
```

这一步得通过遍历的方式去做，这个复杂度是线性的。那么有没有可能不遍历，我直接就能得到 `i` 在索引堆中的位置呢。答案是可以的，我们采用的思路依然是 **空间换时间**，即我们还须要一个数组，存放某个索引在在堆中的位置。这部分的知识点，我们放在下一节介绍。

---

## 总结

索引堆是在原来堆的基础上加上了维护下标的操作，**实现了 `change()` 操作（改变某个元素的优先级）**。 下一节我们介绍 **反向查找** 技术，**反向查找** 听起来有点玄乎，只是理解起来有点绕，但并不是什么高深的技巧。这就是这一节的内容，感谢大家。
