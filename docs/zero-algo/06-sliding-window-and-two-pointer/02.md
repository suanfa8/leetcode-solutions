# 第 6.2 节 滑动窗口经典问题

通过上一节内容的学习，可能大家会觉得滑动窗口问题思想很简单，但是编码比较复杂。这一节的开始，先为大家总结一下，滑动窗口通常写代码的模式，并且再通过一个例子实际应用。

> 友情提示：代码模板不是万能的，需要在理解的基础上加以应用，而不应该死记和照搬。我们的建议是：通过多做一些类似的问题，理解「滑动窗口」的算法设计思想，理解为什么可以使用「滑动窗口」。而不应该被算法模板所限制。

```Java []
public class Solution {

    public String minWindow(String s, String t) {
        // 同方向移动，起始的时候，都位于 0，表示我们定义搜索区间为 [left, right) ，此时区间为空区间
        int left = 0;
        int right = 0;

        while (right < sLen) {

            if ( 在右移的过程中检测是否满足条件 ) {
                // 对状态做修改，好让程序在后面检测到满足条件
            }

            // 右边界右移 1 格
            right++;

            while ( 满足条件 ) {

                // ① 走到这里是满足条件的，左边界逐渐逐渐左移，可以取最小值

                if ( 在左移的过程中检测是否不满足条件 ) {
                    // 对状态做修改，好让程序在后面检测到不满足条件
                }

                // 左边界左移 1 格
                left++;
            }
            // ② 走到这里是不满足条件的，右边界逐渐右移，可以取最大值
        }
        return 需要的结果变量;
    }
}
```

**说明**：什么是条件？条件就是在遍历的过程中，我们需要时刻关注的一些变量的值。对于第 3 题：虽然题目要我们求的是滑动窗口内 **不重复** 的子串的最大值，但我们更关注的是滑动窗口有重复的子串的时候，因此条件就是：滑动窗口 `[left, right)` 有重复。在 ② 处取最大值。

这一节，我们来看另一个经典的滑动窗口问题。

---

## 例题：「力扣」第 76 题：最小覆盖子串

这也是一个经典的滑动窗口问题。我们依然先考虑暴力解法，然后考虑如何优化这个暴力解法。

> 友情提示：滑动窗口问题如果一下子没有思路，先考虑暴力解法，然后再纸上写写画画，进而考虑优化的解法，通常考虑「剪枝」或者「空间换时间」。

### 方法一：暴力求解

以 `输入: S = "ADOBECODEBANC", T = "ABC"` 为例，由于 `T` 中所有的字符都互不相同。我们可以：

+ 枚举 `S` 中长度大于等于 `3` 的所有子串：$O(N^2)$ ；
+ 对这些子串逐个判断是否包含 `T` 的所有字母：$O(N)$；
+ 对满足上述两条的所有子串，取最小值。

总的时间复杂度是 $O(N^3)$。

### 方法二：滑动窗口

下面我们思考如何优化：

一开始的时候，`left` 和 `right` 都位于 0 的位置，`right` 向右移动，直至包含 `T` 的所有字母。因为我们要求的是最小子串，因此，以 `left` 开头的子串 `[left, right + 1]`、 `[left, right + 2]`、……、 `[left, len - 1]` 一定不符合要求。因此可以不用判断；

然后考虑 `left` 如何移动，`left` 不能向左移动，向左移动只能让子串更长，我们要求最小子串，因此  `left` 只能右移，移到 `left` 滑出以后，恰恰好 `[left, right)` 这个区间里面的字符不包含 `T` 所有字母的最小子串；

> 友情提示：这里 `right` 设置成为开区间，表示 `right` 之前的所有元素程序都看到过，并且还有一个好处，`right - left` 的值恰好等于「滑动窗口」的长度。

然后 `right` 继续向右移动，直到包含 `T` 所有字母的最小子串。

重复这样的过程，直到 `right` 到达 `S` 的末尾。怎么样，这个思想是不是和第 3 题是一样的？「滑动窗口」有如下的特点：

+ `right` 先向右移动，移到不能再移动的时候，`left` 再向右移动；
+ `right` 变长刚好满足条件，`left` 变短到刚好不满足条件，然后 `right` 变长刚好满足条件，如此循环下去，直到 `right` 到达末尾。

这里的条件是指：`[left, right)` 包含 `T` 所有字母。这里如何判断区间 `[left, right)` 内包含 `T` 所有字母呢？

由于我们并不关心字母的顺序，因此我们采用的是对比频数数组的方式。

+ 先对 `T` 做频数统计，然后设置一个变量 `distance` 表示 `T` 中一共有多少个不同的字母；
+ `left` 和 `right` 在动的时候，只对 `T` 中出现的字母做统计。

`right` 移动的时候，频数增加，加到刚刚好和 `T` 对应字母相等的时候，`distance - 1`，表示滑动窗口内的字母种类与 `T` 的差距减少了 $1$，当这个差距为 $0$ 的时候，滑动窗口内包含 `T` 所有字母的最小子串。此时考虑移动 `left`；

+ `left` 移动的时候，做减法，减少到刚刚好比 `T` 中对应字符个数少 $1$ 的时候，就说明“平衡”被打破，此时应该 `right` 继续向右移动。


**总结**：

+ `right` 一直往前走，走到 `[left, right]` 包含 `T` 里所有的字母；
+ `right` 和 `left` 同方向；
+ 小技巧：用哈希表或者数组统计不同字母的个数，这样可以保证复杂度最低，具体使用「数组」还是「哈希表」需要根据具体情况具体分析。

**参考代码**：

```Java []
public class Solution {

    public String minWindow(String s, String t) {
        int[] window = new int[128];
        int[] pattern = new int[128];

        final int A = 'A';

        for (Character c : t.toCharArray()) {
            pattern[c - A]++;
        }
        int distance = 0;

        for (int i = 0; i < 128; i++) {
            if (pattern[i] > 0) {
                distance++;
            }
        }

        int sLen = s.length();
        int start = 0;
        int left = 0;
        int right = 0;
        int match = 0;
        int minLen = sLen + 1;

        while (right < sLen) {
            Character curChar = s.charAt(right);
            if (pattern[curChar - A] > 0) {
                window[curChar - A]++;

                if (window[curChar - A] == pattern[curChar - A]) {
                    match++;
                }
            }

            right++;

            while (match == distance) {
                if (right - left < minLen) {
                    start = left;
                    minLen = right - left;
                }

                // 考虑左边界向右边走
                Character leftChar = s.charAt(left);
                if (pattern[leftChar - A] > 0) {
                    window[leftChar - A]--;

                    if (window[leftChar - A] < pattern[leftChar - A]) {
                        match--;
                    }
                }
                left++;
            }
        }
        return minLen == sLen + 1 ? "" : s.substring(start, start + minLen);
    }
}
```

**复杂度分析**：

- 时间复杂度： $O(|S| + |T|)$，这里 $|S|$ 表示字符串 `S` 的长度，这里 $|T|$  表示字符串 `T` 的长度；
- 空间复杂度：$O(|S| + |T|)$ ，如果题目没有提示 `S` 和 `T` 所代表的字符是哪些，或者没有给出字符的 ASCII 值范围，空间复杂度是 $O(|S| + |T|)$。否则像这道题，我们使用了两个长度为 $128$ 的字符频数数组，可以认为空间复杂度是 $O(1)$。

这里还要注意一些细节：

+ `minLen`，一开始要设置一个不可能的值；
+ 同时记录左边界 `left` 和 `minLen`。

与第 3 题对比：

+ 对于这一题，我们需要时刻关注的是：`[left, right)` 内包含 `T` 的所有字母。它就是条件，因此在模板的 ① 处取最小值；
+ 用频数数组、哈希表的区别。

这一节介绍的例题中使用两个数组统计频数进行比对的技巧是比较常见的。

---

## 「滑动窗口」总结

+ `left` 和 `right` 同方向移动，`right` 先向右移动，`left` 再向右移动；
+ 定义循环不变量，即我们需要时刻关注的一件事情，保持变量的定义；
+ 原理：充分利用本题本身的特点，以减少不必要的计算；
+ 利用循环不变量保证代码正确性；
+ 知道什么时候滑动窗口最长，什么时候滑动窗口最短；
+ 字符串处理技巧。

---

## 练习

1. 完成「力扣」第 209 题：长度最小的子数组（中等）；
2. 完成「力扣」第 438 题：找到字符串中所有字母异位词（中等）；
3. 完成「力扣」第 567 题：字符串的排列（中等）；
4. 完成「力扣」第 424 题：替换后的最长重复字符（中等）。

---

「滑动窗口」的部分我们就为大家介绍到这里了，下一节我们介绍「双指针」，感谢大家。
