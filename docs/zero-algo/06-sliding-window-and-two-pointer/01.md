# 第 6 章 数组里常见的两类算法（有修改）

![image-20200723124524603](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0t3yiz7aj31eq0r044p.jpg)

这一章节我们要向大家介绍在数组里常见的两类算法，它们是「滑动窗口」和「双指针」。事实上「滑动窗口」问题也可以理解为是一种特殊的「双指针」的问题。它们都使用了两个变量，在完成 **数组** 的相关任务中发挥了作用。

它们的区别是「两个变量的移动方式不同」：

+ 应用「滑动窗口」的问题，两个变量同向移动；
+ 应用「双指针」的问题，两个变量一头一尾，向着中间移动。我们在第二章学习过的「二分查找」就是一种特殊的应用「双指针」解决的问题。

我们还向大家提及几点：

+ 这里说的「指针」，和 C 语言中的「指针」是两个不同的概念。在「算法和数据结构」领域中可以理解成「变量」，我们使用了一些「变量」完成了任务。在使用这些变量的时候，有意识地遵守了一些不变的性质，这个性质是我们之前多次提到的「循环不变量」。解决数组中的「滑动窗口」和「双指针」问题也都应用了「循环不变量」这个概念，希望大家能够在做题和练习的过程中不断总结；
+ 在数组中，通过下标访问元素是容易的，这是因为数组具有随机访问的特性。因此这两类算法可以有效地应用于在数组上的操作。在链表里也有类似的「双指针」的技巧，但是链表中使用「指针」变量的操作具有一定特殊性，我们在下一章节将会看到；
+ 不管是「滑动窗口」还是「双指针」，它们都是暴力解法的优化（可以理解为剪枝）。因此考虑清楚，为什么可以使用「滑动窗口」（「双指针」）是更重要的，我们建议这一类问题通常都从「暴力解法」开始考虑，思考算法的 **合理性** 和 **有效性** 。

> 友情提示：解决一个问题，方法很重要，更重要的是思考清楚为什么可以使用这个方法。

+ 不要忽视使用「画示意图」帮助分析问题的简单技巧。

---


# 第 6.1 节 滑动窗口简介

以数组为载体完成的任务中，有一类问题以「滑动窗口」为标签。这一类问题的思想其实并不复杂，但是在代码实现的时候，会有一些边界和细节的问题需要考虑。

对于绝大多数「滑动窗口」问题，一般而言，都需要先思考暴力解法，进而思考暴力解法是不是有可以优化的地方。「暴力解法」通常以「二重循环」、「三重循环」的形式出现，优化的思路有：

+ 以空间换时间：在遍历的过程中，记录变量的值，以使得每一次不同规模的区间的相关信息的计算不必从头开始；
+ 利用题目给出的性质，在枚举的过程中，能够一下子 **排除很多不必要的方案** ，以降低时间复杂度。

> 友情提示：滑动窗口的问题通常给我们的感觉是：这个问题并不难，但是我就是很难把它写对，应对这样的现象其实解决方案并不深奥，也是我们之前向大家多次提到过的：在程序出现问题的时候，一定不要忽视调试代码的作用。看一看我们在编写代码的过程中，是不是遵守了循环不变量，把这些变量的值打印出来看一下，或许问题就得到了解决。


「滑动窗口」算法的两个指针变量的移动方向是相同的，形成了一个「窗口」在直线上「滑动」的效果。我们以「力扣」第 3 题：无重复字符的最长子串为例进行讲解。

---

## 例题：「力扣」第 3 题：无重复字符的最长子串

这道题给我们一个字符串，要求我们找出这个字符串中不含有重复字符的 **最长子串** 的长度。首先我们需要弄清楚一个概念：「子串」，它通常区别于「子序列」。它们的区别是：

+ 子串（substring）：在原始数组中一定连续；
+ 子序列（subsequeue）：在原始数组中不一定连续，只需要这些子序列中的元素保持在原始数组中的相对顺序。

### 方法一：暴力解法

一个最直接的思考方案是：

+ 枚举这个字符串的所有子串；
+ 对于每一个子串都判断一下这个子串是否有重复字符；
+ 在从没有重复字符的所有子串中找出长度最长的那个，返回即可。

部分代码如下：

```Java []
public class Solution {

    public int lengthOfLongestSubstring(String s) {
        int len = s.length();

        int maxLen = 1;
        // 枚举到 len - 2 即可
        for (int left = 0; left < len - 1; left++) {
            for (int right = 0; right < len; right++) {
                String subString = s.substring(left, right + 1);
                // 如果 subString 不包含重复元素，记录 subString 的长度，并且维护 maxLen
            }
        }
        return maxLen;
    }
}
```

说明：首先看到一个二重循环，并且最里层的判断「`subString` 不包含重复元素」这个方法也是线性的。因此整体的复杂度是 $O(N^3)$。

下面我们分析，是否有必要暴力枚举左右边界。在枚举的过程中，假设有如下中间状态：

<![image.png](https://pic.leetcode-cn.com/453f28fde89344b7ee11c4bea3d55e6989aa35d2e5be766f448dcb70ae39d411-image.png),![image.png](https://pic.leetcode-cn.com/cca2e099393a9e819610144d5dda33546f0573badb5fda6251297249218402df-image.png),![image.png](https://pic.leetcode-cn.com/8383e0963d868567a7f8c4910e8cb1f57dad4a5cca5808f930bad99b1961aad2-image.png),![image.png](https://pic.leetcode-cn.com/afbf8d7a6275ec3449ac902629f5f37c16ba4ec77509ebb1d74d791aa855cda0-image.png),![image.png](https://pic.leetcode-cn.com/0303b6a7989d28f6eb0ee3afb67024d864094f0c99aadd357f47da9240b2ac35-image.png)>


+ 一开始的时候，`left` 与 `right` 重合，`left` 不动，`right` 尝试向右边扩张，直到 `[left, right]` 中有恰有 1 个重复元素；
+ 如果在子区间 `[left, right]` 中有重复元素，`[left, right + 1]`、`[left, right + 2]` 一直到 `[left, len - 1]` 一定包含重复元素，这一点是这问题可以使用「滑动窗口」的原因。此时就得考虑 `left` 向右移动，这是因为：
  + `left` 不能向左移动：因为向左移动，仍然不能改变 `[left, right]` 中有恰有 $1$ 个重复元素的现状；
  + `left` 只能向右移动，直到 `left` 刚刚好越过 `right` 指向的那个重复的元素为止。
+ 接着有没有必要继续移动 `left` 呢？答案是不可以，因为我们要求的是最长的子串的长度，此时的子串只是局部最长的。我们应该移动 `right` 以期待获得更长的不重复子串；
+ 这样的过程一直进行下去，直到 `right` 到达字符串的末尾。

下面我们分析这个过程为什么比暴力枚举要快。

+ 当我们得到了一个有重复元素的子串的时候，和它 **有相同前缀的所有子串** 都会一下子被排除；
+ 在判断子区间 `[left, right]` 是否有重复字符的时候，我们不必每一次都做扫描。事实上，我们只需要开辟一个字符频数数组，让右边界进来的时候，字符频数加 1，此时检测是否有重复。当左边界滑出的时候，字符频数减 1，此时检测是否无重复；
+ 有重复字符的时候，尝试让左边界 `left` 右移，尝试让区间内无重复字符。没有重复字符的时候，尝试右边界 `right` 右移，以尝试让区间长度更长。

以上就是解决这道问题的基本思路。这种 `right` 主动向右移动，`left` 被动向右移动的方式就是滑动窗口的思想，也叫「尺取法」或者「虫取法」。这个名字可以说是非常形象了，一个资深的裁缝为我们量体裁衣，他很可能就是用右手大拇指在你的肩膀上做「滑动窗口」的样子。下面我们来看一下代码是如何编写的：

说明：编写代码的过程中遵守的 **循环不变量** 是：`[left, right)` 内不包含重复字符。注意，这个区间是左闭右开的，好处是滑动窗口长度 `= right - left`。在一开始的时候，`right` 之前的元素已知，在本轮循环中，希望把 `right` 纳入，保持区间内无重复字符这一性质。

**参考代码 1**：

```Java []
public class Solution {

    public int lengthOfLongestSubstring(String s) {
        int len = s.length();
        if (len < 2) {
            return len;
        }

        char[] charArray = s.toCharArray();
        // 描述 [left, right) 里是否有元素的变量
        int[] freq = new int[128];
        // [left, right) 无重复的元素
        int res = 1;
        for (int left = 0, right = 0; right < len; right++) {
            freq[charArray[right]]++;

            if (freq[charArray[right]] == 2) {
                while (freq[charArray[right]] == 2) {
                    freq[charArray[left]]--;
                    left++;
                }
            }
            res = Math.max(res, right - left + 1);
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是输入字符的长度，`left` 和 `right` 各扫过数组一次；
+ 空间复杂度：$O(M)$，这里 $M$ 表示字符出现的种类数。

说明：

+ 创建字符频数数组，将字符的 ACSII 码作为数组的下标；
+ 右边指针移动的过程中做加法：只要字符频数数组超过 $1$，刚刚好等于 $2$ 的时候，就说明子区间内有重复元素；
+ 左边指针移动的过程中做减法：因为我们的算法在子区间刚刚好有 $1$ 个重复字符的时候，就想方设法让子区间没内有重复元素，因此重复元素的个数有且仅有 $1$ 个，字符频数数组内单个字符的个数最多为 $2$，当左边界指向字符刚刚好减到 $1$ 的时候，就说明子区间内没有重复元素（这样的说法有点绕，希望大家能够通过具体的例子，自己在纸上写写画画想明白）；
+ 在右边指针移动的过程中记录最大值。要特别注意这里记录最大值的位置，不能在 `if (freq[charArray[right]] == 2) {` 之前，因为此时滑动窗口内可能有重复元素，因此，只能在 `if (freq[charArray[right]] == 2) {` 之后。

---

## 滑动窗口的优化

仔细思考我们就会发现：一步一步来到重复元素出现过的地方太慢了，我们是不是可以一下子来到重复元素的后面呢？答案是：完全可以。具体的做法是：在遍历的过程中，不是记录元素的频数（其实在上一种做法里，频次最多也只用到 $2$），而是记录元素出现的位置。

当有重复元素出现的时候，只要这个元素之前出现的下标 **大于等于** 当前滑动窗口左边界的下标，就可以直接跳过来；如果重复元素之前出现的下标严格小于当前滑动窗口左边界的下标，左边界不用移动。

这两种情况，都需要更新当前看到的字符的下标为最新看到的字符的下标。

**参考代码 2**：

Java 代码：滑动窗口的优化。

```Java []
public class Solution {

    public int lengthOfLongestSubstring(String s) {
        // 重复元素上一次出现的位置很重要
        int len = s.length();
        if (len < 2) {
            return len;
        }

        // 当做哈希表使用。key：字符的 ASCII 值，value：最新下标，-1 表示当前字符在遍历的时候还未出现过
        int[] window = new int[128];
        for (int i = 0; i < 128; i++) {
            window[i] = -1;
        }

        char[] charArray = s.toCharArray();

        int res = 1;
        int left = 0;
        // [left, right) 没有重复元素
        for (int right = 0; right < len; right++) {
            if (window[charArray[right]] != -1) {
                left = Math.max(left, window[charArray[right]] + 1);
            }
            window[charArray[right]] = right;
            // 注意理解这里为什么是 + 1
            res = Math.max(res, right - left + 1);
        }
        return res;
    }
}
```

事实上，对于建立字符和某个数值的映射，也可以使用 **哈希表** 做。相信大家不难体会它们二者的差别。

---

这就是这一节的内容。下一节，我们再看一个使用「滑动窗口」解决的经典问题：「最小覆盖子串」，感谢大家。








