# 第 7 节 递归函数的复杂度分析

递归函数本质上是对树形结构或者图形结构的深度优先遍历。如果我们能够很清楚我们所设计的算法只访问了树形结构或者图形结构中的每个结点有限次，那么递归函数的时间复杂度就等于树形结构或者图形结构的结点个数。

另外，分析递归函数的时间复杂读还有一个工具，称为「主定理」。由于「主定理」的理论性很强，只需要知道结论，会应用即可。在面试的时候，绝大多数情况下，不会考察主定理的内容和证明。我严谨的论述请参考《算法导论》第 4.5 节和第 4.6 节的内容。

## 主定理

如果一个规模为 $n$ 的问题，可以拆解为 $a$ 个子问题，每个子问题的规模是 $\cfrac{n}{b}$，其中 $a \ge 1$，$b > 1$。用 $f(n)$ 表示分解和合并的开销与 $n$ 的关系，那么原始问题的时间复杂度 $T(n)$ 可以表示成如下递归式：

$$
T(n) = a \cdot T (\cfrac{n}{b}) + f(n)
$$

将此递推式得到关于 $n$ 的通项公式的时候，需要利用以下结论：

+ 如果 $f(n) < n^{\log_{b}a}$，那么 $T(n) = O(\log n)$；
+ 如果 $f(n) = n^{\log_{b}a}$，那么 $T(n) = O(n^{\log_{b}a} \cdot \log n)$；
+ 如果 $f(n) > n^{\log_{b}a}$，那么 $T(n) = O(f(n))$。

证明过程请参考《算法导论》第 4.6 节（证明主定理）。结论可以这样记忆：

比较 $f(n)$ 与 $n^{\log_{b}a}$ 的大小，如果相等，$T(n)$ 等于 $n^{\log_{b}a}$ 后面乘以 $\log n$。如果不相等，谁大就以谁作为时间复杂度，这一点与「时间复杂度考虑最差情况」的规则一致。

### 例 1：使用主定理计算「二分查找」的时间复杂度

二分查找每一次将问题一分为二，但是只在其中一个子问题里继续求解，此时 $a = 1$，$b = 2$。只有拆分子问题，不用合并子问题，此时 $f(n) = 1$（常数次操作，与 $n$ 无关）。比较 $n^{\log_{b}a} = n^{\log_{2}1} = n^{0} = 1$，套用主定理的第二种情况，此时 $T(n) = O(\log n)$。

### 例 2：根据主定理推导「归并排序」的时间复杂度

二分查找每一次将问题一分为二，然后递归在两个子问题里继续求解，此时 $a = 2$，$b = 2$。拆分子问题使用了 $O(1)$，合并子问题使用了 $f(n) = n$，此时 $f(n) = n$。比较 $n^{\log_{b}a} = n^{\log_{2}2} = n$，套用主定理的第二种情况，此时 $T(n) = O(n \log n)$。