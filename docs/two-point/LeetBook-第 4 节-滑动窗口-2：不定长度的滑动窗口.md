# 第 4 节-滑动窗口-2：不定长度的滑动窗口

有一类数组上的问题，需要使用两个指针变量（我们称为左指针和右指针），**同向**、**交替**向右移动完成任务。这样的过程像极了一个窗口在平面上滑动的过程，因此我们将解决这一类问题的算法称为「滑动窗口」问题。

掌握好这一类「滑动窗口」的问题，需要先从「暴力解法」开始分析，**「滑动窗口」利用了问题本身的特点**，在两个指针同向、交替向右移动的过程中，少考虑了很多「暴力解法」需要考察了情况，将时间复杂度降到了线性级别 $O(N)$（这里 $N$ 是数组的长度），如下图所示。

![image.png](https://pic.leetcode-cn.com/1616666761-qbDEru-image.png)

写对「滑动窗口」除了要弄清楚为什么可以使用滑动窗口，还需要明白代码编写过程中的「循环不变量」，这样才不会在初始化和一些边界问题上出错。我们会在例题讲解的部分和大家进行说明。

---

## 例1：「力扣」第 76 题：最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意**：如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
```

**提示：**

- `1 <= s.length, t.length <= 105`
- `s` 和 `t` 由英文字母组成


**视频题解**：

![76. 最小覆盖子串.mp4]()

### 方法一：暴力求解

以 `输入: S = "ADOBECODEBANC", T = "ABC"` 为例，由于 `T` 中所有的字符都互不相同。我们可以：

+ 枚举 `S` 中长度大于等于 `3` 的所有子串；
+ 对这些子串逐个判断是否包含 `T` 的所有字母；
+ 对满足上述两条的所有子串，取最小值。

枚举所有子串，$O(N^2)$ ，判断是否包含 `T` 的所有字符，$O(N)$。总体的时间复杂度是 $O(N^3)$。下面我们思考如何优化。

### 方法二：滑动窗口

+ 一开始的时候，`left` 和 `right` 都位于下标 `0` 的位置。`right` 向右移动，直至包含 `T` 的所有字母。由于我们要求的是最小子串，因此，以 `left` 开头的子串 `[left..right + 1]`、 `[left..right + 2]`、……、 `[left..len - 1]` 一定不符合要求，因此这些区间可以不用判断；
+ 然后考虑 `left` 如何移动。此时 `left` 不能向左移动，向左移动只能让子串更长，我们要求最小子串，因此  `left` 只能右移，移到恰恰好 `[left..right]` 区间里面的字符不包含 `T` 所有字母的最小子串；
+ 然后 `right` 继续向右移动，直到包含 `T` 所有字母的最小子串。

重复这样的过程，直到 `right` 到达 `S` 的末尾。怎么样，这个思想是不是和第 3 题是一样的，尺取法。

---

「滑动窗口」算法有下面的特点：

+ `right` 先向右移动，移到不能再移动的时候，`left` 再向右移动；
+ `right` 右移使得滑动窗口边长，刚好满足条件，`left` 右移使得滑动窗口变短到刚好不满足条件，然后 `right` 变长刚好满足条件，如此循环下去，直到 `right` 到达末尾。这里的条件是指：`[left, right)` 包含 `T` 所有字母。

那么如何判断区间 `[left, right] ` 内包含 `T` 所有字母呢？由于我们并不关心字母的顺序，因此我们采用的是对比频数数组的方式。

+ 先对 `T` 做频数统计，然后设置一个变量 `distance` 表示 `T` 中一共有多少个不同的字母；
+ `left` 和 `right` 在动的时候，只对 `T` 中出现的字母做统计；
+ `right` 移动的时候，频数增加，加到刚刚好和 `T` 对应字母相等的时候，`distance - 1`，表示滑动窗口内的字母种类与 `T` 的差距减少了 1，当这个差距为 0 的时候，滑动窗口内包含 `T` 所有字母的最小子串。此时考虑移动 `left`；
+ `left` 移动的时候，做减法，减少到刚刚好比 `T` 中对应字符个数少 1 的时候，就说明「平衡」被打破，此时应该 `right` 继续向右移动。


**参考代码**：

```Java []
public class Solution {

    public String minWindow(String s, String t) {
        int[] window = new int[128];
        int[] pattern = new int[128];

        final int A = 'A';

        for (Character c : t.toCharArray()) {
            pattern[c - A]++;
        }
        int distance = 0;

        for (int i = 0; i < 128; i++) {
            if (pattern[i] > 0) {
                distance++;
            }
        }

        int sLen = s.length();
        int start = 0;
        int left = 0;
        int right = 0;
        int match = 0;
        int minLen = sLen + 1;

        while (right < sLen) {
            Character curChar = s.charAt(right);
            if (pattern[curChar - A] > 0) {
                window[curChar - A]++;

                if (window[curChar - A] == pattern[curChar - A]) {
                    match++;
                }
            }

            right++;

            while (match == distance) {
                if (right - left < minLen) {
                    start = left;
                    minLen = right - left;
                }

                // 考虑左边界向右边走
                Character leftChar = s.charAt(left);
                if (pattern[leftChar - A] > 0) {
                    window[leftChar - A]--;

                    if (window[leftChar - A] < pattern[leftChar - A]) {
                        match--;
                    }
                }
                left++;
            }
        }
        return minLen == sLen + 1 ? "" : s.substring(start, start + minLen);
    }
}
```

**细节**：

+ `minLen`，一开始要设置一个不可能的值；
+ 同时记录左边界 `left` 和 `minLen`。


**复杂度分析**：

+ 时间复杂度：$O(|S| + |T|)$，这里 $|S|$ 表示字符串 `S` 的长度，这里 $|T|$ 表示字符串 `T` 的长度；
+ 空间复杂度：$O(|S| + |T|)$，只使用到常数个变量。

---

## 例 2：「力扣」第 424 题：替换后的最长重复字符

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 *k* 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

**注意**：字符串长度 和 *k* 不会超过 $10^4$。

**示例 1：**

```
输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
```

**示例 2：**

```
输入：s = "AABABBA", k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。
```

### 📺 视频讲解 

![424. 替换后的最长重复字符.mp4]()

### 📖 文字解析

如果一个问题暂时没有思路，可以先考虑暴力解法（不一定要实现）。当前问题的暴力解法是：枚举输入字符串的 **所有** 子串，对于每一个子串：

+ 如果子串里所有的字符都一样，就考虑长度更长的子串；
+ 如果当前子串里出现了至少两种字符，要想使得替换以后所有的字符都一样，并且重复的、连续的部分更长，应该替换掉出现次数最多字符 **以外** 的字符。

暴力解法的时间复杂度为 $O(N^3)$（这里 $N$ 是输入字符串的长度，枚举所有子串 $O(N^2)$，对于每一个子串计算最多出现的字符 $O(N)$）。而题目的提示告诉我们字符串长度和 `k` 不会超过 $10^4$，暴力算法在这个数据规模下会超时。

**暴力解法的缺点**：

+ 做了重复的工作，子串和子串有很多重合的部分，重复扫描它们是不划算的；
+ 做了很多没有必要的工作：
  + 如果找到了一个长度为 `L` 且替换 `k` 个字符以后全部相等的子串，就没有必要考虑长度小于等于 `L` 的子串，因为题目只让我们找到符合题意的最长的长度；
  + 如果找到了一个长度为 `L` 且替换 `k` 个字符以后不能全部相等的子串，**左边界相同、长度更长的子串一定不符合要求**（原因我们放在最后说）。

优化暴力解法，我们须要研究一些典型的例子并结合题意找到思路。

---

以 `s = AABCABBB`，`k = 2` 为例，寻找替换 `k` 次以后字符全部相等的最长子串的长度的过程如下图所示：

<![0424.001.jpeg](https://pic.leetcode-cn.com/1612187721-MsiQFf-0424.001.jpeg),![0424.002.jpeg](https://pic.leetcode-cn.com/1612187721-MTivHh-0424.002.jpeg),![0424.003.jpeg](https://pic.leetcode-cn.com/1612187721-dgYLuf-0424.003.jpeg),![0424.004.jpeg](https://pic.leetcode-cn.com/1612187721-xprtnn-0424.004.jpeg),![0424.005.jpeg](https://pic.leetcode-cn.com/1612187721-bESDci-0424.005.jpeg),![0424.006.jpeg](https://pic.leetcode-cn.com/1612187721-bCUXRn-0424.006.jpeg),![0424.007.jpeg](https://pic.leetcode-cn.com/1612187721-RFXxmJ-0424.007.jpeg),![image.png](https://pic.leetcode-cn.com/1612195646-HlfgOl-image.png),![0424.009.jpeg](https://pic.leetcode-cn.com/1612187721-LQJnwd-0424.009.jpeg),![0424.010.jpeg](https://pic.leetcode-cn.com/1612187721-thEJfM-0424.010.jpeg),![0424.011.jpeg](https://pic.leetcode-cn.com/1612187721-FeDdUD-0424.011.jpeg)>

整个过程，我们使用了两个表示边界的变量，一前一后，交替在字符串上前进：右边界先向右和移动，直到它不能移动了为止，左边界再继续向右移动，整个过程像极了一个滑动的窗口在一条线段上移动。

我们还一直关心的是：考虑的子串中最多出现的字符是次数，因此须要一个频数数组，记录每个字符出现的次数。


### 方法：双指针（滑动窗口）

- 右边界先移动找到一个满足题意的可以替换 `k` 个字符以后，所有字符都变成一样的当前看来最长的子串，直到右边界纳入一个字符以后，不能满足的时候停下；
- 然后考虑左边界向右移动，**左边界只须要向右移动一格以后，右边界就又可以开始向右移动了**，继续尝试找到更长的目标子串；
- 替换后的最长重复子串就产生在右边界、左边界交替向右移动的过程中。

> 友情提示：建议大家先自己尝试编码实现，然后提交验证代码的正确性，并且思考清楚代码中的一些细节，相信会是一个非常不错的练习。

**参考代码**：

```Java []
public class Solution {

    public int characterReplacement(String s, int k) {
        int len = s.length();
        if (len < 2) {
            return len;
        }

        char[] charArray = s.toCharArray();
        int left = 0;
        int right = 0;

        int res = 0;
        int maxCount = 0;
        int[] freq = new int[26];
        // [left, right) 内最多替换 k 个字符可以得到只有一种字符的子串
        while (right < len){
            freq[charArray[right] - 'A']++;
            // 在这里维护 maxCount，因为每一次右边界读入一个字符，字符频数增加，才会使得 maxCount 增加
            maxCount = Math.max(maxCount, freq[charArray[right] - 'A']);
            right++;

            if (right - left > maxCount + k){
              	// 说明此时 k 不够用
                // 把其它不是最多出现的字符替换以后，都不能填满这个滑动的窗口，这个时候须要考虑左边界向右移动
                // 移出滑动窗口的时候，频数数组须要相应地做减法
                freq[charArray[left] - 'A']--;
                left++;
            }
            res = Math.max(res, right - left);
        }
        return res;
    }
}
```


**复杂度分析**：

- 时间复杂度：$O(N)$，这里 $N$ 是输入字符串 `S` 的长度；
- 空间复杂度：$O(A)$，这里 $A$ 是输入字符串 `S` 出现的字符 ASCII 值的范围。

---

以下是我们在编码的过程中思考的一些问题。我们建议大家先思考，通过调试，理解代码结果正确的原因。欢迎大家参与讨论。

#### 1. 证明：如果长度为 `L` 的子串不符合题目的要求，那么左边界固定，长度更长的子串也不符合题目的要求。

答：记 $count(X)$ 表示长度为 `L` 的子串中，字符 `X` 出现的次数。

不失一般性，假设长度为 `L` 的子串，出现最多的字符为 `A`，记 $count(A) = x$。其余字符均为 `B`，记 $count(B) = y$。由字符 `A` 出现次数最多，可知 $x \ge y$。又由于长度为 `L` 的子串不符合题目的要求，可知 $y > k$。**起点固定的情况下**，考虑更长的子串：

+ 如果接下来看到的字符都是 `A`（频数最多的字符越来越多），依然须要考虑把之前看到的 `B` 全部替换成为 `A`，由于 $count(B) = y > k$，这是不能做到的；
+ 如果接下来看到的字符不是 `A`（频数较少的字符超过原来频数最多的字符），那么须要考虑把之前看到的 `A` 全部替换成为新的频数最多的字符，由于 $count(A) = x \ge y > k$，这也是不能做到的。

**说明**：这里我们只讨论了滑动窗口扫过的子区间只含有 2 种字符的情况，如果滑动窗口扫过的子区间只含有 3 种以及 3 种以上字符，讨论是类似的。

#### 2. `maxCount` 在内层循环「左边界向右移动一个位置」的过程中，没有维护它的定义，结论是否正确？

**答**：结论依然正确。「左边界向右移动一个位置」的时候，`maxCount` 或者不变，或者值减 $1$。

+ `maxCount` 的值虽然不维护，但数组 `freq` 的值是被正确维护的；
+ 当「左边界向右移动」之前：
  + 如果有两种字符长度相等，左边界向右移动不改变 `maxCount` 的值。例如 `s = [AAABBB]`、`k` = 2，左边界 `A` 移除以后，窗口内字符出现次数不变，依然为 $3$；
  + 如果左边界移除以后，使得此时 `maxCount` 的值变小，又由于 **我们要找的只是最长替换 `k` 次以后重复子串的长度**。接下来我们继续让右边界向右移动一格，有两种情况：① 右边界如果读到了刚才移出左边界的字符，恰好 `maxCount` 的值被正确维护；② 右边界如果读到了不是刚才移出左边界的字符，新的子串要想在符合题意的条件下变得更长，`maxCount` 一定要比之前的值还要更多，因此不会错过更优的解。

#### 3. 内层循环里的 `if` 能不能改成 `while`?

**答**：可以但没有必要。理由依然是：**我们只关心最长替换 `k` 次以后重复子串的长度**。

+ 正是因为多读了一个字符，使得 `right - left > maxCount + k` 成立；
+ 在 `left++` 以后，由于可以不维护 `maxCount` 的定义，`right - left > maxCount + k` 不成立。因此 `if` 里面的代码块只会被执行一次。

#### 4. 可以不用一直用 `res` 记录滑动窗口的最大长度，最后返回 `right - left` 即可。

**答**：依然是 **我们只关心最长替换 `k` 次以后重复子串的长度**，并且 `maxCount` 只会增加不会减少。在退出内层 `if` 语句的时候，区间 `[left, right)` 不一定是符合要求的子串，但是子串的长度一定等于题目要求的替换 `k` 次以后字符全都相等的最长子串（`maxCount` 的值不会变小，所以它会一直撑着滑动窗口的长度直到 `right` 遍历到字符串的末尾）。这一点如果很难理解的话，我们建议大家使用小测试数据、跟踪代码进行理解。

---

## 总结

「滑动窗口」是一类通过使用两个变量在数组上同向交替移动解决问题的算法。这一类问题的思考路径通常是：先思考暴力解法，分析暴力解法的缺点（一般而言暴力解法的缺点是重复计算），然后 **结合问题的特点**，使用「双指针」技巧对暴力解法进行剪枝。因此，**思考算法设计的合理性是更关键的，这一点适用于所有算法问题**。


+ **`left`** 和 **`right`** 同方向移动；
+ 定义条件，即我们需要时刻检测的一件事情；
+ 原理：充分利用本题本身的特点，以减少不必要的计算；
+ 利用「循环不变量」保证代码边界正确；
+ 不要记忆代码模板，应该结合具体问题分析出什么时候滑动窗口最长，什么时候滑动窗口最短；
+ 掌握处理字符串的技巧。

---

## 练习

### 第 1 部分：基础练习

+ 完成「力扣」第 3 题：无重复字符的最长子串；
+ 完成「力扣」第 209 题：长度最小的子数组；
+ 完成「力扣」第 1695 题：删除子数组的最大得分。

---

+ 完成「力扣」第 438 题：找到字符串中所有字母异位词；
+ 完成「力扣」第 567 题：字符串的排列；

---

+ 完成「力扣」第 487 题：最大连续1的个数 II；

+ 完成「力扣」第 1004 题：最大连续 1 的个数 III；
+ 完成「力扣」第 1208 题：尽可能使字符串相等；
+ 完成「力扣」第 1493 题：删掉一个元素以后全为 1 的最长子数组；
+ 完成「力扣」第 1052 题：爱生气的书店老板。

---

+ 完成「力扣」第 978 题：最长湍流子数组。


### 第 2 部分：进阶练习

+ 完成「力扣」第 995 题： K 连续位的最小翻转次数；

+ 完成「力扣」第 727 题：最小窗口子序列；

+ 完成「力扣」第 1100 题：长度为 K 的无重复字符子串；

+ 完成「力扣」第 1151题：最少交换次数来组合所有的 1；

+ 完成「力扣」第 1176题：健身计划评估（会员题）。