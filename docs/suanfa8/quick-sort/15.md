# 「力扣」第 451 题：根据字符出现频率排序（中等）

- 题目链接：[451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)。

## 视频讲解

建议快进播放。

- [「力扣」第 451 题：根据字符出现频率排序](https://www.bilibili.com/video/BV1bT4y167xN?spm_id_from=333.999.0.0&vd_source=8d4c0bb6f04271cbe95d70f568c88555)

## 题目描述

给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

**示例 1:**

```
输入:
"tree"

输出:
"eert"

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

**示例 2:**

```
输入:
"cccaaa"

输出:
"cccaaa"


解释:
'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
```

**示例 3:**

```
输入:
"Aabb"

输出:
"bbAa"

解释:
此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。
注意'A'和'a'被认为是两种不同的字符。
```

**Constraints:**

- `1 <= s.length <= 5 * 10^5`
- `s` 由大小写英文字母和数字组成

## 解释题意

给定一个字符串，请将字符串里的字符按照出现的频率 **降序** 排列。

## 方法一：排序（常见的思路）

把词频计入哈希表，然后排序。

**参考代码**：

```java
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

public class Solution {

    public String frequencySort(String s) {
        int len = s.length();
        if (len == 0) {
            return s;
        }
        Map<Character, Integer> map = new HashMap<>();
        for (Character c : s.toCharArray()) {
            map.put(c, map.get(c) == null ? 1 : map.get(c) + 1);
        }
        Comparator<Character> comparator = (o1, o2) -> {
            if (map.get(o2) - map.get(o1) == 0) {
                // 要注意：如果出现频次相同，要按字母顺序排序， "loveleetcode" 就是一个很好的测试用例
                return o1.compareTo(o2);
            }
            // 注意顺序
            return map.get(o2) - map.get(o1);
        };
        Character[] cArr = new Character[len];
        for (int i = 0; i < len; i++) {
            cArr[i] = s.charAt(i);
        }
        Arrays.sort(cArr, comparator);

        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < len; i++) {
            stringBuilder.append(cArr[i]);
        }
        return stringBuilder.toString();
    }
}
```

## 方法二：三路快排（本题主要想考查的）

- 注意到题目中的说明： `s` 由大小写英文字母和数字组成。所以 `s` 的种类是有限的，有 $26 \times 2 + 10 = 36$ 种，而 `s` 的长度最大是 $5 * 10^5$，因此 **`s` 中有大量重复的值，这一点提示我们可以使用「三路快排」**，代码其实和「三路快排」是一样的，在编码的时候清楚变量的定义就容易写对；
- 下面两版代码的不同只是在于循环不变量的定义（已经作为注释写在代码中），读者只需要实现任意一种。

**参考代码 1**：

```java
import java.util.Random;


class Solution {

    private final static Random random = new Random(System.currentTimeMillis());

    private int[] freq;

    public String frequencySort(String s) {
        freq = new int[128];
        char[] charArray = s.toCharArray();
        for (char c : charArray) {
            freq[c]++;
        }

        quickSort(charArray, 0, s.length() - 1);
        return new String(charArray);
    }

    private void quickSort(char[] charArray, int left, int right) {
        if (left >= right) {
            return;
        }

        // [left..right]
        int randomIndex = left + random.nextInt(right - left + 1);
        swap(charArray, left, randomIndex);

        int pivot = charArray[left];

        int lt = left + 1; // lt: less than
        int gt = right; // ge: greater than
        // all in nums[left + 1..lt) < pivot
        // all in nums[lt..i) = pivot
        // all in nums(gt..right] > pivot
        int i = left + 1;

        while (i <= gt) {
            if (freq[charArray[i]] > freq[pivot]) {
                swap(charArray, i, lt);
                lt++;
                i++;
            } else if (charArray[i] == pivot) {
                i++;
            } else {
                // nums[i] > pivot
                swap(charArray, i, gt);
                gt--;
            }
        }

        swap(charArray, left, lt - 1);

        quickSort(charArray, left, lt - 2);
        quickSort(charArray, gt + 1, right);
    }



    private void swap(char[] charArray, int index1, int index2) {
        char temp = charArray[index1];
        charArray[index1] = charArray[index2];
        charArray[index2] = temp;
    }

}
```

**参考代码 2**：

```java
import java.util.Random;

public class Solution {

    private int[] freq;

    private static final Random RANDOM = new Random(System.currentTimeMillis());

    public String frequencySort(String s) {
        // 先转换为字符数组，以避免 charAt() 方法每次都检查下标有效性
        char[] charArray = s.toCharArray();
        // 题目中的字符只有 a-zA-Z 和数字
        freq = new int[128];
        for (char c : charArray) {
            freq[c]++;
        }

        int len = charArray.length;
        quickSort(charArray, 0, len - 1);
        return new String(charArray);
    }

    private void quickSort(char[] charArray, int left, int right) {
        if (left >= right) {
            return;
        }
        int randomIndex = left + RANDOM.nextInt(right - left + 1);
        swap(charArray, randomIndex, left);

        // 循环不变量定义
        // all in [left + 1..lt] 的频数 > pivot 的频数
        // all in [lt + 1..i) 的频数 = pivot 的频数
        // all in [gt..right] 的频数 < pivot 的频数
        int pivot = charArray[left];
        int lt = left;
        int gt = right + 1;

        int i = left + 1;
        while (i < gt) {
            // 只需要在这句话外面套一层 freq [] ，其它逻辑和快速排序一样
            if (freq[charArray[i]] > freq[pivot]) {
                lt++;
                swap(charArray, i, lt);
                i++;
            } else if (charArray[i] == pivot) {
                i++;
            } else {
                gt--;
                swap(charArray, i, gt);
            }
        }
        swap(charArray, left, lt);
        // 注意这里，大大减少了分治的区间
        quickSort(charArray, left, lt - 1);
        quickSort(charArray, gt, right);
    }

    private void swap(char[] charArray, int index1, int index2) {
        char temp = charArray[index1];
        charArray[index1] = charArray[index2];
        charArray[index2] = temp;
    }
}
```

## 方法三：使用优先队列、二叉搜索树或者桶排序

总之能完成排序就可以，大家可以在「力扣」的题解区找到对应的解法，在这里就不赘述了。

---

作者：liweiwei1419
链接：https://suanfa8.com/quick-sort/solutions/0451-sort-characters-by-frequency
来源：算法吧
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。