# 「力扣」第 962 题：最大宽度坡（中等）

- 题目描述：[962. 最大宽度坡](https://leetcode-cn.com/problems/maximum-width-ramp/)。

## 题目描述

给定一个整数数组 `A`，*坡*是元组 `(i, j)`，其中 `i < j` 且 `A[i] <= A[j]`。这样的坡的宽度为 `j - i`。

找出 `A` 中的坡的最大宽度，如果不存在，返回 0 。

**示例 1：**

```
输入：[6, 0, 8, 2, 1, 5]
输出：4
解释：
最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.
```

**示例 2：**

```
输入：[9, 8, 1, 0, 1, 9, 4, 0, 4, 1]
输出：7
解释：
最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.
```

**提示：**

1. `2 <= A.length <= 50000`
2. `0 <= A[i] <= 50000`

## 理解题意

- 题目要找的是「**下标** 元组 `(i, j)`，其中 `i < j` 且 `A[i] <= A[j]`」，不要求 `i` 和 `j` 之间的元素保持单调，并且要求找 `j - i` 的最大值。因此我们希望 `i` 尽可能小，`j` 尽可能大。

## 思路分析

- 找一个元素左边比自己小的元素可以使用「栈」；
- 用「栈」可以找的左边（右边）**第一个** 比自己小或者比自己大的元素，我们这里都看左边（以看左边为例进行讲解）。都看右边也是可以的，代码可以「对称地」写出来；
- 下面思考：我们要找「左边比自己小」还是「左边比自己大」？
  - 如果找「左边比自己小」，使用「栈」只能找到第一个比自己小；
  - 但是我们要找的是「左边距离自己最远的、比自己还小（不大于）的元素的位置」，因此我们就需要找「左边比自己还大的第一个元素的位置」，这个元素之前的那个位置就是「左边距离自己最远的、比自己还小（不大于）的元素的位置」（**重点在这里**）。

## 具体做法

- 因此我们从左到右遍历输入数组，找出从下标 `0` 开始数值依次递减（**单调不增**）的 **下标** 存起来（**重点在这里**），这些下标都有可能构成题目要找的下标元组的 `i`。

  > 解释：题目要找的是 `j - i` 的最大值，因此如果数组中的两个元素值相等，右边还有比当前值还大的元素，取靠左的元素的下标为 `i`。



![参考代码第 1 部分示意图](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/202301250102794.png)

- 然后 **从右向左** 遍历输入数组，如果遇到比之前保存下标的元素还要大（不小于）的元素，此时记录下来，直到遇到比自己还大的元素就停下来。

  > 解释：因为要保证 `j` 尽可能大，所以 `j` 从右边向左边遍历。


![参考代码第 2 部分示意图](https://suanfa8-1252206550.cos.ap-shanghai.myqcloud.com/202301250102142.png)

**参考代码**：

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Solution {

    public int maxWidthRamp(int[] nums) {
        int len = nums.length;

        Deque<Integer> stack = new ArrayDeque<>();
        stack.addLast(0);
        // 下标 0 已经被添加到栈中，所以遍历从 1 开始
        for (int i = 1; i < len; i++) {
            if (nums[i] <= nums[stack.peekLast()]) {
                stack.addLast(i);
            }
        }

        int res = 0;
        for (int i = len - 1; i >= 0; i--) {
            while (!stack.isEmpty() && nums[i] >= nums[stack.peekLast()]) {
                res = Math.max(res, i - stack.removeLast());
            }
        }
        return res;
    }
}
```

- 时间复杂度：$O(N)$，这里 $N$ 是输入数组的长度。我们遍历了两次输入数组，因此时间复杂度为 $O(N)$。



---

作者：liweiwei1419
链接：https://suanfa8.com/stack/solutions-2/0962-maximum-width-ramp
来源：算法吧
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。