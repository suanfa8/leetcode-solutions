> 专题名称：深度优先遍历与回溯算法。

# 第 1 节 勇往直前的深度优先遍历

![image.png](https://pic.leetcode-cn.com/1611504979-HoeCGp-image.png)


在线性结构中，按照顺序一个一个地看到所有的元素，称为线性遍历。在非线性结构中，由于元素之间的组织方式变得复杂，就有了不同的遍历行为。其中最常见的遍历有：深度优先遍历（Depth-First-Search）和广度优先遍历（Breadth-First-Search）。它们的思想非常简单，但是在算法的世界里发挥着巨大的作用。

> 友情提示：大家先不要纠结这里「Search」为什么翻译成「遍历」，可以认为「遍历」和「搜索」是一回事。

本专题将为大家详解「深度优先遍历」。

## 深度优先遍历的形象描述

「一条路走到底，不撞南墙不回头」是对「深度优先遍历」的最直观描述。下面的视频演示了以「深度优先遍历」的方式「走迷宫找出口」的搜索轨迹。

![深度搜索迷宫.mp4]()

**说明**：

+ 深度优先遍历 **只要前面有可以走的路**，就会一直向前走，直到无路可走才会回头；
+ 「无路可走」有两种情况：① 遇到了墙；② 遇到了已经走过的路；
+ 在「无路可走」的时候，**沿着原路返回**，直到回到了还有未走过的路的路口，尝试继续走没有走过的路径；
+ 有一些路径没有走到，这是因为找到了出口，程序就停止了；
+ 「深度优先遍历」也叫「深度优先搜索」，遍历是行为的描述，搜索是目的（用途）；
+ 遍历不是很深奥的事情，把 **所有** 可能的情况都看一遍，才能说「找到了目标元素」或者「没找到目标元素」。遍历也称为 **穷举**，穷举的思想在人类看来虽然很不起眼，但借助 **计算机强大的计算能力**，穷举可以帮助我们解决很多专业领域知识不能解决的问题。

> 友情提示：深度优先遍历的思想是简单、常见的。在「力扣」上很多标注为「树」和「图」的问题，其实就是要求我们在「树」或者「图」上执行一次「深度优先遍历」或者「广度优先遍历」。

---

## 初识「搜索」

「遍历」和「搜索」可以看作是两个的等价概念，通过遍历 **所有** 的可能的情况达到搜索的目的。遍历是手段，搜索是目的。因此「深度优先遍历」也叫「深度优先搜索」。

关于搜索，有一些概念，我们会放在「回溯算法」（第 4 节）向大家介绍。

---

## 树的深度优先遍历

我们以「二叉树」的深度优先遍历为例，向大家介绍树的深度优先遍历。

二叉树的深度优先遍历从「根结点」开始，依次 「**递归地**」 遍历「左子树」的所有结点和「右子树」的所有结点。

![image.png](https://pic.leetcode-cn.com/1608889478-JaYKMr-image.png)

事实上，「根结点 → 右子树 → 左子树」也是一种深度优先遍历的方式，为了符合人们「先左再右」的习惯。如果没有特别说明，我们在这个专题里，树的深度优先遍历默认都按照 「根结点 → 左子树 → 右子树」 的方式进行。

**二叉树深度优先遍历的递归终止条件**：遍历完一棵树的 **所有** 叶子结点，等价于遍历到 **空结点**。大家可以点击下面的幻灯片查看深度优先遍历的结果。

<![07-01-01.001.jpeg](https://pic.leetcode-cn.com/1608633232-LvvNrt-07-01-01.001.jpeg),![07-01-01.002.jpeg](https://pic.leetcode-cn.com/1608633232-cdkRjE-07-01-01.002.jpeg),![07-01-01.003.jpeg](https://pic.leetcode-cn.com/1608633232-MmryEl-07-01-01.003.jpeg),![07-01-01.004.jpeg](https://pic.leetcode-cn.com/1608633232-upwVXJ-07-01-01.004.jpeg),![07-01-01.005.jpeg](https://pic.leetcode-cn.com/1608633232-rYArfw-07-01-01.005.jpeg),![07-01-01.006.jpeg](https://pic.leetcode-cn.com/1608633232-dWOteP-07-01-01.006.jpeg),![07-01-01.007.jpeg](https://pic.leetcode-cn.com/1608633232-pILTok-07-01-01.007.jpeg),![07-01-01.008.jpeg](https://pic.leetcode-cn.com/1608633232-yreIwJ-07-01-01.008.jpeg),![07-01-01.009.jpeg](https://pic.leetcode-cn.com/1608633232-BfKKOc-07-01-01.009.jpeg),![07-01-01.010.jpeg](https://pic.leetcode-cn.com/1608633232-Mgyzff-07-01-01.010.jpeg),![07-01-01.011.jpeg](https://pic.leetcode-cn.com/1608633232-MlNfoH-07-01-01.011.jpeg),![07-01-01.012.jpeg](https://pic.leetcode-cn.com/1608633232-JanTsZ-07-01-01.012.jpeg)>

二叉树的深度优先遍历还可以分为：前序遍历、中序遍历和后序遍历。

### 1. 前序遍历

对于任意一棵子树，先输出根结点，再递归输出左子树的 **所有** 结点、最后递归输出右子树的 **所有** 结点。上图前序遍历的结果就是深度优先遍历的结果：`[0、1、3、4、7、2、5、8、9、6、10]`。

### 2. 中序遍历

对于任意一棵子树，先递归输出左子树的 **所有** 结点，然后输出根结点，最后递归输出右子树的 **所有** 结点。上图中序遍历的结果是：`[3、1、7、4、0、8、5、9、2、10、6]`。

### 3. 后序遍历（重要）

对于任意一棵子树，总是先递归输出左子树的 **所有** 结点，然后递归输出右子树的 **所有** 结点，最后输出根结点。后序遍历体现的思想是：**先必需得到左右子树的结果，才能得到当前子树的结果**，这一点在解决一些问题的过程中非常有用。上图后序遍历的结果是：`[3、7、4、1、8、9、5、10、6、2、0]`。

> 友情提示：后序遍历是非常重要的遍历方式，解决很多树的问题都采用了后序遍历的思想，请大家务必重点理解「后序遍历」一层一层向上传递信息的遍历方式。并在做题的过程中仔细体会「后序遍历」思想的应用。

### 4. 为什么前、中、后序遍历都是深度优先遍历

可以把树的深度优先遍历想象成一只蚂蚁，从根结点绕着树的外延走一圈。每一个结点的外延按照下图分成三个部分：前序遍历是第一部分，中序遍历是第二部分，后序遍历是第三部分。

![image.png](https://pic.leetcode-cn.com/1610298406-MwKKNZ-image.png)


只看结点的第一部分（红色区域），深度优先遍历到的结点顺序就是「前序遍历」的顺序。

![前序遍历.mp4]()

只看结点的第二部分（黄色区域），深度优先遍历到的结点顺序就是「中序遍历」的顺序。

![中序遍历.mp4]()

只看结点的第三部分（绿色区域），深度优先遍历到的结点顺序就是「后序遍历」的顺序。

![后序遍历.mp4]()


### 5. 重要性质

根据定义不难得到以下性质。

+ 性质 1：二叉树的 **前序遍历** 序列，根结点一定是 **最先** 访问到的结点；
+ 性质 2：二叉树的 **后序遍历** 序列，根结点一定是 **最后** 访问到的结点；
+ 性质 3：根结点把二叉树的 **中序遍历** 序列划分成两个部分，第一部分的所有结点构成了根结点的左子树，第二部分的所有结点构成了根结点的右子树。

> 友情提示：根据这些性质，可以完成「力扣」第 105 题、第 106 题，这两道问题是面试高频问题，请大家务必掌握。

---

## 图的深度优先遍历

深度优先遍历有「回头」的过程，在树中由于不存在「环」（回路），对于每一个结点来说，每一个结点只会被递归处理一次。而「图」中由于存在「环」（回路），就需要 **记录已经被递归处理的结点**（通常使用布尔数组或者哈希表），以免结点被重复遍历到。



<![07-01-02.001.jpeg](https://pic.leetcode-cn.com/1608889688-UqYymK-07-01-02.001.jpeg),![07-01-02.002.jpeg](https://pic.leetcode-cn.com/1608889688-AECIhd-07-01-02.002.jpeg),![07-01-02.003.jpeg](https://pic.leetcode-cn.com/1608889688-DjnOCs-07-01-02.003.jpeg),![07-01-02.004.jpeg](https://pic.leetcode-cn.com/1608889688-YNKsgU-07-01-02.004.jpeg),![07-01-02.005.jpeg](https://pic.leetcode-cn.com/1608889688-nJsZtU-07-01-02.005.jpeg),![07-01-02.006.jpeg](https://pic.leetcode-cn.com/1608889688-OAdkcr-07-01-02.006.jpeg),![07-01-02.007.jpeg](https://pic.leetcode-cn.com/1608889688-DqZbOf-07-01-02.007.jpeg)>

**说明**：深度优先遍历的结果通常与图的顶点如何存储有关，所以图的深度优先遍历的结果并不唯一。例如上面这张图，从顶点 `0` 开始进行深度优先遍历的结果还可能是 `[0, 5, 4, 3, 2, 1]`。


---

## 练习

下面这些练习可能是大家在入门「树」这个专题的过程中做过的问题，以前我们在做这些问题的时候可以总结为：树的问题可以递归求解。现在我们可以用「深度优先遍历」的思想，特别是「后序遍历」的思想重新看待这些问题。

请大家通过这些问题体会 「**如何设计递归函数的返回值**」 帮助我们解决问题。并理解这些简单的问题其实都是「深度优先遍历」的思想中「后序遍历」思想的体现，真正程序在执行的时候，是通过「一层一层向上汇报」的方式，最终在根结点汇总整棵树遍历的结果。

1. 完成「力扣」第 104 题：二叉树的最大深度（简单）：设计递归函数的返回值；
2. 完成「力扣」第 111 题：二叉树的最小深度（简单）：设计递归函数的返回值；
3. 完成「力扣」第 112 题：路径总和（简单）：设计递归函数的返回值；
4. 完成「力扣」第 226 题：翻转二叉树（简单）：前中后序遍历、广度优先遍历均可，中序遍历有一个小小的坑；
5. 完成「力扣」第 100 题：相同的树（简单）：设计递归函数的返回值；
6. 完成「力扣」第 101 题：对称二叉树（简单）：设计递归函数的返回值；
7. 完成「力扣」第 129 题：求根到叶子节点数字之和（中等）：设计递归函数的返回值。
8. 完成「力扣」第 236 题：二叉树的最近公共祖先（中等）：使用后序遍历的典型问题。

---

请大家完成下面这些树中的问题，加深对前序遍历序列、中序遍历序列、后序遍历序列的理解。

9. 完成「力扣」第 105 题：从前序与中序遍历序列构造二叉树（中等）；
10. 完成「力扣」第 106 题：从中序与后序遍历序列构造二叉树（中等）；
11. 完成「力扣」第 1008 题：前序遍历构造二叉搜索树（中等）；
12. 完成「力扣」第 1028 题：从先序遍历还原二叉树（困难）。

> **友情提示**：需要用到后序遍历思想的一些经典问题，这些问题可能有一些难度，可以不用急于完成。先做后面的问题，见多了类似的问题以后，慢慢理解「后序遍历」一层一层向上汇报，在根结点汇总的遍历思想。

---


## 总结

+ 遍历可以用于搜索，思想是穷举，遍历是实现搜索的手段；
+ 树的「前、中、后」序遍历都是深度优先遍历；
+ 树的后序遍历很重要；
+ 由于图中存在环（回路），图的深度优先遍历需要记录已经访问过的结点，以避免重复访问；
+ 遍历是一种简单、朴素但是很重要的算法思想，很多树和图的问题就是在树和图上执行一次遍历，在遍历的过程中记录有用的信息，得到需要结果，区别在于为了解决不同的问题，在遍历的时候传递了不同的 **与问题相关** 的数据。


