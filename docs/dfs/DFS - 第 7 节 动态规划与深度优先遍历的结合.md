# 第 7 节 动态规划与深度优先遍历思想的结合

深度优先遍历是一种重要的算法设计思想，可以用于解决「力扣」上很多问题，熟练掌握「深度优先遍历」以及与之相关的「递归」、「分治」思想的应用是十分有帮助的。事实上，有一类问题需要「深度优先遍历」思想与「动态规划」思想的结合。

## 树形动态规划问题

在动态规划问题里，有一类问题叫做「树形动态规划 DP」问题。这一类问题通常的解决的思路是：通过对树结构执行一次深度优先遍历，采用 **后序遍历** 的方式，一层一层向上传递信息，并且利用「无后效性」的思想（固定住一些状态，或者对当前维度进行升维）解决问题。即这一类问题通常采用「后序遍历」 + 「动态规划（无后效性）」的思路解决。

> 友情提示：「无后效性」是「动态规划」的一个重要特征，也是一个问题可以使用「动态规划」解决的必要条件，「无后效性」就是字面意思：当前阶段的状态值一旦被计算出来就不会被修改，即：在计算之后阶段的状态值时不会修改之前阶段的状态值。
>
> 利用「无后效性」解决动态规划问题通常有两种表现形式：
>
> + 对当前维度进行「升维」，在「自底向上递推」的过程中记录更多的信息，避免复杂的分类讨论；
>
> + 固定住一种的状态，通常这种状态的形式最简单，它可以组合成复杂的状态。
>
> 理解「无后效性」需要做一些经典的使用「动态规划」解决的问题。例如：「力扣」第 62 题、第 120 题、第 53 题、第 152 题、第 300 题、第 1142 题。

### 例 ：「力扣」第 543 题：二叉树的直径（简单）

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例**：

给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 `[4, 2, 1, 3]` 或者 `[5, 2, 1, 3]`。

**注意**：两结点之间的路径长度是以它们之间边的数目表示。

---

**思路分析**：

+ 首先理解题意。在题目最后的「注意」中有强调：**两个结点之间边的数目为直径**，而不是结点的数目；
+ 要了解树当中的信息，通常来说需要执行一次 **深度优先遍历**，最后在根结点汇总值，自底向上，一层一层向上汇报信息，这是 **后序遍历**；
+ 我们再看直径的概念，题目中已经强调了：直径可能穿过也可能不穿过根结点。并且示例给出的路径 `[4, 2, 1, 3]` 或者 `[5, 2, 1, 3]` 是弯曲的，不是「从根结点到叶子结点的最长路径」，**因此一条路径是否经过某个结点，就需要分类讨论**。在动态规划里，可以利用一个概念，叫做「无后效性」，即：将不确定的事情确定下来，以方便以后的讨论。

我们采用逐步完善代码的方式向大家展示编码过程，首先写出代码大致的框架，请大家留意代码中的注释，注释体现了编码的思路。

**阶段代码**：

```Java []
public class Solution {

    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return res;
    }


    /**
     * @param node 某个子树的根结点
     * @return 必需经过当前 node 结点的「单边」路径长度的「最大值」，这是动态规划「无后效性」的应用
     */
    private int dfs(TreeNode node) {
        // 递归终止条件
      	if (node == null) {
            return 0;
        }

				// 根据左右子树的结果，再得到当前结点的结果，这是典型的「后序遍历」的思想   
        int left = dfs(node.left);
        int right = dfs(node.right);

      	// 注意：递归函数的返回值的定义，必需经过 node 并且只有一边
        return Math.max(left, right) + 1;
    }
}
```

**注意**：这里递归函数 `dfs` 的定义，有两点很重要：① 必需经过当前 `node` 结点，也就是说当前结点 `node` 必需被选取，这一点是我们上面向大家介绍的「固定住」一些信息，方便分类讨论；② 「单边路径」是我们为了方便说明这个问题引入的概念。「单边路径」指的是 `node` 作为某一条路径的端点，它或者是「左端点」或者是「右端点」，它一定不是位于在这条路径中间的结点。

![image.png](https://pic.leetcode-cn.com/1609644818-NmdQVB-image.png)

比较难理解的地方是：为什么只讨论「单边路径」？这是因为「单边」的情况最简单，是可以拆分的最小单元。「弯曲」的情况可以由「单边」的情况组合而成。

**题目要求的直径，可以「弯曲」。「弯曲」的部分就是「左边单边」的长度 + 「右边单边」的长度之和，可以在遍历的过程中记录最大值**。

完整代码：

```Java []
public class Solution {

    private int res;

    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return res;
    }


    /**
     * @param node
     * @return 必需经过当前 node 结点的路径长度的「最大值」
     */
    private int dfs(TreeNode node) {
        if (node == null) {
            return 0;
        }

        int left = dfs(node.left);
        int right = dfs(node.right);
        // 注意：在深度优先遍历的过程中，记录最大值
        res = Math.max(res, left + right);

        return Math.max(left, right) + 1;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，这里 $N$ 是树的结点总数；
+ 空间复杂度：$O(N)$，空间复杂度取决于递归调用栈的深度。

## 练习

1. 完成「力扣」第 124 题：二叉树中的最大路径和（困难）；
2. 完成「力扣」第 298 题：二叉树最长连续序列（中等）；
3. 完成「力扣」第 549 题：二叉树中最长的连续序列（中等）；
4. 完成「力扣」第 687 题：最长同值路径（中等）；
5. 完成「力扣」第 865 题：具有所有最深节点的最小子树（中等）；
6. 完成「力扣」第 1372 题：二叉树中的最长交错路径（中等）。

---

下面的问题可以使用「二分答案 + DFS 或者 BFS」的思想解决。

7. 完成「力扣」第 1102 题：得分最高的路径（中等）；
8. 完成「力扣」第 1631 题：最小体力消耗路径（中等）；
9. 完成「力扣」第 778 题：水位上升的泳池中游泳（困难）；
10. 完成「力扣」第 403 题：青蛙过河（困难）。

## 总结

+ 深度优先遍历的直观理解非常重要，支撑深度优先遍历实现的数据结构是「栈」；
+ 「力扣」上很多树和图的问题都可以通过深度优先遍历实现、使用深度优先遍历实现的问题很多时候也可以使用广度优先遍历实现；
+ 「回溯算法」是深度优先遍历算法的应用；
+ 「回溯算法」的细节很多，需要通过练习和调试理解。